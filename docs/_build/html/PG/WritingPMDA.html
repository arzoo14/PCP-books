

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. Writing A PMDA &mdash; pcp  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. PMAPI–The Performance Metrics API" href="PMAPI.html" />
    <link rel="prev" title="1. Programming Performance Co-Pilot" href="ProgrammingPcp.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> pcp
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/AboutUAGGuide.html">About User’s and Administrator’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="AboutPGGuide.html">About Programmer’s Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User's and Administrator's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/IntroductionToPcp.html">1. Introduction to PCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/InstallingAndConfiguringPcp.html">2. Installing and Configuring Performance Co-Pilot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CommonConventionsAndArguments.html">3. Common Conventions and Arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/MonitoringSystemPerformance.html">4. Monitoring System Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PerformanceMetricsInferenceEngine.html">5. Performance Metrics Inference Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/ArchiveLogging.html">6. Archive Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PcpDeploymentStrategies.html">7. Performance Co-Pilot Deployment Strategies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CustomizingAndExtendingPcpServices.html">8. Customizing and Extending PCP Services</a></li>
</ul>
<p class="caption"><span class="caption-text">Programmer's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ProgrammingPcp.html">1. Programming Performance Co-Pilot</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Writing A PMDA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#implementing-a-pmda">2.1. Implementing a PMDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pmda-architecture">2.2. ⁠PMDA Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">2.2.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dso-pmda">2.2.2. DSO PMDA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#daemon-pmda">2.2.3. Daemon PMDA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#caching-pmda">2.2.4. Caching PMDA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#domains-metrics-instances-and-labels">2.3. Domains, Metrics, Instances and Labels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">2.3.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domains">2.3.2. Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#metrics">2.3.3. Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-structures">2.3.3.1. Data Structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semantics">2.3.3.2. Semantics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#instances">2.3.4. Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#instance-identification">2.3.4.1. Instance Identification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#n-dimensional-data">2.3.4.2. N Dimensional Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.3.4.3. Data Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#labels">2.3.5. Labels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#label-hierarchy">2.3.5.1. Label Hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">2.3.5.2. Data Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-issues">2.4. Other Issues</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extracting-the-information">2.4.1. Extracting the Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#latency-and-threads-of-control">2.4.2. Latency and Threads of Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#name-space">2.4.3. Name Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pmda-help-text">2.4.4. PMDA Help Text</a></li>
<li class="toctree-l3"><a class="reference internal" href="#management-of-evolution-within-a-pmda">2.4.5. Management of Evolution within a PMDA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pmda-interface">2.5. PMDA Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">2.5.1. Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#trivial-pmda">2.5.1.1. Trivial PMDA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-pmda">2.5.1.2. Simple PMDA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-store-in-the-simple-pmda">2.5.1.3. simple_store in the Simple PMDA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-codes-for-pmdafetch-callbacks">2.5.1.4. Return Codes for pmdaFetch Callbacks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmda-structures">2.5.2. PMDA Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-a-pmda">2.6. Initializing a PMDA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">2.6.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-initialization">2.6.2. Common Initialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.6.2.1. Trivial PMDA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">2.6.2.2. Simple PMDA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#daemon-initialization">2.6.3. Daemon Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#testing-and-debugging-a-pmda">2.7. Testing and Debugging a PMDA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">2.7.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-information">2.7.2. Debugging Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dbpmda-debug-utility">2.7.3. dbpmda Debug Utility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#integration-of-a-pmda">2.8. Integration of a PMDA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-a-pmda">2.8.1. Installing a PMDA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#removing-a-pmda">2.8.2. Removing a PMDA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-pcp-tools">2.8.3. Configuring PCP Tools</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="PMAPI.html">3. PMAPI–The Performance Metrics API</a></li>
<li class="toctree-l1"><a class="reference internal" href="InstrumentingApplications.html">4. Instrumenting Applications</a></li>
</ul>
<p class="caption"><span class="caption-text">REST API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../REST_API/PMWEBAPI.html">PMWEBAPI</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>2. Writing A PMDA</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/PG/WritingPMDA.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-a-pmda">
<span id="writingpmda"></span><h1><a class="toc-backref" href="#id9">2. Writing A PMDA</a><a class="headerlink" href="#writing-a-pmda" title="Permalink to this headline">¶</a></h1>
<p>This chapter constitutes a programmer’s guide to writing a Performance Metrics Domain Agent (PMDA) for Performance Co-Pilot (PCP).</p>
<p>The presentation assumes the developer is using the standard PCP <strong>libpcp_pmda</strong> library, as documented in the <strong>PMDA(3)</strong> and associated man pages.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#writing-a-pmda" id="id9">Writing A PMDA</a><ul>
<li><a class="reference internal" href="#implementing-a-pmda" id="id10">Implementing a PMDA</a></li>
<li><a class="reference internal" href="#pmda-architecture" id="id11">⁠PMDA Architecture</a><ul>
<li><a class="reference internal" href="#overview" id="id12">Overview</a></li>
<li><a class="reference internal" href="#dso-pmda" id="id13">DSO PMDA</a></li>
<li><a class="reference internal" href="#daemon-pmda" id="id14">Daemon PMDA</a></li>
<li><a class="reference internal" href="#caching-pmda" id="id15">Caching PMDA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#domains-metrics-instances-and-labels" id="id16">Domains, Metrics, Instances and Labels</a><ul>
<li><a class="reference internal" href="#id1" id="id17">Overview</a></li>
<li><a class="reference internal" href="#domains" id="id18">Domains</a></li>
<li><a class="reference internal" href="#metrics" id="id19">Metrics</a><ul>
<li><a class="reference internal" href="#data-structures" id="id20">Data Structures</a></li>
<li><a class="reference internal" href="#semantics" id="id21">Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instances" id="id22">Instances</a><ul>
<li><a class="reference internal" href="#instance-identification" id="id23">Instance Identification</a></li>
<li><a class="reference internal" href="#n-dimensional-data" id="id24">N Dimensional Data</a></li>
<li><a class="reference internal" href="#id2" id="id25">Data Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#labels" id="id26">Labels</a><ul>
<li><a class="reference internal" href="#label-hierarchy" id="id27">Label Hierarchy</a></li>
<li><a class="reference internal" href="#id3" id="id28">Data Structures</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#other-issues" id="id29">Other Issues</a><ul>
<li><a class="reference internal" href="#extracting-the-information" id="id30">Extracting the Information</a></li>
<li><a class="reference internal" href="#latency-and-threads-of-control" id="id31">Latency and Threads of Control</a></li>
<li><a class="reference internal" href="#name-space" id="id32">Name Space</a></li>
<li><a class="reference internal" href="#pmda-help-text" id="id33">PMDA Help Text</a></li>
<li><a class="reference internal" href="#management-of-evolution-within-a-pmda" id="id34">Management of Evolution within a PMDA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmda-interface" id="id35">PMDA Interface</a><ul>
<li><a class="reference internal" href="#id4" id="id36">Overview</a><ul>
<li><a class="reference internal" href="#trivial-pmda" id="id37">Trivial PMDA</a></li>
<li><a class="reference internal" href="#simple-pmda" id="id38">Simple PMDA</a></li>
<li><a class="reference internal" href="#simple-store-in-the-simple-pmda" id="id39">simple_store in the Simple PMDA</a></li>
<li><a class="reference internal" href="#return-codes-for-pmdafetch-callbacks" id="id40">Return Codes for pmdaFetch Callbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmda-structures" id="id41">PMDA Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initializing-a-pmda" id="id42">Initializing a PMDA</a><ul>
<li><a class="reference internal" href="#id5" id="id43">Overview</a></li>
<li><a class="reference internal" href="#common-initialization" id="id44">Common Initialization</a><ul>
<li><a class="reference internal" href="#id6" id="id45">Trivial PMDA</a></li>
<li><a class="reference internal" href="#id7" id="id46">Simple PMDA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#daemon-initialization" id="id47">Daemon Initialization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-and-debugging-a-pmda" id="id48">Testing and Debugging a PMDA</a><ul>
<li><a class="reference internal" href="#id8" id="id49">Overview</a></li>
<li><a class="reference internal" href="#debugging-information" id="id50">Debugging Information</a></li>
<li><a class="reference internal" href="#dbpmda-debug-utility" id="id51">dbpmda Debug Utility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#integration-of-a-pmda" id="id52">Integration of a PMDA</a><ul>
<li><a class="reference internal" href="#installing-a-pmda" id="id53">Installing a PMDA</a></li>
<li><a class="reference internal" href="#removing-a-pmda" id="id54">Removing a PMDA</a></li>
<li><a class="reference internal" href="#configuring-pcp-tools" id="id55">Configuring PCP Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="implementing-a-pmda">
<h2><a class="toc-backref" href="#id10">2.1. Implementing a PMDA</a><a class="headerlink" href="#implementing-a-pmda" title="Permalink to this headline">¶</a></h2>
<p>The job of a PMDA is to gather performance data and report them to the Performance Metrics Collection Daemon (PMCD) in response to requests from PCP monitoring
tools routed to the PMDA via PMCD.</p>
<p>An important requirement for any PMDA is that it have low latency response to requests from PMCD. Either the PMDA must use a quick access method and a single
thread of control, or it must have asynchronous refresh and two threads of control: one for communicating with PMCD, the other for updating the performance data.</p>
<p>The PMDA is typically acting as a gateway between the target domain (that is, the performance instrumentation in an application program or service) and the PCP
framework. The PMDA may extract the information using one of a number of possible export options that include a shared memory segment or <strong>mmap</strong> file; a sequential
log file (where the PMDA parses the tail of the log file to extract the information); a snapshot file (the PMDA rereads the file as required); or application-specific
communication services (IPC).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The choice of export methodology is typically determined by the source of the instrumentation (the target domain) rather than by the PMDA.</p>
</div>
<p><a class="reference internal" href="#procedure-2-1-creating-a-pmda">Procedure 2.1. Creating a PMDA</a> describes the suggested steps for designing and implementing a PMDA:</p>
<p id="procedure-2-1-creating-a-pmda"><strong>Procedure 2.1. Creating a PMDA</strong></p>
<ol class="arabic simple">
<li>Determine how to extract the metrics from the target domain.</li>
<li>Select an appropriate architecture for the PMDA (daemon or DSO, IPC, <strong>pthreads</strong> or single threaded).</li>
<li>Define the metrics and instances that the PMDA will support.</li>
<li>Implement the functionality to extract the metric values.</li>
<li>Assign Performance Metric Identifiers (PMIDs) for the metrics, along with names for the metrics in the Performance Metrics Name Space (PMNS). These concepts
will be further expanded in Section 2.3, “<a class="reference internal" href="#domains-metrics-instances-and-labels">Domains, Metrics, Instances and Labels</a>”</li>
<li>Specify the help file and control data structures for metrics and instances that are required by the standard PMDA implementation library functions.</li>
<li>Write code to supply the metrics and associated information to PMCD.</li>
<li>Implement any PMDA-specific callbacks, and PMDA initialization functions.</li>
<li>Exercise and test the PMDA with the purpose-built PMDA debugger; see the <strong>dbpmda(1)</strong> man page.</li>
<li>Install and connect the PMDA to a running PMCD process; see the <strong>pmcd(1)</strong> man page.</li>
<li>Where appropriate, define <strong>pmie</strong> rule templates suitable for alerting or notification systems. For more information, see the <strong>pmie(1)</strong> and <strong>pmieconf(1)</strong> man pages.</li>
<li>Where appropriate, define <strong>pmlogger</strong> configuration templates suitable for creating PCP archives containing the new metrics. For more information, see the
<strong>pmlogconf(1)</strong> and <strong>pmlogger(1)</strong> man pages.</li>
</ol>
</div>
<div class="section" id="pmda-architecture">
<h2><a class="toc-backref" href="#id11">2.2. ⁠PMDA Architecture</a><a class="headerlink" href="#pmda-architecture" title="Permalink to this headline">¶</a></h2>
<p>This section discusses the two methods of connecting a PMDA to a PMCD process:</p>
<ol class="arabic simple">
<li>As a separate process using some interprocess communication (IPC) protocol.</li>
<li>As a dynamically attached library (that is, a dynamic shared object or DSO).</li>
</ol>
<div class="section" id="overview">
<h3><a class="toc-backref" href="#id12">2.2.1. Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>All PMDAs are launched and controlled by the PMCD process on the local host. PMCD receives requests from the monitoring tools and forwards them to the PMDAs.
Responses, when required, are returned through PMCD to the clients. The requests fall into a small number of categories, and the PMDA must handle each request type.
For a DSO PMDA, each request type corresponds to a method in the agent. For a daemon PMDA, each request translates to a message or protocol data unit (PDU) that
may be sent to a PMDA from PMCD.</p>
<p>For a daemon PMDA, the following request PDUs must be supported:</p>
<p><strong>PDU_FETCH</strong></p>
<p>Request for metric values (see the <strong>pmFetch(3)</strong> man page.)</p>
<p><strong>PDU_PROFILE</strong></p>
<p>A list of instances required for the corresponding metrics in subsequent fetches (see the <strong>pmAddProfile(3)</strong> man page).</p>
<p><strong>PDU_INSTANCE_REQ</strong></p>
<p>Request for a particular instance domain for instance descriptions (see the <strong>pmGetInDom(3)</strong> man page).</p>
<p><strong>PDU_DESC_REQ</strong></p>
<p>Request for metadata describing metrics (see the <strong>pmLookupDesc(3)</strong> man page).</p>
<p><strong>PDU_TEXT_REQ</strong></p>
<p>Request for metric help text (see the <strong>pmLookupText(3)</strong> man page).</p>
<p><strong>PDU_RESULT</strong></p>
<p>Values to store into metrics (see the <strong>pmStore(3)</strong> man page).</p>
<p>The following request PDUs may optionally be supported:</p>
<p><strong>PDU_PMNS_NAMES</strong></p>
<p>Request for metric names, given one or more identifiers (see the <strong>pmLookupName(3)</strong> man page.)</p>
<p><strong>PDU_PMNS_CHILD</strong></p>
<p>A list of immediate descendent nodes of a given namespace node (see the <strong>pmGetChildren(3)</strong> man page).</p>
<p><strong>PDU_PMNS_TRAVERSE</strong></p>
<p>Request for a particular sub-tree of a given namespace node (see the <strong>pmTraversePMNS(3)</strong> man page).</p>
<p><strong>PDU_PMNS_IDS</strong></p>
<p>Perform a reverse name lookup, mapping a metric identifier to a name (see the <strong>pmNameID(3)</strong> man page).</p>
<p><strong>PDU_ATTR</strong></p>
<p>Handle connection attributes (key/value pairs), such as client credentials and other authentication information (see the <strong>__pmParseHostAttrsSpec(3)</strong> man page).</p>
<p><strong>PDU_LABEL_REQ</strong></p>
<p>Request for metric labels (see the <strong>pmLookupLabels(3)</strong> man page).</p>
<p>Each PMDA is associated with a unique domain number that is encoded in the domain field of metric and instance identifiers, and PMCD uses the domain number to
determine which PMDA can handle the components of any given client request.</p>
</div>
<div class="section" id="dso-pmda">
<h3><a class="toc-backref" href="#id13">2.2.2. DSO PMDA</a><a class="headerlink" href="#dso-pmda" title="Permalink to this headline">¶</a></h3>
<p>Each PMDA is required to implement a function that handles each of the request types. By implementing these functions as library functions, a PMDA can be
implemented as a dynamically shared object (DSO) and attached by PMCD at run time with a platform-specific call, such as <strong>dlopen</strong>; see the <strong>dlopen(3)</strong>
man page. This eliminates the need for an IPC layer (typically a pipe) between each PMDA and PMCD, because each request becomes a function call rather than
a message exchange. The required library functions are detailed in Section 2.5, “<a class="reference internal" href="#pmda-interface">PMDA Interface</a>”.</p>
<p>A PMDA that interacts with PMCD in this fashion must abide by a formal initialization protocol so that PMCD can discover the location of the library functions
that are subsequently called with function pointers. When a DSO PMDA is installed, the PMCD configuration file, <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code>, is updated to reflect the
domain and name of the PMDA, the location of the shared object, and the name of the initialization function. The initialization sequence is discussed in
Section 2.6, “<a class="reference internal" href="#initializing-a-pmda">Initializing a PMDA</a>”.</p>
<p>As superuser, install the simple PMDA as a DSO, as shown in <a class="reference internal" href="#example-2-1-simple-pmda-as-a-dso">Example 2.1. Simple PMDA as a DSO</a>, and observe the changes in the PMCD configuration file. The
output may differ slightly depending on the operating system you are using, any other PMDAs you have installed or any PMCD access controls you have in place.</p>
<p id="example-2-1-simple-pmda-as-a-dso"><strong>Example 2.1. Simple PMDA as a DSO</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              cat ${PCP_PMCDCONF_PATH}
# Performance Metrics Domain Specifications
#
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
root    1       pipe    binary          /var/lib/pcp/pmdas/root/pmdaroot
pmcd    2       dso     pmcd_init       ${PCP_PMDAS_DIR}/pmcd/pmda_pmcd.so
proc    3       pipe    binary          ${PCP_PMDAS_DIR}/linux/pmda_proc.so -d 3
linux   60      dso     linux_init      ${PCP_PMDAS_DIR}/linux/pmda_linux.so
mmv     70      dso     mmv_init        /var/lib/pcp/pmdas/mmv/pmda_mmv.so
simple  254     dso     simple_init     ${PCP_PMDAS_DIR}/simple/pmda_simple.so
</pre></div>
</div>
<p>As can be seen from the contents of <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code>, the DSO version of the simple PMDA is in a library named <strong>pmda_simple.so</strong> and has an initialization
function called <strong>simple_init</strong>. The domain of the simple PMDA is 254, as shown in the column headed <strong>Id</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For some platforms the DSO file name will not be <strong>pmda_simple.so</strong>. On Mac OS X it is <strong>pmda_simple.dylib</strong> and on Windows it is <strong>pmda_simple.dll</strong>.</p>
</div>
</div>
<div class="section" id="daemon-pmda">
<h3><a class="toc-backref" href="#id14">2.2.3. Daemon PMDA</a><a class="headerlink" href="#daemon-pmda" title="Permalink to this headline">¶</a></h3>
<p>A DSO PMDA provides the most efficient communication between the PMDA and PMCD. This approach has some disadvantages resulting from the DSO PMDA being the same
process as PMCD:</p>
<ul class="simple">
<li>An error or bug that causes a DSO PMDA to exit also causes PMCD to exit, which affects all connected client tools.</li>
<li>There is only one thread of control in PMCD; as a result, a computationally expensive PMDA, or worse, a PMDA that blocks for I/O, adversely affects the performance of PMCD.</li>
<li>PMCD runs as the “pcp” user; so all DSO PMDAs must also run as this user.</li>
<li>A memory leak in a DSO PMDA also causes a memory leak for PMCD.</li>
</ul>
<p>Consequently, many PMDAs are implemented as a daemon process.</p>
<p>The <strong>libpcp_pmda</strong> library is designed to allow simple implementation of a PMDA that runs as a separate process. The library functions provide a message passing
layer acting as a generic wrapper that accepts PDUs, makes library calls using the standard DSO PMDA interface, and sends PDUs. Therefore, you can implement a PMDA
as a DSO and then install it as either a daemon or a DSO, depending on the presence or absence of the generic wrapper.</p>
<p>The PMCD process launches a daemon PMDA with <strong>fork</strong> and <strong>execv</strong> (or <strong>CreateProcess</strong> on Windows). You can easily connect a pipe to the PMDA using standard
input and output. The PMCD process may also connect to a daemon PMDA using IPv4 or IPv6 TCP/IP, or UNIX domain sockets if the platform supports that; see the
<strong>tcp(7), ip(7), ipv6(7)</strong> or <strong>unix(7)</strong> man pages.</p>
<p>As superuser, install the simple PMDA as a daemon process as shown in <a class="reference internal" href="#example-2-2-simple-pmda-as-a-daemon">Example 2.2. Simple PMDA as a Daemon</a>. Again, the output may differ due to operating
system differences, other PMDAs already installed, or access control sections in the PMCD configuration file.</p>
<p id="example-2-2-simple-pmda-as-a-daemon"><strong>Example 2.2. Simple PMDA as a Daemon</strong></p>
<p>The specification for the simple PMDA now states the connection type of <strong>pipe</strong> to PMCD and the executable image for the PMDA is <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/simple/pmdasimple</span></code>,
using domain number 253.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cd ${PCP_PMDAS_DIR}/simple
# ./Install
...
Install simple as a daemon or dso agent? [daemon] daemon
PMCD should communicate with the daemon via pipe or socket? [pipe] pipe
...
# cat ${PCP_PMCDCONF_PATH}
# Performance Metrics Domain Specifications
#
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
root    1       pipe    binary          /var/lib/pcp/pmdas/root/pmdaroot
pmcd    2       dso     pmcd_init       ${PCP_PMDAS_DIR}/pmcd/pmda_pmcd.so
proc    3       pipe    binary          ${PCP_PMDAS_DIR}/linux/pmda_proc.so -d 3
linux   60      dso     linux_init      ${PCP_PMDAS_DIR}/linux/pmda_linux.so
mmv     70      dso     mmv_init        /var/lib/pcp/pmdas/mmv/pmda_mmv.so
simple  253     pipe    binary          ${PCP_PMDAS_DIR}/simple/pmdasimple -d 253
</pre></div>
</div>
</div>
<div class="section" id="caching-pmda">
<h3><a class="toc-backref" href="#id15">2.2.4. Caching PMDA</a><a class="headerlink" href="#caching-pmda" title="Permalink to this headline">¶</a></h3>
<p>When either the cost or latency associated with collecting performance metrics is high, the PMDA implementer may choose to trade off the currency of the
performance data to reduce the PMDA resource demands or the fetch latency time.</p>
<p>One scheme for doing this is called a caching PMDA, which periodically instantiates values for the performance metrics and responds to each request from PMCD
with the most recently instantiated (or cached) values, as opposed to instantiating current values on demand when the PMCD asks for them.</p>
<p>The Cisco PMDA is an example of a caching PMDA. For additional information, see the contents of the <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/cisco</span></code> directory and the <strong>pmdacisco(1)</strong>
man page.</p>
</div>
</div>
<div class="section" id="domains-metrics-instances-and-labels">
<h2><a class="toc-backref" href="#id16">2.3. Domains, Metrics, Instances and Labels</a><a class="headerlink" href="#domains-metrics-instances-and-labels" title="Permalink to this headline">¶</a></h2>
<p>This section defines metrics and instances, discusses how they should be designed for a particular target domain, and shows how to implement support for them.</p>
<p>The examples in this section are drawn from the trivial and simple PMDAs. Refer to the <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/trivial</span></code> and <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/simple</span></code> directories,
respectively, where both binaries and source code are available.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id17">2.3.1. Overview</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><em>Domains</em> are autonomous performance areas, such as the operating system or a layered service or a particular application. <em>Metrics</em> are raw performance data for
a domain, and typically quantify activity levels, resource utilization or quality of service. <em>Instances</em> are sets of related metrics, as for multiple processors,
or multiple service classes, or multiple transaction types.</p>
<p>PCP employs the following simple and uniform data model to accommodate the demands of performance metrics drawn from multiple domains:</p>
<ul class="simple">
<li>Each metric has an identifier that is unique across all metrics for all PMDAs on a particular host.</li>
<li>Externally, metrics are assigned names for user convenience–typically there is a 1:1 relationship between a metric name and a metric identifier.</li>
<li>The PMDA implementation determines if a particular metric has a singular value or a set of (zero or more) values. For instance, the metric <strong>hinv.ndisk</strong>
counts the number of disks and has only one value on a host, whereas the metric <strong>disk.dev.total</strong> counts disk I/O operations and has one value for each disk
on the host.</li>
<li>If a metric has a set of values, then members of the set are differentiated by instances. The set of instances associated with a metric is an <em>instance domain</em>.
For example, the set of metrics <strong>disk.dev.total</strong> is defined over an instance domain that has one member per disk spindle.</li>
</ul>
<p>The selection of metrics and instances is an important design decision for a PMDA implementer. The metrics and instances for a target domain should have the following qualities:</p>
<ul class="simple">
<li>Obvious to a user</li>
<li>Consistent across the domain</li>
<li>Accurately representative of the operational and functional aspects of the domain</li>
</ul>
<p>For each metric, you should also consider these questions:</p>
<ul class="simple">
<li>How useful is this value?</li>
<li>What units give a good sense of scale?</li>
<li>What name gives a good description of the metric’s meaning?</li>
<li>Can this metric be combined with another to convey the same useful information?</li>
</ul>
<p>As with all programming tasks, expect to refine the choice of metrics and instances several times during the development of the PMDA.</p>
</div>
<div class="section" id="domains">
<h3><a class="toc-backref" href="#id18">2.3.2. Domains</a><a class="headerlink" href="#domains" title="Permalink to this headline">¶</a></h3>
<p>Each PMDA must be uniquely identified by PMCD so that requests from clients can be efficiently routed to the appropriate PMDA. The unique identifier, the PMDA’s
domain, is encoded within the metrics and instance domain identifiers so that they are associated with the correct PMDA, and so that they are unique, regardless
of the number of PMDAs that are connected to the PMCD process.</p>
<p>The default domain number for each PMDA is defined in <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns/stdpmid</span></code>. This file is a simple table of PMDA names and their corresponding domain
number. However, a PMDA does not have to use this domain number–the file is only a guide to help avoid domain number clashes when PMDAs are installed and
activated.</p>
<p>The domain number a PMDA uses is passed to the PMDA by PMCD when the PMDA is launched. Therefore, any data structures that require the PMDA’s domain number must
be set up when the PMDA is initialized, rather than declared statically. The protocol for PMDA initialization provides a standard way for a PMDA to implement
this run-time initialization.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although uniqueness of the domain number in the <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code> control file used by PMCD is all that is required for successful starting of PMCD and
the associated PMDAs, the developer of a new PMDA is encouraged to add the default domain number for each new PMDA to the <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns/stdpmid.local</span></code>
file and then to run the <strong>Make.stdpmid</strong> script in <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns</span></code> to recreate <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns/stdpmid</span></code>; this file acts as a repository for
documenting the known default domain numbers.</p>
</div>
</div>
<div class="section" id="metrics">
<h3><a class="toc-backref" href="#id19">2.3.3. Metrics</a><a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h3>
<p>A PMDA provides support for a collection of metrics. In addition to the obvious performance metrics, and the measures of time, activity and resource utilization,
the metrics should also describe how the target domain has been configured, as this can greatly affect the correct interpretation of the observed performance. For
example, metrics that describe network transfer rates should also describe the number and type of network interfaces connected to the host (<strong>hinv.ninterface</strong>,
<strong>network.interface.speed, network.interface.duplex</strong>, and so on)</p>
<p>In addition, the metrics should describe how the PMDA has been configured. For example, if the PMDA was periodically probing a system to measure quality of
service, there should be metrics for the delay between probes, the number of probes attempted, plus probe success and failure counters. It may also be appropriate
to allow values to be stored (see the <strong>pmstore(1)</strong> man page) into the delay metric, so that the delay used by the PMDA can be altered dynamically.</p>
<div class="section" id="data-structures">
<h4><a class="toc-backref" href="#id20">2.3.3.1. Data Structures</a><a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h4>
<p>Each metric must be described in a <strong>pmDesc</strong> structure; see the <strong>pmLookupDesc(3)</strong> man page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    pmID        pmid;           /* unique identifier */
    int         type;           /* base data type */
    pmInDom     indom;          /* instance domain */
    int         sem;            /* semantics of value */
    pmUnits     units;          /* dimension and units */
} pmDesc;
</pre></div>
</div>
<p>This structure contains the following fields:</p>
<p><strong>pmid</strong></p>
<p>A unique identifier, Performance Metric Identifier (PMID), that differentiates this metric from other metrics across the union of all PMDAs</p>
<p><strong>type</strong></p>
<p>A data type indicator showing whether the format is an integer (32 or 64 bit, signed or unsigned); float; double; string; or arbitrary aggregate of binary data</p>
<p><strong>indom</strong></p>
<p>An instance domain identifier that links this metric to an instance domain</p>
<p><strong>sem</strong></p>
<p>An encoding of the value’s semantics (counter, instantaneous, or discrete)</p>
<p><strong>units</strong></p>
<p>A description of the value’s units based on dimension and scale in the three orthogonal dimensions of space, time, and count (or events)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This information can be observed for metrics from any active PMDA using <strong>pminfo</strong> command line options, for example:</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span>$ pminfo -d -m network.interface.out.drops

network.interface.out.drops PMID: 60.3.11
    Data Type: 64-bit unsigned int  InDom: 60.3 0xf000003
    Semantics: counter  Units: count
</pre></div>
</div>
</div>
<p>Symbolic constants of the form <strong>PM_TYPE*, PM_SEM_*, PM_SPACE_*, PM_TIME_*</strong>, and <strong>PM_COUNT_*</strong> are defined in the <strong>&lt;pcp/pmapi.h&gt;</strong> header file.
You may use them to initialize the elements of a <strong>pmDesc</strong> structure. The <strong>pmID</strong> type is an unsigned integer that can be safely cast to a <strong>__pmID_int</strong>
structure, which contains fields defining the metric’s (PMDA’s) domain, cluster, and item number as shown in <a class="reference internal" href="#example-2-3-pmid-int-structure">Example 2.3. __pmID_int Structure</a>:</p>
<p id="example-2-3-pmid-int-structure"><strong>Example 2.3. __pmID_int Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
        int             flag:1;
        unsigned int    domain:9;
        unsigned int    cluster:12;
        unsigned int    item:10;
} __pmID_int;
</pre></div>
</div>
<p>For additional information, see the <strong>&lt;pcp/libpcp.h&gt;</strong> file.</p>
<p>The <strong>flag</strong> field should be ignored. The <strong>domain</strong> number should be set at run time when the PMDA is initialized. The <strong>PMDA_PMID</strong> macro defined in
<strong>&lt;pcp/pmapi.h&gt;</strong> can be used to set the <strong>cluster</strong> and <strong>item</strong> fields at compile time, as these should always be known and fixed for a particular metric.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The three components of the PMID should correspond exactly to the three-part definition of the PMID for the corresponding metric in the PMNS described in Section 2.4.3, “<a class="reference internal" href="#name-space">Name Space</a>”.</p>
</div>
<p>A table of <strong>pmdaMetric</strong> structures should be defined within the PMDA, with one structure per metric as shown in <a class="reference internal" href="#example-2-4-pmdametric-structure">Example 2.4. pmdaMetric Structure</a>.</p>
<p id="example-2-4-pmdametric-structure"><strong>Example 2.4. pmdaMetric Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    void        *m_user;        /* for users external use */
    pmDesc      m_desc;         /* metric description */
} pmdaMetric;
</pre></div>
</div>
<p>This structure contains a <strong>pmDesc</strong> structure and a handle that allows PMDA-specific structures to be associated with each metric. For example, <strong>m_user</strong>
could be a pointer to a global variable containing the metric value, or a pointer to a function that may be called to instantiate the metric’s value.</p>
<p>The trivial PMDA, shown in <a class="reference internal" href="#example-2-5-trivial-pmda">Example 2.5. Trivial PMDA</a>, has only a singular metric (that is, no instance domain):</p>
<p id="example-2-5-trivial-pmda"><strong>Example 2.5. Trivial PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static pmdaMetric metrictab[] = {
/* time */
 { NULL,
   { PMDA_PMID(0, 1), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
     PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
};
</pre></div>
</div>
<p>This single metric (<strong>trivial.time</strong>) has the following:</p>
<ul class="simple">
<li>A PMID with a cluster of 0 and an item of 1. Note that this is not yet a complete PMID, the domain number which identifies the PMDA will be combined with it at runtime.</li>
<li>An unsigned 32-bit integer (<strong>PM_TYPE_U32</strong>)</li>
<li>A singular value and hence no instance domain (<strong>PM_INDOM_NULL</strong>)</li>
<li>An instantaneous semantic value (<strong>PM_SEM_INSTANT</strong>)</li>
<li>Dimension “time” and the units “seconds”</li>
</ul>
</div>
<div class="section" id="semantics">
<h4><a class="toc-backref" href="#id21">2.3.3.2. Semantics</a><a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h4>
<p>The metric’s semantics describe how PCP tools should interpret the metric’s value. The following are the possible semantic types:</p>
<ul class="simple">
<li>Counter (<strong>PM_SEM_COUNTER</strong>)</li>
<li>Instantaneous value (<strong>PM_SEM_INSTANT</strong>)</li>
<li>Discrete value (<strong>PM_SEM_DISCRETE</strong>)</li>
</ul>
<p>A counter should be a value that monotonically increases (or monotonically decreases, which is less likely) with respect to time, so that the rate of change
should be used in preference to the actual value. Rate conversion is not appropriate for metrics with instantaneous values, as the value is a snapshot and there
is no basis for assuming any values that might have been observed between snapshots. Discrete is similar to instantaneous; however, once observed it is presumed
the value will persist for an extended period (for example, system configuration, static tuning parameters and most metrics with non-numeric values).</p>
<p>For a given time interval covering six consecutive timestamps, each spanning two units of time, the metric values in <a class="reference internal" href="#example-2-6-effect-of-semantics-on-a-metric">Example 2.6. Effect of Semantics on a Metric</a>
are exported from a PMDA (“N/A” implies no value is available):</p>
<p id="example-2-6-effect-of-semantics-on-a-metric"><strong>Example 2.6. Effect of Semantics on a Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Timestamps:         1   3   5   7   9  11
Value:             10  30  60  80  90 N/A
</pre></div>
</div>
<p>The default display of the values would be as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Timestamps:         1   3   5   7   9  11
Semantics:
Counter           N/A  10  15  10   5 N/A
Instantaneous      10  30  60  80  90 N/A
Discrete           10  30  60  80  90  90
</pre></div>
</div>
<p>Note that these interpretations of metric semantics are performed by the monitor tool, automatically, before displaying a value and they are not transformations
that the PMDA performs.</p>
</div>
</div>
<div class="section" id="instances">
<h3><a class="toc-backref" href="#id22">2.3.4. Instances</a><a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Singular metrics have only one value and no associated instance domain. Some metrics contain a set of values that share a common set of semantics for a specific
instance, such as one value per processor, or one value per disk spindle, and so on.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The PMDA implementation is solely responsible for choosing the instance identifiers that differentiate instances within the instance domain. The PMDA is also
responsible for ensuring the uniqueness of instance identifiers in any instance domain, as described in Section 2.3.4.1, “<a class="reference internal" href="#instance-identification">Instance Identification</a>”.</p>
</div>
<div class="section" id="instance-identification">
<h4><a class="toc-backref" href="#id23">2.3.4.1. Instance Identification</a><a class="headerlink" href="#instance-identification" title="Permalink to this headline">¶</a></h4>
<p>Consistent interpretation of instances and instance domains require a few simple rules to be followed by PMDA authors. The PMDA library provides a series of
<strong>pmdaCache</strong> routines to assist.</p>
<ul class="simple">
<li>Each internal instance identifier (numeric) must be a unique 31-bit number.</li>
<li>The external instance name (string) must be unique.</li>
<li>When the instance name contains a space, the name to the left of the first space (the short name) must also be unique.</li>
<li>Where an external instance name corresponds to some object or entity, there is an expectation that the association between the name and the object is fixed.</li>
<li>It is preferable, although not mandatory, for the association between and external instance name (string) and internal instance identifier (numeric) to be persistent.</li>
</ul>
</div>
<div class="section" id="n-dimensional-data">
<h4><a class="toc-backref" href="#id24">2.3.4.2. N Dimensional Data</a><a class="headerlink" href="#n-dimensional-data" title="Permalink to this headline">¶</a></h4>
<p>Where the performance data can be represented as scalar values (singular metrics) or one-dimensional arrays or lists (metrics with an instance domain), the PCP
framework is more than adequate. In the case of metrics with an instance domain, each array or list element is associated with an instance from the instance
domain.</p>
<p>To represent two or more dimensional arrays, the coordinates must be one of the following:</p>
<ul class="simple">
<li>Mapped onto one dimensional coordinates.</li>
<li>Enumerated into the Performance Metrics Name Space (PMNS).</li>
</ul>
<p>For example, this 2 x 3 array of values called M can be represented as instances 1,…, 6 for a metric M:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>M[1]   M[2]   M[3]
M[4]   M[5]   M[6]
</pre></div>
</div>
<p>Or they can be represented as instances 1, 2, 3 for metric M1 and instances 1, 2, 3 for metric M2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>M1[1]  M1[2]  M1[3]
M2[1]  M2[2]  M2[3]
</pre></div>
</div>
<p>The PMDA implementer must decide and consistently export this encoding from the N-dimensional instrumentation to the 1-dimensional data model of the PCP. The use
of metric label metadata - arbitrary key/value pairs - allows the implementer to capture the higher dimensions of the performance data.</p>
<p>In certain special cases (for example, such as for a histogram), it may be appropriate to export an array of values as raw binary data (the type encoding in the
descriptor is <strong>PM_TYPE_AGGREGATE</strong>). However, this requires the development of special PMAPI client tools, because the standard PCP tools have no knowledge of
the structure and interpretation of the binary data. The usual issues of platform-depdendence must also be kept in mind for this case - endianness, word-size,
alignment and so on - the (possibly remote) special PMAPI client tools may need this information in order to decode the data successfully.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id25">2.3.4.3. Data Structures</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>If the PMDA is required to support instance domains, then for each instance domain the unique internal instance identifier and external instance identifier should
be defined using a <strong>pmdaInstid</strong> structure as shown in <a class="reference internal" href="#example-2-7-pmdainstid-structure">Example 2.7. pmdaInstid Structure</a>:</p>
<p id="example-2-7-pmdainstid-structure"><strong>Example 2.7.  pmdaInstid Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    int         i_inst;         /* internal instance identifier */
    char        *i_name;        /* external instance identifier */
} pmdaInstid;
</pre></div>
</div>
<p>The <strong>i_inst</strong> instance identifier must be a unique integer within a particular instance domain.</p>
<p>The complete instance domain description is specified in a <strong>pmdaIndom</strong> structure as shown in <a class="reference internal" href="#example-2-8-pmdaindom-structure">Example 2.8. pmdaIndom Structure</a>:</p>
<p id="example-2-8-pmdaindom-structure"><strong>Example 2.8.  pmdaIndom Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    pmInDom     it_indom;       /* indom, filled in */
    int         it_numinst;     /* number of instances */
    pmdaInstid  *it_set;        /* instance identifiers */
} pmdaIndom;
</pre></div>
</div>
<p>The <strong>it_indom</strong> element contains a <strong>pmInDom</strong> that must be unique across every PMDA. The other fields of the <strong>pmdaIndom</strong> structure are the number of instances
in the instance domain and a pointer to an array of instance descriptions.</p>
<p><a class="reference internal" href="#example-2-9-pmindom-int-structure">Example 2.9. __pmInDom_int Structure</a> shows that the <strong>pmInDom</strong> can be safely cast to <strong>__pmInDom_int</strong>, which specifies the PMDA’s domain and the instance
number within the PMDA:</p>
<p id="example-2-9-pmindom-int-structure"><strong>Example 2.9. __pmInDom_int Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
        int             flag:1;
        unsigned int    domain:9;   /* the administrative PMD */
        unsigned int    serial:22;  /* unique within PMD */
} __pmInDom_int;
</pre></div>
</div>
<p>As with metrics, the PMDA domain number is not necessarily known until run time; so the <strong>domain</strong> field must be set up when the PMDA is initialized.</p>
<p>For information about how an instance domain may also be associated with more than one metric, see the <strong>pmdaInit(3)</strong> man page.</p>
<p>The simple PMDA, shown in <a class="reference internal" href="#example-2-10-simple-pmda">Example 2.10. Simple PMDA</a>, has five metrics and two instance domains of three instances.</p>
<p id="example-2-10-simple-pmda"><strong>Example 2.10. Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * list of instances
 */
static pmdaInstid color[] = {
    { 0, “red” }, { 1, “green” }, { 2, “blue” }
};
static pmdaInstid       *timenow = NULL;
static unsigned int     timesize = 0;
/*
 * list of instance domains
 */
static pmdaIndom indomtab[] = {
#define COLOR_INDOM     0
    { COLOR_INDOM, 3, color },
#define NOW_INDOM       1
   { NOW_INDOM, 0, NULL },
};
/*
 * all metrics supported in this PMDA - one table entry for each
 */
static pmdaMetric metrictab[] = {
/* numfetch */
    { NULL,
      { PMDA_PMID(0, 0), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
       PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
/* color */
    { NULL,
      { PMDA_PMID(0, 1), PM_TYPE_32, COLOR_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
/* time.user */
    { NULL,
      { PMDA_PMID(1, 2), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
/* time.sys */
    { NULL,
      { PMDA_PMID(1,3), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS(0, 1, 0, 0, PM_TIME_SEC, 0) }, },
/* now */
    { NULL,
      { PMDA_PMID(2,4), PM_TYPE_U32, NOW_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS(0, 0, 0, 0, 0, 0) }, },
};
</pre></div>
</div>
<p>The metric <strong>simple.color</strong> is associated, via <strong>COLOR_INDOM</strong>, with the first instance domain listed in <strong>indomtab</strong>. PMDA initialization assigns the correct
domain portion of the instance domain identifier in <strong>indomtab[0].it_indom</strong> and <strong>metrictab[1].m_desc.indom</strong>. This instance domain has three instances: red, green,
and blue.</p>
<p>The metric <strong>simple.now</strong> is associated, via <strong>NOW_INDOM</strong>, with the second instance domain listed in <strong>indomtab</strong>. PMDA initialization assigns the correct domain
portion of the instance domain identifier in <strong>indomtab[1].it_indom</strong> and <strong>metrictab[4].m_desc.indom</strong>. This instance domain is dynamic and initially has no
instances.</p>
<p>All other metrics are singular, as specified by <strong>PM_INDOM_NULL</strong>.</p>
<p>In some cases an instance domain may vary dynamically after PMDA initialization (for example, <strong>simple.now</strong>), and this requires some refinement of the default
functions and data structures of the <strong>libpcp_pmda</strong> library. Briefly, this involves providing new functions that act as wrappers for <strong>pmdaInstance</strong> and <strong>pmdaFetch</strong>
while understanding the dynamics of the instance domain, and then overriding the instance and fetch methods in the <strong>pmdaInterface</strong> structure during PMDA
initialization.</p>
<p>For the simple PMDA, the wrapper functions are <strong>simple_fetch</strong> and <strong>simple_instance</strong>, and defaults are over-ridden by the following assignments in the
<strong>simple_init</strong> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dp-&gt;version.any.fetch = simple_fetch;
dp-&gt;version.any.instance = simple_instance;
</pre></div>
</div>
</div>
</div>
<div class="section" id="labels">
<h3><a class="toc-backref" href="#id26">2.3.5. Labels</a><a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h3>
<p>Metrics and instances can be further described through the use of metadata labels, which are arbitrary name:value pairs associated with individual metrics and
instances. There are several applications of this concept, but one of the most important is the ability to differentiate the components of a multi-dimensional
instance name, such as the case of the <strong>mem.zoneinfo.numa_hit</strong> metric which has one value per memory zone, per NUMA node.</p>
<p>Consider <a class="reference internal" href="#example-2-11-multi-dimensional-instance-domain-labels">Example 2.11. Multi-dimensional Instance Domain Labels</a>:</p>
<p id="example-2-11-multi-dimensional-instance-domain-labels"><strong>Example 2.11. Multi-dimensional Instance Domain Labels</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ pminfo -l mem.zoneinfo.numa_hit

mem.zoneinfo.numa_hit
   inst [0 or &quot;DMA::node0&quot;] labels {&quot;device_type&quot;:[&quot;numa_node&quot;,&quot;memory&quot;],&quot;indom_name&quot;:&quot;per zone per numa_node&quot;,&quot;numa_node&quot;:0,&quot;zone&quot;:&quot;DMA&quot;}
   inst [1 or &quot;Normal::node0&quot;] labels {&quot;device_type&quot;:[&quot;numa_node&quot;,&quot;memory&quot;],&quot;indom_name&quot;:&quot;per zone per numa_node&quot;,&quot;numa_node&quot;:0,&quot;zone&quot;:&quot;Normal&quot;}
   inst [2 or &quot;DMA::node1&quot;] labels {&quot;device_type&quot;:[&quot;numa_node&quot;,&quot;memory&quot;],&quot;indom_name&quot;:&quot;per zone per numa_node&quot;,&quot;numa_node&quot;:1,&quot;zone&quot;:&quot;DMA&quot;}
   inst [3 or &quot;Normal::node1&quot;] labels {&quot;device_type&quot;:[&quot;numa_node&quot;,&quot;memory&quot;],&quot;indom_name&quot;:&quot;per zone per numa_node&quot;,&quot;numa_node&quot;:1,&quot;zone&quot;:&quot;Normal&quot;}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The metric labels used here individually describe the memory zone and NUMA node associated with each instance.</p>
</div>
<p>The PMDA implementation is only partially responsible for choosing the label identifiers that differentiate components of metrics and instances within an instance
domain. Label sets for a singleton metric or individual instance of a set-valued metric are formed from a label hierarchy, which includes global labels applied to
all metrics and instances from one PMAPI context.</p>
<p>Labels are stored and communicated within PCP using JSONB format. This format is a restricted form of JSON suitable for indexing and other operations. In JSONB
form, insignificant whitespace is discarded, and the order of label names is not preserved. Within the PMCS a lexicographically sorted key space is always
maintained, however. Duplicate label names are not permitted. The label with highest precedence is the only one presented. If duplicate names are presented at
the same hierarchy level, only one will be preserved (exactly which one wins is arbitrary, so do not rely on this).</p>
<div class="section" id="label-hierarchy">
<h4><a class="toc-backref" href="#id27">2.3.5.1. Label Hierarchy</a><a class="headerlink" href="#label-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>The set of labels associated with any singleton metric or instance is formed by merging the sets of labels at each level of a hierarchy. The lower levels of the
hierarchy have highest precendence when merging overlapping (duplicate) label names:</p>
<ul class="simple">
<li>Global context labels (as reported by the <strong>pmcd.labels</strong> metric) are the lowest precedence. The PMDA implementor has no influence over labels at this level of
the hierarchy, and these labels are typically supplied by <strong>pmcd</strong> from <strong>/etc/pcp/labels</strong> files.</li>
<li>Domain labels, for all metrics and instances of a PMDA, are the next highest precedence.</li>
<li>Instance Domain labels, associated with an InDom, are the next highest precedence.</li>
<li>Metric cluster labels, associated with a PMID cluster, are the next highest precedence.</li>
<li>Metric item labels, associated with an individual PMID, are the next highest precedence.</li>
<li>Instance labels, associated with a metric instance identifier, have the highest precedence.</li>
</ul>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id28">2.3.5.2. Data Structures</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>In any PMDA that supports labels at any level of the hierarchy, each individual label (one name:value pair) requires a <strong>pmLabel</strong> structure as shown in <a class="reference internal" href="#example-2-12-pmlabel-structure">Example 2.12. pmLabel Structure</a>:</p>
<p id="example-2-12-pmlabel-structure"><strong>Example 2.12. pmLabel Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    uint     name : 16;      /* label name offset in JSONB string */
    uint     namelen : 8;    /* length of name excluding the null */
    uint     flags : 8;      /* information about this label */
    uint     value : 16;     /* offset of the label value */
    uint     valuelen : 16;  /* length of value in bytes */
} pmLabel;
</pre></div>
</div>
<p>The <strong>flags</strong> field is a bitfield identifying the hierarchy level and whether this name:value pair is intrinsic (optional) or extrinsic (part of the mandatory,
identifying metadata for the metric or instance). All other fields are offsets and lengths in the JSONB string from an associated <strong>pmLabelSet</strong> structure.</p>
<p>Zero or more labels are specified via a label set, in a <strong>pmLabelSet</strong> structure as shown in <a class="reference internal" href="#example-2-13-pmlabelset-structure">Example 2.13. pmLabelSet Structure</a>:</p>
<p id="example-2-13-pmlabelset-structure"><strong>Example 2.13. pmLabelSet Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    uint     inst;          /* PM_IN_NULL or the instance ID */
    int      nlabels;       /* count of labels or error code */
    char     *json;         /* JSONB formatted labels string */
    uint     jsonlen : 16;  /* JSON string length byte count */
    uint     padding : 16;  /* zero, reserved for future use */
    pmLabel  *labels;       /* indexing into the JSON string */
} pmLabelSet;
</pre></div>
</div>
<p>This provides information about the set of labels associated with an entity (context, domain, indom, metric cluster, item or instance). The entity will be from
any one level of the label hierarchy. If at the lowest hierarchy level (which happens to be highest precedence - instances) then the <strong>inst</strong> field will contain
an actual instance identifier instead of PM_IN_NULL.</p>
<p>For information about how a label can be associated with each level of the hierarchy, see the <strong>pmdaLabel(3)</strong> man page.</p>
<p>The simple PMDA, shown in <a class="reference internal" href="#example-2-14-simple-pmda">Example 2.14. Simple PMDA</a>, associates labels at the domain, indom and instance levels of the hierarhy.</p>
<p id="example-2-14-simple-pmda"><strong>Example 2.14. Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int
simple_label(int ident, int type, pmLabelSet **lpp, pmdaExt *pmda)
{
    int         serial;

    switch (type) {
    case PM_LABEL_DOMAIN:
        pmdaAddLabels(lpp, &quot;{&quot;role&quot;:&quot;testing&quot;}&quot;);
        break;
    case PM_LABEL_INDOM:
        serial = pmInDom_serial((pmInDom)ident);
        if (serial == COLOR_INDOM) {
            pmdaAddLabels(lpp, &quot;{&quot;indom_name&quot;:&quot;color&quot;}&quot;);
            pmdaAddLabels(lpp, &quot;{&quot;model&quot;:&quot;RGB&quot;}&quot;);
        }
        if (serial == NOW_INDOM) {
            pmdaAddLabels(lpp, &quot;{&quot;indom_name&quot;:&quot;time&quot;}&quot;);
            pmdaAddLabels(lpp, &quot;{&quot;unitsystem&quot;:&quot;SI&quot;}&quot;);
        }
        break;
    case PM_LABEL_CLUSTER:
    case PM_LABEL_ITEM:
        /* no labels to add for these types, fall through */
    default:
        break;
    }
    return pmdaLabel(ident, type, lpp, pmda);
}

static int
simple_labelCallBack(pmInDom indom, unsigned int inst, pmLabelSet **lp)
{
    struct timeslice *tsp;

    if (pmInDom_serial(indom) != NOW_INDOM)
        return 0;
    if (pmdaCacheLookup(indom, inst, NULL, (void *)&amp;tsp) != PMDA_CACHE_ACTIVE)
        return 0;
    /* SI units label, value: sec (seconds), min (minutes), hour (hours) */
    return pmdaAddLabels(lp, &quot;{&quot;units&quot;:&quot;%s&quot;}&quot;, tsp-&lt;tm_name);
}
</pre></div>
</div>
<p>The <strong>simple_labelCallBack</strong> function is called indirectly via <strong>pmdaLabel</strong> for each instance of the <strong>NOW_INDOM</strong>. PMDA initialization ensures these functions
are registered with the global PMDA interface structure for use when handling label requests, by the following assignments in the <strong>simple_init</strong> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dp-&gt;version.seven.label = simple_label;
pmdaSetLabelCallBack(dp, simple_labelCallBack);
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="other-issues">
<h2><a class="toc-backref" href="#id29">2.4. Other Issues</a><a class="headerlink" href="#other-issues" title="Permalink to this headline">¶</a></h2>
<p>Other issues include extracting the information, latency and threads of control, Name Space, PMDA help text, and management of evolution within a PMDA.</p>
<div class="section" id="extracting-the-information">
<h3><a class="toc-backref" href="#id30">2.4.1. Extracting the Information</a><a class="headerlink" href="#extracting-the-information" title="Permalink to this headline">¶</a></h3>
<p>A suggested approach to writing a PMDA is to write a standalone program to extract the values from the target domain and then incorporate this program into the
PMDA framework. This approach avoids concurrent debugging of two distinct problems:</p>
<ol class="arabic simple">
<li>Extraction of the data</li>
<li>Communication with PMCD</li>
</ol>
<p>These are some possible ways of exporting the data from the target domain:</p>
<ul class="simple">
<li>Accumulate the performance data in a public shared memory segment.</li>
<li>Write the performance data to the end of a log file.</li>
<li>Periodically rewrite a file with the most recent values for the performance data.</li>
<li>Implement a protocol that allows a third party to connect to the target application, send a request, and receive new performance data.</li>
<li>If the data is in the operating system kernel, provide a kernel interface (preferred) to export the performance data.</li>
</ul>
<p>Most of these approaches require some further data processing by the PMDA.</p>
</div>
<div class="section" id="latency-and-threads-of-control">
<h3><a class="toc-backref" href="#id31">2.4.2. Latency and Threads of Control</a><a class="headerlink" href="#latency-and-threads-of-control" title="Permalink to this headline">¶</a></h3>
<p>The PCP protocols expect PMDAs to return the current values for performance metrics when requested, and with short delay (low latency). For some target domains,
access to the underlying instrumentation may be costly or involve unpredictable delays (for example, if the real performance data is stored on some remote host or
network device). In these cases, it may be necessary to separate probing for new performance data from servicing PMCD requests.</p>
<p>An architecture that has been used successfully for several PMDAs is to create one or more child processes to obtain information while the main process
communicates with PMCD.</p>
<p>At the simplest deployment of this arrangement, the two processes may execute without synchronization. Threads have also been used as a more portable multithreading
mechanism; see the <strong>pthreads(7)</strong> man page.</p>
<p>By contrast, a complex deployment would be one in which the refreshing of the metric values must be atomic, and this may require double buffering of the data
structures. It also requires coordination between parent and child processes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Since certain data structures used by the PMDA library are not thread-aware, only one PMDA thread of control should call PMDA library functions - this would
typically be the thread servicing requests from PMCD.</p>
</div>
<p>One caveat about this style of caching PMDA–in this (special) case it is better if the PMDA converts counts to rates based upon consecutive periodic sampling
from the underlying instrumentation. By exporting precomputed rate metrics with instantaneous semantics, the PMDA prevents the PCP monitor tools from computing
their own rates upon consecutive PMCD fetches (which are likely to return identical values from a caching PMDA). The finer points of metric semantics are
discussed in Section 2.3.3.2, “<a class="reference internal" href="#semantics">Semantics</a>”</p>
</div>
<div class="section" id="name-space">
<h3><a class="toc-backref" href="#id32">2.4.3. Name Space</a><a class="headerlink" href="#name-space" title="Permalink to this headline">¶</a></h3>
<p>The PMNS file defines the name space of the PMDA. It is a simple text file that is used during installation to expand the Name Space of the PMCD process. The
format of this file is described by the <strong>pmns(5)</strong> man page and its hierarchical nature, syntax, and helper tools are further described in the <em>Performance Co-Pilot User’s and Administrator’s Guide</em>.</p>
<p>Client processes will not be able to access the PMDA metrics if the PMNS file is not installed as part of the PMDA installation procedure on the collector host.
The installed list of metric names and their corresponding PMIDs can be found in <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns/root</span></code>.</p>
<p><a class="reference internal" href="#example-2-15-pmns-file-for-the-simple-pmda">Example 2.15. pmns File for the Simple PMDA</a> shows the simple PMDA, which has five metrics:</p>
<p>Three metrics immediately under the <strong>simple</strong> node</p>
<p>Two metrics under another non-terminal node called <strong>simple.time</strong></p>
<p id="example-2-15-pmns-file-for-the-simple-pmda"><strong>Example 2.15. pmns File for the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>simple {
    numfetch    SIMPLE:0:0
    color       SIMPLE:0:1
    time
    now         SIMPLE:2:4
}
simple.time {
    user        SIMPLE:1:2
    sys         SIMPLE:1:3
}
</pre></div>
</div>
<p>Metrics that have different clusters do not have to be specified in different subtrees of the PMNS. <a class="reference internal" href="#example-2-16-alternate-pmns-file-for-the-simple-pmda">Example 2.16. Alternate pmns File for the Simple PMDA</a>
shows an alternative PMNS for the simple PMDA:</p>
<p id="example-2-16-alternate-pmns-file-for-the-simple-pmda"><strong>Example 2.16. Alternate pmns File for the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>simple {
    numfetch    SIMPLE:0:0
    color       SIMPLE:0:1
    usertime    SIMPLE:1:2
    systime     SIMPLE:1:3
}
</pre></div>
</div>
<p>In this example, the <strong>SIMPLE</strong> macro is replaced by the domain number listed in <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns/stdpmid</span></code> for the corresponding PMDA during installation
(for the simple PMDA, this would normally be the value 253).</p>
<p>If the PMDA implementer so chooses, all or a subset of the metric names and identifiers can be specified programatically. In this situation, a special asterisk
syntax is used to denote those subtrees which are to be handles this way. <a class="reference internal" href="#example-2-17-dynamic-metrics-pmns-file-for-the-simple-pmda">Example 2.17. Dynamic metrics pmns File for the Simple PMDA</a> shows this dynamic
namespace syntax, for all metrics in the simple PMDA:</p>
<p id="example-2-17-dynamic-metrics-pmns-file-for-the-simple-pmda"><strong>Example 2.17. Dynamic metrics pmns File for the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>simple         SIMPLE:*:*
</pre></div>
</div>
<p>In this example, like the one before, the <strong>SIMPLE</strong> macro is replaced by the domain number, and all (simple.*) metric namespace operations must be handled by
the PMDA. This is in contrast to the static metric name model earlier, where the host-wide PMNS file is updated and used by PMCD, acting on behalf of the agent.</p>
</div>
<div class="section" id="pmda-help-text">
<h3><a class="toc-backref" href="#id33">2.4.4. PMDA Help Text</a><a class="headerlink" href="#pmda-help-text" title="Permalink to this headline">¶</a></h3>
<p>For each metric defined within a PMDA, the PMDA developer is strongly encouraged to provide both terse and extended help text to describe the metric, and perhaps
provide hints about the expected value ranges.</p>
<p>The help text is used to describe each metric in the visualization tools and <strong>pminfo</strong> with the <strong>-T</strong> option. The help text, such as the help text for the
simple PMDA in <a class="reference internal" href="#example-2-18-help-text-for-the-simple-pmda">Example 2.18. Help Text for the Simple PMDA</a>, is specified in a specially formatted file, normally called <strong>help</strong>. This file is converted to
the expected run-time format using the <strong>newhelp</strong> command; see the <strong>newhelp(1)</strong> man page. Converted help text files are usually placed in the PMDA’s directory
below <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}</span></code> as part of the PMDA installation procedure.</p>
<p id="example-2-18-help-text-for-the-simple-pmda"><strong>Example 2.18. Help Text for the Simple PMDA</strong></p>
<p>The two instance domains and five metrics have a short and a verbose description. Each entry begins with a line that starts with the character “&#64;” and is followed
by either the metric name (<strong>simple.numfetch</strong>) or a symbolic reference to the instance domain number (<strong>SIMPLE.1</strong>), followed by the short description. The verbose
description is on the following lines, terminated by the next line starting with “&#64;” or end of file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@ SIMPLE.0 Instance domain “colour” for simple PMDA
Universally 3 instances, “red” (0), “green” (1) and “blue” (3).

@ SIMPLE.1 Dynamic instance domain “time” for simple PMDA
An instance domain is computed on-the-fly for exporting current time
information. Refer to the help text for simple.now for more details.

@ simple.numfetch Number of pmFetch operations.
The cumulative number of pmFetch operations directed to “simple” PMDA.

This counter may be modified with pmstore(1).

@ simple.color Metrics which increment with each fetch
This metric has 3 instances, designated “red”, “green” and “blue”.

The value of the metric is monotonic increasing in the range 0 to
255, then back to 0.  The different instances have different starting
values, namely 0 (red), 100 (green) and 200 (blue).

The metric values my be altered using pmstore(1).

@ simple.time.user Time agent has spent executing user code
The time in seconds that the CPU has spent executing agent user code.

@ simple.time.sys Time agent has spent executing system code
The time in seconds that the CPU has spent executing agent system code.

@ simple.now Time of day with a configurable instance domain
The value reflects the current time of day through a dynamically
reconfigurable instance domain.  On each metric value fetch request,
the agent checks to see whether the configuration file in
${PCP_PMDAS_DIR}/simple/simple.conf has been modified - if it has then
the file is re-parsed and the instance domain for this metric is again
constructed according to its contents.

This configuration file contains a single line of comma-separated time
tokens from this set:
  “sec”  (seconds after the minute),
  “min”  (minutes after the hour),
  “hour” (hour since midnight).

An example configuration file could be:  sec,min,hour
and in this case the simple.now metric would export values for the
three instances “sec”, “min” and “hour” corresponding respectively to
the components seconds, minutes and hours of the current time of day.

The instance domain reflects each token present in the file, and the
values reflect the time at which the PMDA processes the fetch.
</pre></div>
</div>
</div>
<div class="section" id="management-of-evolution-within-a-pmda">
<h3><a class="toc-backref" href="#id34">2.4.5. Management of Evolution within a PMDA</a><a class="headerlink" href="#management-of-evolution-within-a-pmda" title="Permalink to this headline">¶</a></h3>
<p>Evolution of a PMDA, or more particularly the underlying instrumentation to which it provides access, over time naturally results in the appearance of new metrics
and the disappearance of old metrics. This creates potential problems for PMAPI clients and PCP tools that may be required to interact with both new and former
versions of the PMDA.</p>
<p>The following guidelines are intended to help reduce the complexity of implementing a PMDA in the face of evolutionary change, while maintaining predictability
and semantic coherence for tools using the PMAPI, and for end users of those tools.</p>
<ul class="simple">
<li>Try to support as full a range of metrics as possible in every version of the PMDA. In this context, <em>support</em> means responding sensibly to requests, even if
the underlying instrumentation is not available.</li>
<li>If a metric is not supported in a given version of the underlying instrumentation, the PMDA should respond to <strong>pmLookupDesc</strong> requests with a <strong>pmDesc</strong>
structure whose <strong>type</strong> field has the special value <strong>PM_TYPE_NOSUPPORT</strong>. Values of fields other than <strong>pmid</strong> and <strong>type</strong> are immaterial, but
<a class="reference internal" href="#example-2-19-setting-values">Example 2.19. Setting Values</a> is typically benign:</li>
</ul>
<p id="example-2-19-setting-values"><strong>Example 2.19. Setting Values</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pmDesc dummy = {
     .pmid  = PMDA_PMID(3,0),           /* pmid, fill this in */
     .type  = PM_TYPE_NOSUPPORT,        /* this is the important part */
     .indom = PM_INDOM_NULL,            /* singular,causes no problems */
     .sem   = 0,                        /* no semantics */
     .units = PMDA_PMUNITS(0,0,0,0,0,0) /* no units */
};
</pre></div>
</div>
<ul class="simple">
<li>If a metric lacks support in a particular version of the underlying instrumentation, the PMDA should respond to <strong>pmFetch</strong> requests with a <strong>pmResult</strong> in which
no values are returned for the unsupported metric. This is marginally friendlier than the other semantically acceptable option of returning an illegal PMID error
or <strong>PM_ERR_PMID</strong>.</li>
<li>Help text should be updated with annotations to describe different versions of the underlying product, or product configuration options, for which a specific
metric is available. This is so <strong>pmLookupText</strong> can always respond correctly.</li>
<li>The <strong>pmStore</strong> operation should fail with return status of <strong>PM_ERR_PERMISSION</strong> if a user or application tries to amend the value of an unsupported metric.</li>
<li>The value extraction, conversion, and printing functions (<strong>pmExtractValue, pmConvScale, pmAtomStr, pmTypeStr</strong>, and <strong>pmPrintValue</strong>) return the <strong>PM_ERR_CONV</strong>
error or an appropriate diagnostic string, if an attempt is made to operate on a value for which <strong>type</strong> is <strong>PM_TYPE_NOSUPPORT</strong>.</li>
<li>If performance tools take note of the <strong>type</strong> field in the <strong>pmDesc</strong> structure, they should not manipulate values for unsupported metrics. Even if tools ignore
<strong>type</strong> in the metric’s description, following these development guidelines ensures that no misleading value is ever returned; so there is no reason to call the
extraction, conversion, and printing functions.</li>
</ul>
</div>
</div>
<div class="section" id="pmda-interface">
<h2><a class="toc-backref" href="#id35">2.5. PMDA Interface</a><a class="headerlink" href="#pmda-interface" title="Permalink to this headline">¶</a></h2>
<p>This section describes an interface for the request handling callbacks in a PMDA. This interface is used by PMCD for communicating with DSO PMDAs and is also used
by daemon PMDAs with <strong>pmdaMain</strong>.</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id36">2.5.1. Overview</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Both daemon and DSO PMDAs must handle multiple request types from PMCD. A daemon PMDA communicates with PMCD using the PDU protocol, while a DSO PMDA defines
callbacks for each request type. To avoid duplicating this PDU processing (in the case of a PMDA that can be installed either as a daemon or as a DSO), and to
allow a consistent framework, <strong>pmdaMain</strong> can be used by a daemon PMDA as a wrapper to handle the communication protocol using the same callbacks as a DSO PMDA.
This allows a PMDA to be built as both a daemon and a DSO, and then to be installed as either.</p>
<p>To further simplify matters, default callbacks are declared in <strong>&lt;pcp/pmda.h&gt;</strong>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>pmdaFetch</td>
</tr>
<tr class="row-even"><td>pmdaProfile</td>
</tr>
<tr class="row-odd"><td>pmdaInstance</td>
</tr>
<tr class="row-even"><td>pmdaDesc</td>
</tr>
<tr class="row-odd"><td>pmdaText</td>
</tr>
<tr class="row-even"><td>pmdaStore</td>
</tr>
<tr class="row-odd"><td>pmdaPMID</td>
</tr>
<tr class="row-even"><td>pmdaName</td>
</tr>
<tr class="row-odd"><td>pmdaChildren</td>
</tr>
<tr class="row-even"><td>pmdaAttribute</td>
</tr>
<tr class="row-odd"><td>pmdaLabel</td>
</tr>
</tbody>
</table>
<p>Each callback takes a <strong>pmdaExt</strong> structure as its last argument. This structure contains all the information that is required by the default callbacks in most
cases. The one exception is <strong>pmdaFetch</strong>, which needs an additional callback to instantiate the current value for each supported combination of a performance
metric and an instance.</p>
<p>Therefore, for most PMDAs all the communication with PMCD is automatically handled by functions in <strong>libpcp.so</strong> and <strong>libpcp_pmda.so</strong>.</p>
<div class="section" id="trivial-pmda">
<h4><a class="toc-backref" href="#id37">2.5.1.1. Trivial PMDA</a><a class="headerlink" href="#trivial-pmda" title="Permalink to this headline">¶</a></h4>
<p>The trivial PMDA uses all of the default callbacks as shown in <a class="reference internal" href="#example-2-20-request-handling-callbacks-in-the-trivial-pmda">Example 2.20. Request Handling Callbacks in the Trivial PMDA</a>. The additional callback for
<strong>pmdaFetch</strong> is defined as <strong>trivial_fetchCallBack</strong>:</p>
<p id="example-2-20-request-handling-callbacks-in-the-trivial-pmda"><strong>Example 2.20. Request Handling Callbacks in the Trivial PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int
trivial_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   __pmID_int      *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);

   if (idp-&gt;cluster != 0 || idp-&gt;item != 0)
       return PM_ERR_PMID;
   if (inst != PM_IN_NULL)
       return PM_ERR_INST;
   atom-&gt;l = time(NULL);
   return 0;
}
</pre></div>
</div>
<p>This function checks that the PMID and instance are valid, and then places the metric value for the current time into the <strong>pmAtomValue</strong> structure.</p>
<p>The callback is set up by a call to <strong>pmdaSetFetchCallBack</strong> in <strong>trivial_init</strong>. As a rule of thumb, the API routines with named ending with <strong>CallBack</strong> are
helpers for the higher PDU handling routines like <strong>pmdaFetch</strong>. The latter are set directly using the PMDA Interface Structures, as described in Section
2.5.2, “<a class="reference internal" href="#pmda-structures">PMDA Structures</a>”.</p>
</div>
<div class="section" id="simple-pmda">
<h4><a class="toc-backref" href="#id38">2.5.1.2. Simple PMDA</a><a class="headerlink" href="#simple-pmda" title="Permalink to this headline">¶</a></h4>
<p>The simple PMDA callback for <strong>pmdaFetch</strong> is more complicated because it supports more metrics, some metrics are instantiated with each fetch, and one instance
domain is dynamic. The default <strong>pmdaFetch</strong> callback, shown in <a class="reference internal" href="#example-2-21-request-handling-callbacks-in-the-simple-pmda">Example 2.21. Request Handling Callbacks in the Simple PMDA</a>, is replaced by <strong>simple_fetch</strong>
in <strong>simple_init</strong>, which increments the number of fetches and updates the instance domain for <strong>INDOM_NOW</strong> before calling <strong>pmdaFetch</strong>:</p>
<p id="example-2-21-request-handling-callbacks-in-the-simple-pmda"><strong>Example 2.21. Request Handling Callbacks in the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int
simple_fetch(int numpmid, pmID pmidlist[], pmResult **resp, pmdaExt *pmda)
{
    numfetch++;
    simple_timenow_check();
    simple_timenow_refresh();
    return pmdaFetch(numpmid, pmidlist, resp, pmda);
}
</pre></div>
</div>
<p>The callback for <strong>pmdaFetch</strong> is defined as <strong>simple_fetchCallBack</strong>. The PMID is extracted from the <strong>pmdaMetric</strong> structure, and if valid, the appropriate field
in the <strong>pmAtomValue</strong> structure is set. The available types and associated fields are described further in Section 3.4, “<a class="reference internal" href="PMAPI.html#performance-metric-descriptions"><span class="std std-ref">Performance Metric Descriptions</span></a>” and
<a class="reference internal" href="PMAPI.html#example-3-18-pmatomvalue-structure"><span class="std std-ref">Example 3.18. pmAtomValue Structure</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that PMID validity checking need only check the cluster and item numbers, the domain number is guaranteed to be valid and the PMDA should make no
assumptions about the actual domain number being used at this point.</p>
</div>
<p>The <strong>simple.numfetch</strong> metric has no instance domain and is easily handled first as shown in <a class="reference internal" href="#example-2-22-simple-numfetch-metric">Example 2.22. simple.numfetch Metric</a>:</p>
<p id="example-2-22-simple-numfetch-metric"><strong>Example 2.22. simple.numfetch Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int
simple_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   int             i;
   static int      oldfetch;
   static double   usr, sys;
   __pmID_int      *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);

   if (inst != PM_IN_NULL &amp;&amp;
       !(idp-&gt;cluster == 0 &amp;&amp; idp-&gt;item == 1) &amp;&amp;
       !(idp-&gt;cluster == 2 &amp;&amp; idp-&gt;item == 4))
       return PM_ERR_INST;
   if (idp-&gt;cluster == 0) {
       if (idp-&gt;item == 0) {                   /* simple.numfetch */
           atom-&gt;l = numfetch;
       }
</pre></div>
</div>
<p>In <a class="reference internal" href="#example-2-23-simple-color-metric">Example 2.23. simple.color Metric</a>, the <strong>inst</strong> parameter is used to specify which instance is required for the <strong>simple.color</strong> metric:</p>
<p id="example-2-23-simple-color-metric"><strong>Example 2.23. simple.color Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>else if (idp-&gt;item == 1) {              /* simple.color */
      switch (inst) {
      case 0:                             /* red */
          red = (red + 1) % 256;
          atom-&gt;l = red;
          break;
      case 1:                             /* green */
          green = (green + 1) % 256;
          atom-&gt;l = green;
          break;
      case 2:                             /* blue */
          blue = (blue + 1) % 256;
          atom-&gt;l = blue;
          break;
      default:
          return PM_ERR_INST;
      }
 }
 else
     return PM_ERR_PMID;
</pre></div>
</div>
<p>In <a class="reference internal" href="#example-2-24-simple-time-metric">Example 2.24. simple.time Metric</a>, the <strong>simple.time</strong> metric is in a second cluster and has a simple optimization to reduce the overhead of calling <strong>times</strong>
twice on the same fetch and return consistent values from a single call to <strong>times</strong> when both metrics <strong>simple.time.user</strong> and <strong>simple.time.sys</strong> are requested
in a single <strong>pmFetch</strong>. The previous fetch count is used to determine if the <strong>usr</strong> and <strong>sys</strong> values should be updated:</p>
<p id="example-2-24-simple-time-metric"><strong>Example 2.24. simple.time Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>else if (idp-&gt;cluster == 1) {               /* simple.time */
    if (oldfetch &lt; numfetch) {
        __pmProcessRunTimes(&amp;usr, &amp;sys);
        oldfetch = numfetch;
    }
    if (idp-&gt;item == 2)                     /* simple.time.user */
        atom-&gt;d = usr;
    else if (idp-&gt;item == 3)                /* simple.time.sys */
        atom-&gt;d = sys;
    else
        return PM_ERR_PMID;
 }
</pre></div>
</div>
<p>In <a class="reference internal" href="#example-2-25-simple-now-metric">Example 2.25. simple.now Metric</a>, the <strong>simple.now</strong> metric is in a third cluster and uses <strong>inst</strong> again to select a specific instance from the <strong>INDOM_NOW</strong>
instance domain. The values associated with instances in this instance domain are managed using the <strong>pmdaCache(3)</strong> helper routines, which provide efficient interfaces
for managing more complex instance domains:</p>
<p id="example-2-25-simple-now-metric"><strong>Example 2.25. simple.now Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>else if (idp-&gt;cluster == 2) {
    if (idp-&gt;item == 4) {                 /* simple.now */
        struct timeslice *tsp;
        sts = pmdaCacheLookup(*now_indom, inst, NULL, (void *)&amp;tsp);
        if (sts != PMDA_CACHE_ACTIVE) {
            if (sts &lt; 0)
                pmNotifyErr(LOG_ERR, &quot;pmdaCacheLookup failed: inst=%d: %s&quot;,
                              inst, pmErrStr(sts));
            return PM_ERR_INST;
        }
        atom-&gt;l = tsp-&gt;tm_field;
    }
    else
        return PM_ERR_PMID;
}
</pre></div>
</div>
</div>
<div class="section" id="simple-store-in-the-simple-pmda">
<h4><a class="toc-backref" href="#id39">2.5.1.3. simple_store in the Simple PMDA</a><a class="headerlink" href="#simple-store-in-the-simple-pmda" title="Permalink to this headline">¶</a></h4>
<p>The simple PMDA permits some of the metrics it supports to be modified by <strong>pmStore</strong> as shown in <a class="reference internal" href="#example-2-26-simple-store-in-the-simple-pmda">Example 2.26. simple_store in the Simple PMDA</a>.
For additional information, see the <strong>pmstore(1)</strong> and <strong>pmStore(3)</strong> man pages.</p>
<p id="example-2-26-simple-store-in-the-simple-pmda"><strong>Example 2.26. simple_store in the Simple PMDA</strong></p>
<p>The <strong>pmdaStore</strong> callback (which returns <strong>PM_ERR_PERMISSION</strong> to indicate no metrics can be altered) is replaced by <strong>simple_store</strong> in <strong>simple_init</strong>.
This replacement function must take the same arguments so that it can be assigned to the function pointer in the <strong>pmdaInterface</strong> structure.</p>
<p>The function traverses the <strong>pmResult</strong> and checks the cluster and unit of each PMID to ensure that it corresponds to a metric that can be changed. Checks are
made on the values to ensure they are within range before being assigned to variables in the PMDA that hold the current values for exported metrics:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int
simple_store(pmResult *result, pmdaExt *pmda)
{
    int         i, j, val, sts = 0;
    pmAtomValue av;
    pmValueSet  *vsp = NULL;
    __pmID_int  *pmidp = NULL;

    /* a store request may affect multiple metrics at once */
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        vsp = result-&gt;vset[i];
        pmidp = (__pmID_int *)&amp;vsp-&gt;pmid;
        if (pmidp-&gt;cluster == 0) {  /* storable metrics are cluster 0 */
            switch (pmidp-&gt;item) {
            case 0:                           /* simple.numfetch */
                val = vsp-&gt;vlist[0].value.lval;
                if (val &lt; 0) {
                    sts = PM_ERR_SIGN;
                    val = 0;
                }
                numfetch = val;
                break;
            case 1:                             /* simple.color */
                /* a store request may affect multiple instances at once */
                for (j = 0; j &lt; vsp-&gt;numval &amp;&amp; sts == 0; j++) {
                    val = vsp-&gt;vlist[j].value.lval;
                    if (val &lt; 0) {
                        sts = PM_ERR_SIGN;
                        val = 0;
                    } if (val &gt; 255) {
                        sts = PM_ERR_CONV;
                        val = 255;
                    }
</pre></div>
</div>
<p>The <strong>simple.color</strong> metric has an instance domain that must be searched because any or all instances may be specified. Any instances that are not supported in
this instance domain should cause an error value of <strong>PM_ERR_INST</strong> to be returned as shown in <a class="reference internal" href="#example-2-27-simple-color-and-pm-err-inst-errors">Example 2.27. simple.color and PM_ERR_INST Errors</a>:</p>
<p id="example-2-27-simple-color-and-pm-err-inst-errors"><strong>Example 2.27. simple.color and PM_ERR_INST Errors</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (vsp-&gt;vlist[j].inst) {
case 0:                         /* red */
    red = val;
    break;
case 1:                         /* green */
    green = val;
    break;
case 2:                         /* blue */
    blue = val;
    break;
default:
    sts = PM_ERR_INST;
}
</pre></div>
</div>
<p>Any other PMIDs in cluster 0 that are not supported by the simple PMDA should result in an error value of <strong>PM_ERR_PMID</strong> as shown in
<a class="reference internal" href="#example-2-28-pm-err-pmid-errors">Example 2.28. PM_ERR_PMID Errors</a>:</p>
<p id="example-2-28-pm-err-pmid-errors"><strong>Example 2.28. PM_ERR_PMID Errors</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        default:
            sts = PM_ERR_PMID;
            break;
    }
}
</pre></div>
</div>
<p>Any metrics that cannot be altered should generate an error value of <strong>PM_ERR_PERMISSION</strong>, and metrics not supported by the PMDA should result in an error value
of <strong>PM_ERR_PMID</strong> as shown in <a class="reference internal" href="#example-2-29-pm-err-permission-and-pm-err-pmid-errors">Example 2.29. PM_ERR_PERMISSION and PM_ERR_PMID Errors</a>:</p>
<p id="example-2-29-pm-err-permission-and-pm-err-pmid-errors"><strong>Example 2.29. PM_ERR_PERMISSION and PM_ERR_PMID Errors</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        else if ((pmidp-&gt;cluster == 1 &amp;&amp;
                 (pmidp-&gt;item == 2 || pmidp-&gt;item == 3)) ||
                 (pmidp-&gt;cluster == 2 &amp;&amp; pmidp-&gt;item == 4)) {
            sts = PM_ERR_PERMISSION;
            break;
        }
        else {
            sts = PM_ERR_PMID;
            break;
        }
    }
    return sts;
}
</pre></div>
</div>
<p>The structure <strong>pmdaExt</strong> <em>pmda</em> argument is not used by the <strong>simple_store</strong> function above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using storable metrics, it is important to consider the implications. It is possible <strong>pmlogger</strong> is actively sampling the metric being modified, for
example, which may cause unexpected results to be persisted in an archive. Consider also the use of client credentials, available via the <strong>attribute</strong> callback
of the <strong>pmdaInterface</strong> structure, to appropriately limit access to any modifications that might be made via your storable metrics.</p>
</div>
</div>
<div class="section" id="return-codes-for-pmdafetch-callbacks">
<h4><a class="toc-backref" href="#id40">2.5.1.4. Return Codes for pmdaFetch Callbacks</a><a class="headerlink" href="#return-codes-for-pmdafetch-callbacks" title="Permalink to this headline">¶</a></h4>
<p>In <strong>PMDA_INTERFACE_1</strong> and <strong>PMDA_INTERFACE_2</strong>, the return codes for the <strong>pmdaFetch</strong> callback function are defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt; 0</td>
<td>Error code (for example, <strong>PM_ERR_PMID, PM_ERR_INST</strong> or <strong>PM_ERR_AGAIN</strong>)</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>Success</td>
</tr>
</tbody>
</table>
<p>In <strong>PMDA_INTERFACE_3</strong> and all later versions, the return codes for the <strong>pmdaFetch</strong> callback function are defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt; 0</td>
<td>Error code (for example, <strong>PM_ERR_PMID, PM_ERR_INST</strong>)</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>Metric value not currently available</td>
</tr>
<tr class="row-even"><td>&gt; 0</td>
<td>Success</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="pmda-structures">
<h3><a class="toc-backref" href="#id41">2.5.2. PMDA Structures</a><a class="headerlink" href="#pmda-structures" title="Permalink to this headline">¶</a></h3>
<p>PMDA structures used with the <strong>pcp_pmda</strong> library are defined in <strong>&lt;pcp/pmda.h&gt;</strong>. <a class="reference internal" href="#example-2-30-pmdainterface-structure-header">Example 2.30. pmdaInterface Structure Header</a> and
<a class="reference internal" href="#example-2-32-pmdaext-stucture">Example 2.32. pmdaExt Stucture</a> describe the <strong>pmdaInterface</strong> and <strong>pmdaExt</strong> structures.</p>
<p id="example-2-30-pmdainterface-structure-header"><strong>Example 2.30. pmdaInterface Structure Header</strong></p>
<p>The callbacks must be specified in a <strong>pmdaInterface</strong> structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    int domain;     /* set/return performance metrics domain id here */
    struct {
        unsigned int pmda_interface : 8;  /* PMDA DSO version */
        unsigned int pmapi_version : 8;   /* PMAPI version */
        unsigned int flags : 16;          /* optional feature flags */
    } comm;             /* set/return communication and version info */
    int status;         /* return initialization status here */
    union {
        ...
</pre></div>
</div>
<p>This structure is passed by PMCD to a DSO PMDA as an argument to the initialization function. This structure supports multiple (binary-compatible) versions–the
second and subsequent versions have support for the <strong>pmdaExt</strong> structure. Protocol version one is for backwards compatibility only, and should not be used in
any new PMDA.</p>
<p>To date there have been six revisions of the interface structure:</p>
<ol class="arabic simple">
<li>Version two added the <strong>pmdaExt</strong> structure, as mentioned above.</li>
<li>Version three changed the fetch callback return code semantics, as mentioned in Section 2.5.1.4, “<a class="reference internal" href="#return-codes-for-pmdafetch-callbacks">Return Codes for pmdaFetch Callbacks</a>”.</li>
<li>Version four added support for dynamic metric names, where the PMDA is able to create and remove metric names on-the-fly in response to changes in the
performance domain (<strong>pmdaPMID, pmdaName, pmdaChildren</strong> interfaces)</li>
<li>Version five added support for per-client contexts, where the PMDA is able to track arrival and disconnection of PMAPI client tools via PMCD (<strong>pmdaGetContext</strong>
helper routine). At the same time, support for <strong>PM_TYPE_EVENT</strong> metrics was implemented, which relies on the per-client context concepts (<strong>pmdaEvent*</strong>
helper routines).</li>
<li>Version six added support for authenticated client contexts, where the PMDA is informed of user credentials and other PMCD attributes of the connection between
individual PMAPI clients and PMCD (<strong>pmdaAttribute</strong> interface)</li>
<li>Version seven added support for metadata labels, where the PMDA is able to associate name:value pairs in a hierarchy such that additional metadata, above and
beyond the metric descriptors, is associated with metrics and instances (<strong>pmdaLabel</strong> interface)</li>
</ol>
<p><strong>Example 2.31. pmdaInterface Structure, Latest Version</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   ...
    union {
        ...
        /*
         * PMDA_INTERFACE7
         */
        struct {
            pmdaExt *ext;
            int     (*profile)(pmdaInProfile *, pmdaExt *);
            int     (*fetch)(int, pmID *, pmResult **, pmdaExt *);
            int     (*desc)(pmID, pmDesc *, pmdaExt *);
            int     (*instance)(pmInDom, int, char *, pmdaInResult **, pmdaExt *);
            int     (*text)(int, int, char **, pmdaExt *);
            int     (*store)(pmResult *, pmdaExt *);
            int     (*pmid)(const char *, pmID *, pmdaExt *);
            int     (*name)(pmID, char ***, pmdaExt *);
            int     (*children)(const char *, int, char ***, int **, pmdaExt *);
            int     (*attribute)(int, int, const char *, int, pmdaExt *);
            int     (*label)(int, int, pmLabelSet **, pmdaExt *);
        } seven;
    } version;
} pmdaInterface;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Each new interface version is always defined as a superset of those that preceded it, only adds fields at the end of the new structure in the union, and is
always binary backwards-compatible. <strong>And thus it shall remain</strong>. For brevity, we have shown only the latest interface version (seven) above, but all prior
versions still exist, build, and function. In other words, PMDAs built against earlier versions of this header structure (and PMDA library) function correctly
with the latest version of the PMDA library.</p>
</div>
<p id="example-2-32-pmdaext-stucture"><strong>Example 2.32. pmdaExt Stucture</strong></p>
<p>Additional PMDA information must be specified in a <strong>pmdaExt</strong> structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    unsigned int e_flags;       /* PMDA_EXT_FLAG_* bit field */
    void        *e_ext;         /* used internally within libpcp_pmda */
    char        *e_sockname;    /* socket name to pmcd */
    char        *e_name;        /* name of this pmda */
    char        *e_logfile;     /* path to log file */
    char        *e_helptext;    /* path to help text */
    int         e_status;       /* =0 is OK */
    int         e_infd;         /* input file descriptor from pmcd */
    int         e_outfd;        /* output file descriptor to pmcd */
    int         e_port;         /* port to pmcd */
    int         e_singular;     /* =0 for singular values */
    int         e_ordinal;      /* &gt;=0 for non-singular values */
    int         e_direct;       /* =1 if pmid map to meta table */
    int         e_domain;       /* metrics domain */
    int         e_nmetrics;     /* number of metrics */
    int         e_nindoms;      /* number of instance domains */
    int         e_help;         /* help text comes via this handle */
    pmProfile   *e_prof;        /* last received profile */
    pmdaIoType  e_io;           /* connection type to pmcd */
    pmdaIndom   *e_indoms;      /* instance domain table */
    pmdaIndom   *e_idp;         /* instance domain expansion */
    pmdaMetric  *e_metrics;     /* metric description table */
    pmdaResultCallBack e_resultCallBack; /* to clean up pmResult after fetch */
    pmdaFetchCallBack  e_fetchCallBack;  /* to assign metric values in fetch */
    pmdaCheckCallBack  e_checkCallBack;  /* callback on receipt of a PDU */
    pmdaDoneCallBack   e_doneCallBack;   /* callback after PDU is processed */
    /* added for PMDA_INTERFACE_5 */
    int         e_context;      /* client context id from pmcd */
    pmdaEndContextCallBack e_endCallBack;  /* callback after client context closed */
    /* added for PMDA_INTERFACE_7 */
    pmdaLabelCallBack  e_labelCallBack;  /* callback to lookup metric instance labels */
} pmdaExt;
</pre></div>
</div>
<p>The <strong>pmdaExt</strong> structure contains filenames, pointers to tables, and some variables shared by several functions in the <strong>pcp_pmda</strong> library. All fields of the
<strong>pmdaInterface</strong> and <strong>pmdaExt</strong> structures can be correctly set by PMDA initialization functions; see the <strong>pmdaDaemon(3)</strong>, <strong>pmdaDSO(3)</strong>, <strong>pmdaGetOptions(3)</strong>,
<strong>pmdaInit(3)</strong>, and <strong>pmdaConnect(3)</strong> man pages for a full description of how various fields in these structures may be set or used by <strong>pcp_pmda</strong> library functions.</p>
</div>
</div>
<div class="section" id="initializing-a-pmda">
<h2><a class="toc-backref" href="#id42">2.6. Initializing a PMDA</a><a class="headerlink" href="#initializing-a-pmda" title="Permalink to this headline">¶</a></h2>
<p>Several functions are provided to simplify the initialization of a PMDA. These functions, if used, must be called in a strict order so that the PMDA can operate correctly.</p>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id43">2.6.1. Overview</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The initialization process for a PMDA involves opening help text files, assigning callback function pointers, adjusting the metric and instance identifiers to the
correct domains, and much more. The initialization of a daemon PMDA also differs significantly from a DSO PMDA, since the <strong>pmdaInterface</strong> structure is initialized
by <strong>main</strong> or the PMCD process, respectively.</p>
</div>
<div class="section" id="common-initialization">
<h3><a class="toc-backref" href="#id44">2.6.2. Common Initialization</a><a class="headerlink" href="#common-initialization" title="Permalink to this headline">¶</a></h3>
<p>As described in Section 2.2.2, “<a class="reference internal" href="#dso-pmda">DSO PMDA</a>”, an initialization function is provided by a DSO PMDA and called by PMCD. Using the standard PMDA wrappers, the same
function can also be used as part of the daemon PMDA initialization. This PMDA initialization function performs the following tasks:</p>
<ul class="simple">
<li>Assigning callback functions to the function pointer interface of <strong>pmdaInterface</strong></li>
<li>Assigning pointers to the metric and instance tables from <strong>pmdaExt</strong></li>
<li>Opening the help text files</li>
<li>Assigning the domain number to the instance domains</li>
<li>Correlating metrics with their instance domains</li>
</ul>
<p>If the PMDA uses the common data structures defined for the <strong>pcp_pmda</strong> library, most of these requirements can be handled by the default <strong>pmdaInit</strong>
function; see the <strong>pmdaInit(3)</strong> man page.</p>
<p>Because the initialization function is the only initialization opportunity for a DSO PMDA, the common initialization function should also perform any DSO-specific
functions that are required. A default implementation of this functionality is provided by the <strong>pmdaDSO</strong> function; see the <strong>pmdaDSO(3)</strong> man page.</p>
<div class="section" id="id6">
<h4><a class="toc-backref" href="#id45">2.6.2.1. Trivial PMDA</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#example-2-33-initialization-in-the-trivial-pmda">Example 2.33. Initialization in the Trivial PMDA</a> shows the trivial PMDA, which has no instances (that is, all metrics have singular values) and a single
callback. This callback is for the <strong>pmdaFetch</strong> function called <strong>trivial_fetchCallBack</strong>; see the <strong>pmdaFetch(3)</strong> man page:</p>
<p id="example-2-33-initialization-in-the-trivial-pmda"><strong>Example 2.33. Initialization in the Trivial PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static char     *username;
static int      isDSO = 1;              /* ==0 if I am a daemon */

void trivial_init(pmdaInterface *dp)
{
    if (isDSO)
        pmdaDSO(dp, PMDA_INTERFACE_2, “trivial DSO”,
                “${PCP_PMDAS_DIR}/trivial/help”);
    else
        pmSetProcessIdentity(username);

    if (dp-&gt;status != 0)
        return;

    pmdaSetFetchCallBack(dp, trivial_fetchCallBack);
    pmdaInit(dp, NULL, 0,
             metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}
</pre></div>
</div>
<p>The trivial PMDA can execute as either a DSO or daemon PMDA. A default installation installs it as a daemon, however, and the <strong>main</strong> routine clears <em>isDSO</em> and
sets <em>username</em> accordingly.</p>
<p>The <strong>trivial_init</strong> routine provides the opportunity to do any extra DSO or daemon setup before calling the library <strong>pmdaInit</strong>. In the example, the help text is
setup for DSO mode and the daemon is switched to run as an unprivileged user (default is <strong>root</strong>, but it is generally good form for PMDAs to run with the least
privileges possible). If <strong>dp-&gt;status</strong> is non-zero after the <strong>pmdaDSO</strong> call, the PMDA will be removed by PMCD and cannot safely continue to use the <strong>pmdaInterface</strong>
structure.</p>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id46">2.6.2.2. Simple PMDA</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>In <a class="reference internal" href="#example-2-34-initialization-in-the-simple-pmda">Example 2.34. Initialization in the Simple PMDA</a>, the simple PMDA uses its own callbacks to handle <strong>PDU_FETCH</strong> and <strong>PDU_RESULT</strong> request PDUs (for
<strong>pmFetch</strong> and <strong>pmStore</strong> operations respectively), as well as providing <strong>pmdaFetch</strong> with the callback <strong>simple_fetchCallBack</strong>.</p>
<p id="example-2-34-initialization-in-the-simple-pmda"><strong>Example 2.34. Initialization in the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int      isDSO = 1;              /* =0 I am a daemon */
static char     *username;

void simple_init(pmdaInterface *dp)
{
    if (isDSO)
        pmdaDSO(dp, PMDA_INTERFACE_7, “simple DSO”,
                “${PCP_PMDAS_DIR}/simple/help”);
    else
        pmSetProcessIdentity(username);

    if (dp-&gt;status != 0)
        return;

    dp-&gt;version.any.fetch = simple_fetch;
    dp-&gt;version.any.store = simple_store;
    dp-&gt;version.any.instance = simple_instance;
    dp-&gt;version.seven.label = simple_label;
    pmdaSetFetchCallBack(dp, simple_fetchCallBack);
    pmdaSetLabelCallBack(dp, simple_labelCallBack);
    pmdaInit(dp, indomtab, sizeof(indomtab)/sizeof(indomtab[0]),
             metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}
</pre></div>
</div>
<p>Once again, the simple PMDA may be installed either as a daemon PMDA or a DSO PMDA. The static variable <em>isDSO</em> indicates whether the PMDA is running as a DSO or
as a daemon. A daemon PMDA always changes the value of this variable to 0 in <em>main</em>, for PMDAs that can operate in both modes.</p>
<p>Remember also, as described earlier, <strong>simple_fetch</strong> is dealing with a single request for (possibly many) values for metrics from the PMDA, and <strong>simple_fetchCallBack</strong>
is its little helper, dealing with just one metric and one instance (optionally, if the metric happens to have an instance domain) within that larger request.</p>
</div>
</div>
<div class="section" id="daemon-initialization">
<h3><a class="toc-backref" href="#id47">2.6.3. Daemon Initialization</a><a class="headerlink" href="#daemon-initialization" title="Permalink to this headline">¶</a></h3>
<p>In addition to the initialization function that can be shared by a DSO and a daemon PMDA, a daemon PMDA must also meet the following requirements:</p>
<ul class="simple">
<li>Create the <strong>pmdaInterface</strong> structure that is passed to the initialization function</li>
<li>Parse any command-line arguments</li>
<li>Open a log file (a DSO PMDA uses PMCD’s log file)</li>
<li>Set up the IPC connection between the PMDA and the PMCD process</li>
<li>Handle incoming PDUs</li>
</ul>
<p>All these requirements can be handled by default initialization functions in the <strong>pcp_pmda</strong> library; see the <strong>pmdaDaemon(3), pmdaGetOptions(3), pmdaOpenLog(3),</strong>
<strong>pmdaConnect(3)</strong>, and <strong>pmdaMain(3)</strong> man pages.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Optionally, a daemon PMDA may wish to reduce or change its privilege level, as seen in <a class="reference internal" href="#example-2-33-initialization-in-the-trivial-pmda">Example 2.33. Initialization in the Trivial PMDA</a> and
<a class="reference internal" href="#example-2-34-initialization-in-the-simple-pmda">Example 2.34. Initialization in the Simple PMDA</a>. Some performance domains <strong>require</strong> the extraction process to run as a specific user in order to access
the instrumentation. Many domains require the default <strong>root</strong> level of access for a daemon PMDA.</p>
</div>
<p>The simple PMDA specifies the command-line arguments it accepts using <strong>pmdaGetOptions</strong>, as shown in <a class="reference internal" href="#example-2-35-main-in-the-simple-pmda">Example 2.35. main in the Simple PMDA</a>.
For additional information, see the <strong>pmdaGetOptions(3)</strong> man page.</p>
<p id="example-2-35-main-in-the-simple-pmda"><strong>Example 2.35. main in the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static pmLongOptions longopts[] = {
    PMDA_OPTIONS_HEADER(“Options”),
    PMOPT_DEBUG,
    PMDAOPT_DOMAIN,
    PMDAOPT_LOGFILE,
    PMDAOPT_USERNAME,
    PMOPT_HELP,
    PMDA_OPTIONS_TEXT(“\nExactly one of the following options may appear:”),
    PMDAOPT_INET,
    PMDAOPT_PIPE,
    PMDAOPT_UNIX,
    PMDAOPT_IPV6,
    PMDA_OPTIONS_END
};
static pmdaOptions opts = {
    .short_options = “D:d:i:l:pu:U:6:?”,
    .long_options = longopts,
};

int
main(int argc, char **argv)
{
    pmdaInterface       dispatch;

    isDSO = 0;
    pmSetProgname(argv[0]);
    pmGetUsername(&amp;username);
    pmdaDaemon(&amp;dispatch, PMDA_INTERFACE_7, pmGetProgname(), SIMPLE,
               “simple.log”, “${PCP_PMDAS_DIR}/simple/help”);

    pmdaGetOptions(argc, argv, &amp;opts, &amp;dispatch);
    if (opts.errors) {
        pmdaUsageMessage(&amp;opts);
        exit(1);
    }
    if (opts.username)
        username = opts.username;

    pmdaOpenLog(&amp;dispatch);
    simple_init(&amp;dispatch);
    simple_timenow_check();
    pmdaConnect(&amp;dispatch);
    pmdaMain(&amp;dispatch);

    exit(0);
}
</pre></div>
</div>
<p>The conditions under which <strong>pmdaMain</strong> will return are either unexpected error conditions (often from failed initialisation, which would already have been logged),
or when PMCD closes the connection to the PMDA. In all cases the correct action to take is simply to exit cleanly, possibly after any final cleanup the PMDA may
need to perform.</p>
</div>
</div>
<div class="section" id="testing-and-debugging-a-pmda">
<h2><a class="toc-backref" href="#id48">2.7. Testing and Debugging a PMDA</a><a class="headerlink" href="#testing-and-debugging-a-pmda" title="Permalink to this headline">¶</a></h2>
<p>Ensuring the correct operation of a PMDA can be difficult, because the responsibility of providing metrics to the requesting PMCD process and simultaneously
retrieving values from the target domain requires nearly real-time communication with two modules beyond the PMDA’s control. Some tools are available to assist in
this important task.</p>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id49">2.7.1. Overview</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Thoroughly testing a PMDA with PMCD is difficult, although testing a daemon PMDA is marginally simpler than testing a DSO PMDA. If a DSO PMDA exits, PMCD also
exits because they share a single address space and control thread.</p>
<p>The difficulty in using PMCD to test a daemon PMDA results from PMCD requiring timely replies from the PMDA in response to request PDUs. Although a timeout period
can be set in <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDOPTIONS_PATH}</span></code>, attaching a debugger (such as <strong>gdb</strong>) to the PMDA process might cause an already running PMCD to close its connection
with the PMDA. If timeouts are disabled, PMCD could wait forever to connect with the PMDA.</p>
<p>If you suspect a PMDA has been terminated due to a timeout failure, check the PMCD log file, usually <code class="docutils literal notranslate"><span class="pre">${PCP_LOG_DIR}/pmcd/pmcd.log</span></code>.</p>
<p>A more robust way of testing a PMDA is to use the <strong>dbpmda</strong> tool, which is similar to PMCD except that <strong>dbpmda</strong> provides complete control over the PDUs that are
sent to the PMDA, and there are no time limits–it is essentially an interactive debugger for exercising a PMDA. See the <strong>dbpmda(3)</strong> man page for details.</p>
<p>In addition, careful use of PCP debugging flags can produce useful information concerning a PMDA’s behavior; see the <strong>PMAPI(3)</strong> and <strong>pmdbg(1)</strong> man pages for a
discussion of the PCP debugging and tracing framework.</p>
</div>
<div class="section" id="debugging-information">
<h3><a class="toc-backref" href="#id50">2.7.2. Debugging Information</a><a class="headerlink" href="#debugging-information" title="Permalink to this headline">¶</a></h3>
<p>You can activate debugging options in PMCD and most other PCP tools with the <strong>-D</strong> command-line option. Supported options can be listed with the <strong>pmdbg</strong>
command; see the <strong>pmdbg(1)</strong> man page. Setting the debug options for PMCD in <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDOPTIONS_PATH}</span></code> might generate too much information to be useful,
especially if there are other clients and PMDAs connected to the PMCD process.</p>
<p>The PMCD debugging options can also be changed dynamically by storing a new value into the metric <strong>pmcd.control.debug</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># pmstore pmcd.control.debug 5
</pre></div>
</div>
<p>Most of the <strong>pcp_pmda</strong> library functions log additional information if the <strong>libpmda</strong> option is set within the PMDA; see the <strong>PMDA(3)</strong> man page. The command-line
argument <strong>-D</strong> is trapped by <strong>pmdaGetOptions</strong> to set the global debugging control options. Adding tests within the PMDA for the <strong>appl0, appl1</strong> and <strong>appl2</strong>
trace flags permits different levels of information to be logged to the PMDA’s log file.</p>
<p>All diagnostic, debugging, and tracing output from a PMDA should be written to the standard error stream.</p>
<p>Adding this segment of code to the <strong>simple_store</strong> metric causes a timestamped log message to be sent to the current log file whenever <strong>pmstore</strong> attempts to
change <strong>simple.numfetch</strong> and the PCP debugging options have the <strong>appl0</strong> option set as shown in <a class="reference internal" href="#example-2-36-simple-numfetch-in-the-simple-pmda">Example 2.36. simple.numfetch in the Simple PMDA</a>:</p>
<p id="example-2-36-simple-numfetch-in-the-simple-pmda"><strong>Example 2.36. simple.numfetch in the Simple PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>case 0: /* simple.numfetch */
     x
     val = vsp-&gt;vlist[0].value.lval;
     if (val &lt; 0) {
         sts = PM_ERR_SIGN;
         val = 0;
     }
     if (pmDebugOptions.appl0__) {
         pmNotifyErr(LOG_DEBUG,
               &quot;simple: %d stored into numfetch&quot;, val);
     }
     numfetch = val;
     break;
</pre></div>
</div>
<p>For a description of <strong>pmstore</strong>, see the <strong>pmstore(1)</strong> man page.</p>
</div>
<div class="section" id="dbpmda-debug-utility">
<h3><a class="toc-backref" href="#id51">2.7.3. dbpmda Debug Utility</a><a class="headerlink" href="#dbpmda-debug-utility" title="Permalink to this headline">¶</a></h3>
<p>The <strong>dbpmda</strong> utility provides a simple interface to the PDU communication protocol. It allows daemon and DSO PMDAs to be tested with most request types, while
the PMDA process may be monitored with a debugger, tracing utilities, and other diagnostic tools. The <strong>dbpmda(1)</strong> man page contains a sample session with the
<strong>simple</strong> PMDA.</p>
</div>
</div>
<div class="section" id="integration-of-a-pmda">
<h2><a class="toc-backref" href="#id52">2.8. Integration of a PMDA</a><a class="headerlink" href="#integration-of-a-pmda" title="Permalink to this headline">¶</a></h2>
<p>Several steps are required to install (or remove) a PMDA from a production PMCD environment without affecting the operation of other PMDAs or related visualization
and logging tools.</p>
<p>The PMDA typically would have its own directory below <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}</span></code> into which several files would be installed. In the description in Section 2.8.1,
“<a class="reference internal" href="#installing-a-pmda">Installing a PMDA</a>”, the PMDA of interest is assumed to be known by the name <strong>newbie</strong>, hence the PMDA directory would be <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/newbie</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any installation or removal of a PMDA involves updating files and directories that are typically well protected. Hence the procedures described in this
section must be executed as the superuser.</p>
</div>
<div class="section" id="installing-a-pmda">
<h3><a class="toc-backref" href="#id53">2.8.1. Installing a PMDA</a><a class="headerlink" href="#installing-a-pmda" title="Permalink to this headline">¶</a></h3>
<p>A PMDA is fully installed when these tasks are completed:</p>
<ul class="simple">
<li>Help text has been installed in a place where the PMDA can find it, usually in the PMDA directory <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/newbie</span></code>.</li>
<li>The name space has been updated in the <code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/pmns</span></code> directory.</li>
<li>The PMDA binary has been installed, usually in the directory <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/newbie</span></code>.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code> file has been updated.</li>
<li>The PMCD process has been restarted or notified (with a <strong>SIGHUP</strong> signal) that the new PMDA exists.</li>
</ul>
<p>The <strong>Makefile</strong> should include an <strong>install</strong> target to compile and link the PMDA (as a DSO, or a daemon or both) in the PMDA directory. The <strong>clobber</strong> target
should remove any files created as a by-product of the <strong>install</strong> target.</p>
<p>You may wish to use <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/simple/Makefile</span></code> as a template for constructing a new PMDA <strong>Makefile</strong>; changing the assignment of <strong>IAM</strong> from <strong>simple</strong>
to <strong>newbie</strong> would account for most of the required changes.</p>
<p>The <strong>Install</strong> script should make use of the generic procedures defined in the script <code class="docutils literal notranslate"><span class="pre">${PCP_SHARE_DIR}/lib/pmdaproc.sh</span></code>, and may be as straightforward as the
one used for the trivial PMDA, shown in <a class="reference internal" href="#example-2-37-install-script-for-the-trivial-pmda">Example 2.37. Install Script for the Trivial PMDA</a>:</p>
<p id="example-2-37-install-script-for-the-trivial-pmda"><strong>Example 2.37. Install Script for the Trivial PMDA</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. ${PCP_DIR}/etc/pcp.env
. ${PCP_SHARE_DIR}/lib/pmdaproc.sh

iam=trivial
pmdaSetup
pmdainstall
exit
</pre></div>
</div>
<p>The variables, shown in <a class="reference internal" href="#table-2-1-variables-to-control-behavior-of-generic-pmdaproc-sh-procedures">Table 2.1. Variables to Control Behavior of Generic pmdaproc.sh Procedures</a>, may be assigned values to modify the behavior of the
<strong>pmdaSetup</strong> and <strong>pmdainstall</strong> procedures from <code class="docutils literal notranslate"><span class="pre">${PCP_SHARE_DIR}/lib/pmdaproc.sh</span></code>.</p>
<p id="table-2-1-variables-to-control-behavior-of-generic-pmdaproc-sh-procedures"><strong>Table 2.1. Variables to Control Behavior of Generic pmdaproc.sh Procedures</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="60%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Shell Variable</strong></td>
<td><strong>Use</strong></td>
<td><strong>Default</strong></td>
</tr>
<tr class="row-even"><td><strong>$iam</strong></td>
<td>Name of the PMDA; assignment to this variable is mandatory.
Example: <strong>iam=newbie</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>$dso_opt</strong></td>
<td>Can this PMDA be installed as a DSO?</td>
<td><strong>false</strong></td>
</tr>
<tr class="row-even"><td><strong>$daemon_opt</strong></td>
<td>Can this PMDA be installed as a daemon?</td>
<td><strong>true</strong></td>
</tr>
<tr class="row-odd"><td><strong>$perl_opt</strong></td>
<td>Is this PMDA a perl script?</td>
<td><strong>false</strong></td>
</tr>
<tr class="row-even"><td><strong>$python_opt</strong></td>
<td>Is this PMDA a python script?</td>
<td><strong>false</strong></td>
</tr>
<tr class="row-odd"><td><strong>$pipe_opt</strong></td>
<td>If installed as a daemon PMDA, is the default IPC via pipes?</td>
<td><strong>true</strong></td>
</tr>
<tr class="row-even"><td><strong>$socket_opt</strong></td>
<td>If installed as a daemon PMDA, is the default IPC via an Internet socket?</td>
<td><strong>false</strong></td>
</tr>
<tr class="row-odd"><td><strong>$socket_inet_def</strong></td>
<td>If installed as a daemon PMDA, and the IPC method uses an Internet socket, the default port number.</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>$ipc_prot</strong></td>
<td>IPC style for PDU exchanges involving a daemon PMDA; <strong>binary</strong> or <strong>text</strong>.</td>
<td><strong>binary</strong></td>
</tr>
<tr class="row-odd"><td><strong>$check_delay</strong></td>
<td>Delay in seconds between installing PMDA and checking if metrics are available.</td>
<td><strong>3</strong></td>
</tr>
<tr class="row-even"><td><strong>$args</strong></td>
<td>Additional command-line arguments passed to a daemon PMDA.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>$pmns_source</strong></td>
<td>The name of the PMNS file (by default relative to the PMDA directory).</td>
<td><strong>pmns</strong></td>
</tr>
<tr class="row-even"><td><strong>$pmns_name</strong></td>
<td>First-level name for this PMDA’s metrics in the PMNS.</td>
<td><strong>$iam</strong></td>
</tr>
<tr class="row-odd"><td><strong>$help_source</strong></td>
<td>The name of the help file (by default relative to the PMDA directory).</td>
<td><strong>help</strong></td>
</tr>
<tr class="row-even"><td><strong>$pmda_name</strong></td>
<td>The name of the executable for a daemon PMDA.</td>
<td><strong>pmda$iam</strong></td>
</tr>
<tr class="row-odd"><td><strong>$dso_name</strong></td>
<td>The name of the shared library for a DSO PMDA.</td>
<td><strong>pmda$iam.$dso_suffix</strong></td>
</tr>
<tr class="row-even"><td><strong>$dso_entry</strong></td>
<td>The name of the initialization function for a DSO PMDA.</td>
<td><strong>${iam}_init</strong></td>
</tr>
<tr class="row-odd"><td><strong>$domain</strong></td>
<td>The numerical PMDA domain number (from <strong>domain.h</strong>).</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>$SYMDOM</strong></td>
<td>The symbolic name of the PMDA domain number (from <strong>domain.h</strong>).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>$status</strong></td>
<td>Exit status for the shell script</td>
<td><strong>0</strong></td>
</tr>
</tbody>
</table>
<p>In addition, the variable <strong>do_check</strong> will be set to reflect the intention to check the availability of the metrics once the PMDA is installed. By default this variable is <strong>true</strong>
however the command-line option <strong>-Q</strong> to <strong>Install</strong> may be used to set the variable to <strong>false</strong>.</p>
<p>Obviously, for anything but the most trivial PMDA, after calling the <strong>pmdaSetup</strong> procedure, the <strong>Install</strong> script should also prompt for any PMDA-specific parameters, which are
typically accumulated in the <em>args</em> variable and used by the <strong>pmdainstall</strong> procedure.</p>
<p>The detailed operation of the <strong>pmdainstall</strong> procedure involves the following tasks:</p>
<ul class="simple">
<li>Using default assignments, and interaction where ambiguity exists, determine the PMDA type (DSO or daemon) and the IPC parameters, if any.</li>
<li>Copy the <code class="docutils literal notranslate"><span class="pre">$pmns_source</span></code> file, replacing symbolic references to <strong>SYMDOM</strong> by the desired numeric domain number from <strong>domain</strong>.</li>
<li>Merge the PMDA’s name space into the PCP name space at the non-leaf node identified by <strong>$pmns_name</strong>.</li>
<li>If any <strong>pmchart</strong> views can be found (files with names ending in “.pmchart”), copy these to the standard directory (<code class="docutils literal notranslate"><span class="pre">${PCP_VAR_DIR}/config/pmchart</span></code>) with the “.pmchart” suffix removed.</li>
<li>Create new help files from <code class="docutils literal notranslate"><span class="pre">$help_source</span></code> after replacing symbolic references to <strong>SYMDOM</strong> by the desired numeric domain number from <strong>domain</strong>.</li>
<li>Terminate the old daemon PMDA, if any.</li>
<li>Use the <strong>Makefile</strong> to build the appropriate executables.</li>
<li>Add the PMDA specification to PMCD’s configuration file (<code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code>).</li>
<li>Notify PMCD. To minimize the impact on the services PMCD provides, sending a <strong>SIGHUP</strong> to PMCD forces it to reread the configuration file and start, restart, or remove any PMDAs that
have changed since the file was last read. However, if the newly installed PMDA must run using a different privilege level to PMCD then PMCD must be restarted. This is because PMCD runs
unprivileged after initially starting the PMDAs.</li>
<li>Check that the metrics from the new PMDA are available.</li>
</ul>
<p>There are some PMDA changes that may trick PMCD into thinking nothing has changed, and not restarting the PMDA. Most notable are changes to the PMDA executable. In these cases, you may
need to explicitly remove the PMDA as described in Section 2.8.2, “<a class="reference internal" href="#removing-a-pmda">Removing a PMDA</a>”, or more drastically, restart PMCD as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ${PCP_RC_DIR}/pcp start
</pre></div>
</div>
<p>The files <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/*/Install</span></code> provide a wealth of examples that may be used to construct a new PMDA <strong>Install</strong> script.</p>
</div>
<div class="section" id="removing-a-pmda">
<h3><a class="toc-backref" href="#id54">2.8.2. Removing a PMDA</a><a class="headerlink" href="#removing-a-pmda" title="Permalink to this headline">¶</a></h3>
<p>The simplest way to stop a PMDA from running, apart from killing the process, is to remove the entry from <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code> and signal PMCD (with <strong>SIGHUP</strong>) to reread its
configuration file. To completely remove a PMDA requires the reverse process of the installation, including an update of the Performance Metrics Name Space (PMNS).</p>
<p>This typically involves a <strong>Remove</strong> script in the PMDA directory that uses the same common procedures as the <strong>Install</strong> script described Section 2.8.1, “<a class="reference internal" href="#installing-a-pmda">Installing a PMDA</a>”.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}/*/Remove</span></code> files provide a wealth of examples that may be used to construct a new PMDA <strong>Remove</strong> script.</p>
</div>
<div class="section" id="configuring-pcp-tools">
<h3><a class="toc-backref" href="#id55">2.8.3. Configuring PCP Tools</a><a class="headerlink" href="#configuring-pcp-tools" title="Permalink to this headline">¶</a></h3>
<p>Most PCP tools have their own configuration file format for specifying which metrics to view or to log. By using canned configuration files that monitor key metrics of the new PMDA,
users can quickly see the performance of the target system, as characterized by key metrics in the new PMDA.</p>
<p>Any configuration files that are created should be kept with the PMDA and installed into the appropriate directories when the PMDA is installed.</p>
<p>As with all PCP customization, some of the most valuable tools can be created by defining views, scenes, and control-panel layouts that combine related performance metrics from multiple
PMDAs or multiple hosts.</p>
<p>Metrics suitable for on-going logging can be specified in templated <strong>pmlogger</strong> configuration files for <strong>pmlogconf</strong> to automatically add to the <strong>pmlogger_daily</strong> recorded set; see the
<strong>pmlogger(1), pmlogconf(1)</strong> and <strong>pmlogger_daily(1)</strong> man pages.</p>
<p>Parameterized alarm configurations can be created using the <strong>pmieconf</strong> facilities; see the <strong>pmieconf(1)</strong> and <strong>pmie(1)</strong> man pages.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="PMAPI.html" class="btn btn-neutral float-right" title="3. PMAPI–The Performance Metrics API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ProgrammingPcp.html" class="btn btn-neutral float-left" title="1. Programming Performance Co-Pilot" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Performance Co-Pilot

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>