

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. PMAPI–The Performance Metrics API &mdash; pcp  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Instrumenting Applications" href="InstrumentingApplications.html" />
    <link rel="prev" title="2. Writing A PMDA" href="WritingPMDA.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> pcp
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/AboutUAGGuide.html">About User’s and Administrator’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="AboutPGGuide.html">About Programmer’s Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User's and Administrator's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/IntroductionToPcp.html">1. Introduction to PCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/InstallingAndConfiguringPcp.html">2. Installing and Configuring Performance Co-Pilot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CommonConventionsAndArguments.html">3. Common Conventions and Arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/MonitoringSystemPerformance.html">4. Monitoring System Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PerformanceMetricsInferenceEngine.html">5. Performance Metrics Inference Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/ArchiveLogging.html">6. Archive Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PcpDeploymentStrategies.html">7. Performance Co-Pilot Deployment Strategies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CustomizingAndExtendingPcpServices.html">8. Customizing and Extending PCP Services</a></li>
</ul>
<p class="caption"><span class="caption-text">Programmer's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ProgrammingPcp.html">1. Programming Performance Co-Pilot</a></li>
<li class="toctree-l1"><a class="reference internal" href="WritingPMDA.html">2. Writing A PMDA</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. PMAPI–The Performance Metrics API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#naming-and-identifying-performance-metrics">3.1. Naming and Identifying Performance Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-metric-instances">3.2. Performance Metric Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="#current-pmapi-context">3.3. Current PMAPI Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-metric-descriptions">3.4. Performance Metric Descriptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-metrics-values">3.5. Performance Metrics Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-event-metrics">3.6. Performance Event Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#event-monitor-considerations">3.6.1. Event Monitor Considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#event-collector-considerations">3.6.2. Event Collector Considerations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pmapi-programming-style-and-interaction">3.7. PMAPI Programming Style and Interaction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-length-argument-and-results-lists">3.7.1. Variable Length Argument and Results Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-specific-issues">3.7.2. Python Specific Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-error-handling">3.7.3. PMAPI Error Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pmapi-procedural-interface">3.8. PMAPI Procedural Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-name-space-services">3.8.1. PMAPI Name Space Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmgetchildren-function">3.8.1.1. pmGetChildren Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmgetchildrenstatus-function">3.8.1.2. pmGetChildrenStatus Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmgetpmnslocation-function">3.8.1.3. pmGetPMNSLocation Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmloadnamespace-function">3.8.1.4. pmLoadNameSpace Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookupname-function">3.8.1.5. pmLookupName Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnameall-function">3.8.1.6. pmNameAll Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnameid-function">3.8.1.7. pmNameID Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmtraversepmns-function">3.8.1.8. pmTraversePMNS Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmunloadnamespace-function">3.8.1.9. pmUnloadNameSpace Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-metrics-description-services">3.8.2. PMAPI Metrics Description Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmlookupdesc-function">3.8.2.1. pmLookupDesc Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookupindomtext-function">3.8.2.2. pmLookupInDomText Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookuptext-function">3.8.2.3. pmLookupText Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookuplabels-function">3.8.2.4. pmLookupLabels Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-instance-domain-services">3.8.3. PMAPI Instance Domain Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmgetindom-function">3.8.3.1. pmGetInDom Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookupindom-function">3.8.3.2. pmLookupInDom Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnameindom-function">3.8.3.3. pmNameInDom Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-context-services">3.8.4. PMAPI Context Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmnewcontext-function">3.8.4.1. pmNewContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmdestroycontext-function">3.8.4.2. pmDestroyContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmdupcontext-function">3.8.4.3. pmDupContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmusecontext-function">3.8.4.4. pmUseContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmwhichcontext-function">3.8.4.5. pmWhichContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmaddprofile-function">3.8.4.6. pmAddProfile Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmdelprofile-function">3.8.4.7. pmDelProfile Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmsetmode-function">3.8.4.8. pmSetMode Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmreconnectcontext-function">3.8.4.9. pmReconnectContext Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmgetcontexthostname-function">3.8.4.10. pmGetContextHostName Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-timezone-services">3.8.5. PMAPI Timezone Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmnewcontextzone-function">3.8.5.1. pmNewContextZone Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnewzone-function">3.8.5.2. pmNewZone Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmusezone-function">3.8.5.3. pmUseZone Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmwhichzone-function">3.8.5.4. pmWhichZone Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-metrics-services">3.8.6. PMAPI Metrics Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmfetch-function">3.8.6.1. pmFetch Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmfreeresult-function">3.8.6.2. pmFreeResult Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmstore-function">3.8.6.3. pmStore Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-fetchgroup-services">3.8.7. PMAPI Fetchgroup Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fetchgroup-setup">3.8.7.1. Fetchgroup setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fetchgroup-operation">3.8.7.2. Fetchgroup operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fetchgroup-shutdown">3.8.7.3. Fetchgroup shutdown</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-record-mode-services">3.8.8. PMAPI Record-Mode Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmrecordaddhost-function">3.8.8.1. pmRecordAddHost Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmrecordcontrol-function">3.8.8.2. pmRecordControl Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmrecordsetup-function">3.8.8.3. pmRecordSetup Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-archive-specific-services">3.8.9. PMAPI Archive-Specific Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmgetarchivelabel-function">3.8.9.1. pmGetArchiveLabel Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmgetarchiveend-function">3.8.9.2. pmGetArchiveEnd Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmgetindomarchive-function">3.8.9.3. pmGetInDomArchive Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmlookupindomarchive-function">3.8.9.4. pmLookupInDomArchive Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnameindomarchive-function">3.8.9.5. pmNameInDomArchive Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmfetcharchive-function">3.8.9.6. pmFetchArchive Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-time-control-services">3.8.10. PMAPI Time Control Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pmapi-ancillary-support-services">3.8.11. PMAPI Ancillary Support Services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pmgetconfig-function">3.8.11.1. pmGetConfig Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmerrstr-function">3.8.11.2. pmErrStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmextractvalue-function">3.8.11.3. pmExtractValue Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmconvscale-function">3.8.11.4. pmConvScale Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmunitsstr-function">3.8.11.5. pmUnitsStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmidstr-function">3.8.11.6. pmIDStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmindomstr-function">3.8.11.7. pmInDomStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmtypestr-function">3.8.11.8. pmTypeStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmatomstr-function">3.8.11.9. ⁠pmAtomStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmnumberstr-function">3.8.11.10. pmNumberStr Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmprintvalue-function">3.8.11.11. pmPrintValue Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmflush-function">3.8.11.12. pmflush Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmprintf-function">3.8.11.13. pmprintf Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmsortinstances-function">3.8.11.14. pmSortInstances Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmparseinterval-function">3.8.11.15. pmParseInterval Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pmparsemetricspec-function">3.8.11.16. pmParseMetricSpec Function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pmapi-programming-issues-and-examples">3.9. PMAPI Programming Issues and Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#symbolic-association-between-a-metric-s-name-and-value">3.9.1. Symbolic Association between a Metric’s Name and Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-new-metrics">3.9.2. Initializing New Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterative-processing-of-values">3.9.3. Iterative Processing of Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accommodating-program-evolution">3.9.4. Accommodating Program Evolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handling-pmapi-errors">3.9.5. Handling PMAPI Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-and-linking-pmapi-applications">3.9.6. Compiling and Linking PMAPI Applications</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="InstrumentingApplications.html">4. Instrumenting Applications</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>3. PMAPI–The Performance Metrics API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/PG/PMAPI.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pmapi-the-performance-metrics-api">
<span id="pmapi"></span><h1><a class="toc-backref" href="#id4">3. PMAPI–The Performance Metrics API</a><a class="headerlink" href="#pmapi-the-performance-metrics-api" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the Performance Metrics Application Programming Interface (PMAPI) provided with Performance Co-Pilot (PCP).</p>
<p>The PMAPI is a set of functions and data structure definitions that allow client applications to access performance data from one or more Performance Metrics
Collection Daemons (PMCDs) or from PCP archive logs. The PCP utilities are all written using the PMAPI.</p>
<p>The most common use of PCP includes running performance monitoring utilities on a workstation (the monitoring system) while performance data is retrieved from one
or more remote collector systems by a number of PCP processes. These processes execute on both the monitoring system and the collector systems. The collector
systems are typically servers, and are the targets for the performance investigations.</p>
<p>In the development of the PMAPI the most important question has been, “How easily and quickly will this API enable the user to build new performance tools, or
exploit existing tools for newly available performance metrics?” The PMAPI and the standard tools that use the PMAPI have enjoyed a symbiotic evolution throughout
the development of PCP.</p>
<p>It will be convenient to differentiate between code that uses the PMAPI and code that implements the services of the PMAPI. The former will be termed “above the
PMAPI” and the latter “below the PMAPI.”</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#pmapi-the-performance-metrics-api" id="id4">PMAPI–The Performance Metrics API</a><ul>
<li><a class="reference internal" href="#naming-and-identifying-performance-metrics" id="id5">Naming and Identifying Performance Metrics</a></li>
<li><a class="reference internal" href="#performance-metric-instances" id="id6">Performance Metric Instances</a></li>
<li><a class="reference internal" href="#current-pmapi-context" id="id7">Current PMAPI Context</a></li>
<li><a class="reference internal" href="#performance-metric-descriptions" id="id8">Performance Metric Descriptions</a></li>
<li><a class="reference internal" href="#performance-metrics-values" id="id9">Performance Metrics Values</a></li>
<li><a class="reference internal" href="#performance-event-metrics" id="id10">Performance Event Metrics</a><ul>
<li><a class="reference internal" href="#event-monitor-considerations" id="id11">Event Monitor Considerations</a></li>
<li><a class="reference internal" href="#event-collector-considerations" id="id12">Event Collector Considerations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-programming-style-and-interaction" id="id13">PMAPI Programming Style and Interaction</a><ul>
<li><a class="reference internal" href="#variable-length-argument-and-results-lists" id="id14">Variable Length Argument and Results Lists</a></li>
<li><a class="reference internal" href="#python-specific-issues" id="id15">Python Specific Issues</a></li>
<li><a class="reference internal" href="#pmapi-error-handling" id="id16">PMAPI Error Handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-procedural-interface" id="id17">PMAPI Procedural Interface</a><ul>
<li><a class="reference internal" href="#pmapi-name-space-services" id="id18">PMAPI Name Space Services</a><ul>
<li><a class="reference internal" href="#pmgetchildren-function" id="id19">pmGetChildren Function</a></li>
<li><a class="reference internal" href="#pmgetchildrenstatus-function" id="id20">pmGetChildrenStatus Function</a></li>
<li><a class="reference internal" href="#pmgetpmnslocation-function" id="id21">pmGetPMNSLocation Function</a></li>
<li><a class="reference internal" href="#pmloadnamespace-function" id="id22">pmLoadNameSpace Function</a></li>
<li><a class="reference internal" href="#pmlookupname-function" id="id23">pmLookupName Function</a></li>
<li><a class="reference internal" href="#pmnameall-function" id="id24">pmNameAll Function</a></li>
<li><a class="reference internal" href="#pmnameid-function" id="id25">pmNameID Function</a></li>
<li><a class="reference internal" href="#pmtraversepmns-function" id="id26">pmTraversePMNS Function</a></li>
<li><a class="reference internal" href="#pmunloadnamespace-function" id="id27">pmUnloadNameSpace Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-metrics-description-services" id="id28">PMAPI Metrics Description Services</a><ul>
<li><a class="reference internal" href="#pmlookupdesc-function" id="id29">pmLookupDesc Function</a></li>
<li><a class="reference internal" href="#pmlookupindomtext-function" id="id30">pmLookupInDomText Function</a></li>
<li><a class="reference internal" href="#pmlookuptext-function" id="id31">pmLookupText Function</a></li>
<li><a class="reference internal" href="#pmlookuplabels-function" id="id32">pmLookupLabels Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-instance-domain-services" id="id33">PMAPI Instance Domain Services</a><ul>
<li><a class="reference internal" href="#pmgetindom-function" id="id34">pmGetInDom Function</a></li>
<li><a class="reference internal" href="#pmlookupindom-function" id="id35">pmLookupInDom Function</a></li>
<li><a class="reference internal" href="#pmnameindom-function" id="id36">pmNameInDom Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-context-services" id="id37">PMAPI Context Services</a><ul>
<li><a class="reference internal" href="#pmnewcontext-function" id="id38">pmNewContext Function</a></li>
<li><a class="reference internal" href="#pmdestroycontext-function" id="id39">pmDestroyContext Function</a></li>
<li><a class="reference internal" href="#pmdupcontext-function" id="id40">pmDupContext Function</a></li>
<li><a class="reference internal" href="#pmusecontext-function" id="id41">pmUseContext Function</a></li>
<li><a class="reference internal" href="#pmwhichcontext-function" id="id42">pmWhichContext Function</a></li>
<li><a class="reference internal" href="#pmaddprofile-function" id="id43">pmAddProfile Function</a></li>
<li><a class="reference internal" href="#pmdelprofile-function" id="id44">pmDelProfile Function</a></li>
<li><a class="reference internal" href="#pmsetmode-function" id="id45">pmSetMode Function</a></li>
<li><a class="reference internal" href="#pmreconnectcontext-function" id="id46">pmReconnectContext Function</a></li>
<li><a class="reference internal" href="#pmgetcontexthostname-function" id="id47">pmGetContextHostName Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-timezone-services" id="id48">PMAPI Timezone Services</a><ul>
<li><a class="reference internal" href="#pmnewcontextzone-function" id="id49">pmNewContextZone Function</a></li>
<li><a class="reference internal" href="#pmnewzone-function" id="id50">pmNewZone Function</a></li>
<li><a class="reference internal" href="#pmusezone-function" id="id51">pmUseZone Function</a></li>
<li><a class="reference internal" href="#pmwhichzone-function" id="id52">pmWhichZone Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-metrics-services" id="id53">PMAPI Metrics Services</a><ul>
<li><a class="reference internal" href="#pmfetch-function" id="id54">pmFetch Function</a></li>
<li><a class="reference internal" href="#pmfreeresult-function" id="id55">pmFreeResult Function</a></li>
<li><a class="reference internal" href="#pmstore-function" id="id56">pmStore Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-fetchgroup-services" id="id57">PMAPI Fetchgroup Services</a><ul>
<li><a class="reference internal" href="#fetchgroup-setup" id="id58">Fetchgroup setup</a></li>
<li><a class="reference internal" href="#fetchgroup-operation" id="id59">Fetchgroup operation</a></li>
<li><a class="reference internal" href="#fetchgroup-shutdown" id="id60">Fetchgroup shutdown</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-record-mode-services" id="id61">PMAPI Record-Mode Services</a><ul>
<li><a class="reference internal" href="#pmrecordaddhost-function" id="id62">pmRecordAddHost Function</a></li>
<li><a class="reference internal" href="#pmrecordcontrol-function" id="id63">pmRecordControl Function</a></li>
<li><a class="reference internal" href="#pmrecordsetup-function" id="id64">pmRecordSetup Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-archive-specific-services" id="id65">PMAPI Archive-Specific Services</a><ul>
<li><a class="reference internal" href="#pmgetarchivelabel-function" id="id66">pmGetArchiveLabel Function</a></li>
<li><a class="reference internal" href="#pmgetarchiveend-function" id="id67">pmGetArchiveEnd Function</a></li>
<li><a class="reference internal" href="#pmgetindomarchive-function" id="id68">pmGetInDomArchive Function</a></li>
<li><a class="reference internal" href="#pmlookupindomarchive-function" id="id69">pmLookupInDomArchive Function</a></li>
<li><a class="reference internal" href="#pmnameindomarchive-function" id="id70">pmNameInDomArchive Function</a></li>
<li><a class="reference internal" href="#pmfetcharchive-function" id="id71">pmFetchArchive Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-time-control-services" id="id72">PMAPI Time Control Services</a></li>
<li><a class="reference internal" href="#pmapi-ancillary-support-services" id="id73">PMAPI Ancillary Support Services</a><ul>
<li><a class="reference internal" href="#pmgetconfig-function" id="id74">pmGetConfig Function</a></li>
<li><a class="reference internal" href="#pmerrstr-function" id="id75">pmErrStr Function</a></li>
<li><a class="reference internal" href="#pmextractvalue-function" id="id76">pmExtractValue Function</a></li>
<li><a class="reference internal" href="#pmconvscale-function" id="id77">pmConvScale Function</a></li>
<li><a class="reference internal" href="#pmunitsstr-function" id="id78">pmUnitsStr Function</a></li>
<li><a class="reference internal" href="#pmidstr-function" id="id79">pmIDStr Function</a></li>
<li><a class="reference internal" href="#pmindomstr-function" id="id80">pmInDomStr Function</a></li>
<li><a class="reference internal" href="#pmtypestr-function" id="id81">pmTypeStr Function</a></li>
<li><a class="reference internal" href="#pmatomstr-function" id="id82">⁠pmAtomStr Function</a></li>
<li><a class="reference internal" href="#pmnumberstr-function" id="id83">pmNumberStr Function</a></li>
<li><a class="reference internal" href="#pmprintvalue-function" id="id84">pmPrintValue Function</a></li>
<li><a class="reference internal" href="#pmflush-function" id="id85">pmflush Function</a></li>
<li><a class="reference internal" href="#pmprintf-function" id="id86">pmprintf Function</a></li>
<li><a class="reference internal" href="#pmsortinstances-function" id="id87">pmSortInstances Function</a></li>
<li><a class="reference internal" href="#pmparseinterval-function" id="id88">pmParseInterval Function</a></li>
<li><a class="reference internal" href="#pmparsemetricspec-function" id="id89">pmParseMetricSpec Function</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#pmapi-programming-issues-and-examples" id="id90">PMAPI Programming Issues and Examples</a><ul>
<li><a class="reference internal" href="#symbolic-association-between-a-metric-s-name-and-value" id="id91">Symbolic Association between a Metric’s Name and Value</a></li>
<li><a class="reference internal" href="#initializing-new-metrics" id="id92">Initializing New Metrics</a></li>
<li><a class="reference internal" href="#iterative-processing-of-values" id="id93">Iterative Processing of Values</a></li>
<li><a class="reference internal" href="#accommodating-program-evolution" id="id94">Accommodating Program Evolution</a></li>
<li><a class="reference internal" href="#handling-pmapi-errors" id="id95">Handling PMAPI Errors</a></li>
<li><a class="reference internal" href="#compiling-and-linking-pmapi-applications" id="id96">Compiling and Linking PMAPI Applications</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="naming-and-identifying-performance-metrics">
<h2><a class="toc-backref" href="#id5">3.1. Naming and Identifying Performance Metrics</a><a class="headerlink" href="#naming-and-identifying-performance-metrics" title="Permalink to this headline">¶</a></h2>
<p>Across all of the supported performance metric domains, there are a large number of performance metrics. Each metric has its own description, format, and semantics.
PCP presents a uniform interface to these metrics above the PMAPI, independent of the source of the underlying metric data. For example, the performance metric
<strong>hinv.physmem</strong> has a single 32-bit unsigned integer value, representing the number of megabytes of physical memory in the system, while the performance metric
<strong>disk.dev.total</strong> has one 32-bit unsigned integer value per disk spindle, representing the cumulative count of I/O operations involving each associated disk
spindle. These concepts are described in greater detail in Section 2.3, “<a class="reference internal" href="WritingPMDA.html#domains-metrics-instances-and-labels"><span class="std std-ref">Domains, Metrics, Instances and Labels</span></a>”.</p>
<p>For brevity and efficiency, internally PCP avoids using names for performance metrics, and instead uses an identification scheme that unambiguously associates a
single integer with each known performance metric. This integer is known as a Performance Metric Identifier, or PMID. For functions using the PMAPI, a PMID is
defined and manipulated with the typedef <strong>pmID</strong>.</p>
<p>Below the PMAPI, the integer value of the PMID has an internal structure that reflects the details of the PMCD and PMDA architecture, as described in
Section 2.3.3, “<a class="reference internal" href="WritingPMDA.html#metrics"><span class="std std-ref">Metrics</span></a>”.</p>
<p>Above the PMAPI, a Performance Metrics Name Space (PMNS) is used to provide a hierarchic classification of external metric names, and a one-to-one mapping of
external names to internal PMIDs. A more detailed description of the PMNS can be found in the <em>Performance Co-Pilot User’s and Administrator’s Guide</em>.</p>
<p>The default PMNS comes from the performance metrics source, either a PMCD process or a PCP archive. This PMNS always reflects the available metrics from the
performance metrics source.</p>
</div>
<div class="section" id="performance-metric-instances">
<h2><a class="toc-backref" href="#id6">3.2. Performance Metric Instances</a><a class="headerlink" href="#performance-metric-instances" title="Permalink to this headline">¶</a></h2>
<p>When performance metric values are returned across the PMAPI to a requesting application, there may be more than one value for a particular metric; for example,
independent counts for each CPU, or each process, or each disk, or each system call type, and so on. This multiplicity of values is not enumerated in the Name
Space, but rather when performance metrics are delivered across the PMAPI.</p>
<p>The notion of <strong>metric instances</strong> is really a number of related concepts, as follows:</p>
<ul class="simple">
<li>A particular performance metric may have a set of associated values or instances.</li>
<li>The instances are differentiated by an instance identifier.</li>
<li>An instance identifier has an internal encoding (an integer value) and an external encoding (a corresponding external name or label).</li>
<li>The set of all possible instance identifiers associated with a performance metric on a particular host constitutes an <em>instance domain</em>.</li>
<li>Several performance metrics may share the same instance domain.</li>
</ul>
<p>Consider <a class="reference internal" href="#example-3-1-metrics-sharing-the-same-instance-domain">Example 3.1. Metrics Sharing the Same Instance Domain</a>:</p>
<p id="example-3-1-metrics-sharing-the-same-instance-domain"><strong>Example 3.1. Metrics Sharing the Same Instance Domain</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ pminfo -f filesys.free

filesys.free
   inst [1 or “/dev/disk0”] value 1803
   inst [2 or “/dev/disk1”] value 22140
   inst [3 or “/dev/disk2”] value 157938
</pre></div>
</div>
<p>The metric <strong>filesys.free</strong> has three values, currently 1803, 22140, and 157938. These values are respectively associated with the instances identified by the
internal identifiers 1, 2 and 3, and the external identifiers <strong>/dev/disk0, /dev/disk1</strong>, and <strong>/dev/disk2</strong>. These instances form an instance domain that is shared
by the performance metrics <strong>filesys.capacity, filesys.used, filesys.free, filesys.mountdir</strong>, and so on.</p>
<p>Each performance metric is associated with an instance domain, while each instance domain may be associated with many performance metrics. Each instance domain is
identified by a unique value, as defined by the following <strong>typedef</strong> declaration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef unsigned long pmInDom;
</pre></div>
</div>
<p>The special instance domain <strong>PM_INDOM_NULL</strong> is reserved to indicate that the metric has a single value (a singular instance domain). For example, the performance
metric <strong>mem.freemem</strong> always has exactly one value. Note that this is semantically different to a performance metric like <strong>kernel.percpu.cpu.sys</strong> that has a
non-singular instance domain, but may have only one value available; for example, on a system with a single processor.</p>
<p>In the results returned above the PMAPI, each individual instance within an instance domain is identified by an internal integer instance identifier. The special
instance identifier <strong>PM_IN_NULL</strong> is reserved for the single value in a singular instance domain. Performance metric values are delivered across the PMAPI as a
set of instance identifier and value pairs.</p>
<p>The instance domain of a metric may change with time. For example, a machine may be shut down, have several disks added, and be rebooted. All performance metrics
associated with the instance domain of disk devices would contain additional values after the reboot. The difficult issue of transient performance metrics means
that repeated requests for the same PMID may return different numbers of values, or some changes in the particular instance identifiers returned. This means
applications need to be aware that metric instantiation is guaranteed to be valid only at the time of collection.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some instance domains are more dynamic than others. For example, consider the instance domains behind the performance metrics <strong>proc.memory.rss</strong>
(one instance per process), <strong>swap.free</strong> (one instance per swap partition) and <strong>kernel.percpu.cpu.intr</strong> (one instance per CPU).</p>
</div>
</div>
<div class="section" id="current-pmapi-context">
<h2><a class="toc-backref" href="#id7">3.3. Current PMAPI Context</a><a class="headerlink" href="#current-pmapi-context" title="Permalink to this headline">¶</a></h2>
<p>When performance metrics are retrieved across the PMAPI, they are delivered in the context of a particular source of metrics, a point in time, and a profile of
desired instances. This means that the application making the request has already negotiated across the PMAPI to establish the context in which the request should
be executed.</p>
<p>A metric’s source may be the current performance data from a particular host (a live or real-time source), or a set of archive logs of performance data collected
by <strong>pmlogger</strong> at some remote host or earlier time (a retrospective or archive source). The metric’s source is specified when the PMAPI context is created by
calling the <strong>pmNewContext</strong> function. This function returns an opaque handle which can be used to identify the context.</p>
<p>The collection time for a performance metric is always the current time of day for a real-time source, or current position for an archive source. For archives,
the collection time may be set to an arbitrary time within the bounds of the set of archive logs by calling the <strong>pmSetMode</strong> function.</p>
<p>The last component of a PMAPI context is an instance profile that may be used to control which particular instances from an instance domain should be retrieved.
When a new PMAPI context is created, the initial state expresses an interest in all possible instances, to be collected at the current time. The instance profile
can be manipulated using the <strong>pmAddProfile</strong> and <strong>pmDelProfile</strong> functions.</p>
<p>The current context can be changed by passing a context handle to <strong>pmUseContext</strong>. If a live context connection fails, the <strong>pmReconnectContext</strong> function can be
used to attempt to reconnect it.</p>
</div>
<div class="section" id="performance-metric-descriptions">
<h2><a class="toc-backref" href="#id8">3.4. Performance Metric Descriptions</a><a class="headerlink" href="#performance-metric-descriptions" title="Permalink to this headline">¶</a></h2>
<p>For each defined performance metric, there exists metadata describing it.</p>
<ul class="simple">
<li>A performance metric description (<strong>pmDesc</strong> structure) that describes the format and semantics of the performance metric.</li>
<li>Help text associated with the metric and any associated instance domain.</li>
<li>Performance metric labels (name:value pairs in <strong>pmLabelSet</strong> structures) associated with the metric and any associated instances.</li>
</ul>
<p>The <strong>pmDesc</strong> structure, in <a class="reference internal" href="#example-3-2-pmdesc-structure">Example 3.2. pmDesc Structure</a>, provides all of the information required to interpret and manipulate a performance metric through
the PMAPI. It has the following declaration:</p>
<p id="example-3-2-pmdesc-structure"><strong>Example 3.2. pmDesc Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Performance Metric Descriptor */
typedef struct {
    pmID    pmid;   /* unique identifier */
    int     type;   /* base data type (see below) */
    pmInDom indom;  /* instance domain */
    int     sem;    /* semantics of value (see below) */
    pmUnits units;  /* dimension and units (see below) */
} pmDesc;
</pre></div>
</div>
<p>The <strong>type</strong> field in the <strong>pmDesc</strong> structure describes various encodings of a metric’s value. Its value will be one of the following constants:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* pmDesc.type - data type of metric values */
#define PM_TYPE_NOSUPPORT -1   /* not in this version */
#define PM_TYPE_32        0    /* 32-bit signed integer */
#define PM_TYPE_U32       1    /* 32-bit unsigned integer */
#define PM_TYPE_64        2    /* 64-bit signed integer */
#define PM_TYPE_U64       3    /* 64-bit unsigned integer */
#define PM_TYPE_FLOAT     4    /* 32-bit floating point */
#define PM_TYPE_DOUBLE    5    /* 64-bit floating point */
#define PM_TYPE_STRING    6    /* array of char */
#define PM_TYPE_AGGREGATE 7    /* arbitrary binary data */
#define PM_TYPE_AGGREGATE_STATIC 8 /* static pointer to aggregate */
#define PM_TYPE_EVENT     9    /* packed pmEventArray */
#define PM_TYPE_UNKNOWN   255  /* used in pmValueBlock not pmDesc */
</pre></div>
</div>
<p>By convention <strong>PM_TYPE_STRING</strong> is interpreted as a classic C-style null byte terminated string.</p>
<p>Event records are encoded as a packed array of strongly-typed, well-defined records within a <strong>pmResult</strong> structure, using a container metric with a value of type
<strong>PM_TYPE_EVENT</strong>.</p>
<p>If the value of a performance metric is of type <strong>PM_TYPE_STRING, PM_TYPE_AGGREGATE, PM_TYPE_AGGREGATE_STATIC</strong>, or <strong>PM_TYPE_EVENT</strong>, the interpretation of that
value is unknown to many PCP components. In the case of the aggregate types, the application using the value and the Performance Metrics Domain Agent (PMDA)
providing the value must have some common understanding about how the value is structured and interpreted. Strings can be manipulated using the standard C libraries.
Event records contain timestamps, event flags and event parameters, and the PMAPI provides support for unpacking an event record - see the <strong>pmUnpackEventRecords(3)</strong>
man page for details. Further discussion on event metrics and event records can be found in Section 3.6, “<a class="reference internal" href="#performance-event-metrics">Performance Event Metrics</a>”.</p>
<p><strong>PM_TYPE_NOSUPPORT</strong> indicates that the PCP collection framework knows about the metric, but the corresponding service or application is either not configured or
is at a revision level that does not provide support for this performance metric.</p>
<p>The semantics of the performance metric is described by the <strong>sem</strong> field of a <strong>pmDesc</strong> structure and uses the following constants:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* pmDesc.sem - semantics of metric values */
#define PM_SEM_COUNTER  1  /* cumulative count, monotonic increasing */
#define PM_SEM_INSTANT  3  /* instantaneous value continuous domain */
#define PM_SEM_DISCRETE 4  /* instantaneous value discrete domain */
</pre></div>
</div>
<p>Each value for a performance metric is assumed to be drawn from a set of values that can be described in terms of their dimensionality and scale by a compact
encoding, as follows:</p>
<ul class="simple">
<li>The dimensionality is defined by a power, or index, in each of three orthogonal dimensions: Space, Time, and Count (dimensionless). For example, I/O throughput
is Space1.Time-1, while the running total of system calls is Count1, memory allocation is Space1, and average service time per event is Time1.Count-1.</li>
<li>In each dimension, a number of common scale values are defined that may be used to better encode ranges that might otherwise exhaust the precision of a 32-bit
value. For example, a metric with dimension Space1.Time-1 may have values encoded using the scale megabytes per second.</li>
</ul>
<p>This information is encoded in the <strong>pmUnits</strong> data structure, shown in <a class="reference internal" href="#example-3-3-pmunits-and-pmdesc-structures">Example 3.3. pmUnits and pmDesc Structures</a>. It is embedded in the pmDesc structure :</p>
<p>The structures are as follows:</p>
<p id="example-3-3-pmunits-and-pmdesc-structures"><strong>Example 3.3. pmUnits and pmDesc Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Encoding for the units (dimensions and
 * scale) for Performance Metric Values
 *
 * For example, a pmUnits struct of
 * { 1, -1, 0, PM_SPACE_MBYTE, PM_TIME_SEC, 0 }
 * represents Mbytes/sec, while
 * { 0, 1, -1, 0, PM_TIME_HOUR, 6 }
 * represents hours/million-events
 */
typedef struct {
    int pad:8;
    int scaleCount:4; /* one of PM_COUNT_* below */
    int scaleTime:4;  /* one of PM_TIME_* below */
    int scaleSpace:4; /* one of PM_SPACE_* below */
    int dimCount:4;   /* event dimension */
    int dimTime:4;    /* time dimension */
    int dimSpace:4;   /* space dimension
} pmUnits;   /* dimensional units and scale of value */
/* pmUnits.scaleSpace */
#define PM_SPACE_BYTE 0  /* bytes */
#define PM_SPACE_KBYTE 1 /* kibibytes (1024) */
#define PM_SPACE_MBYTE 2 /* mebibytes (1024^2) */
#define PM_SPACE_GBYTE 3 /* gibibytes (1024^3) */
#define PM_SPACE_TBYTE 4 /* tebibytes (1024^4) */
#define PM_SPACE_PBYTE 5 /* pebibytes (1024^5) */
#define PM_SPACE_EBYTE 6 /* exbibytes (1024^6) */
#define PM_SPACE_ZBYTE 7 /* zebibytes (1024^7) */
#define PM_SPACE_YBYTE 8 /* yobibytes (1024^8) */
/* pmUnits.scaleTime */
#define PM_TIME_NSEC 0   /* nanoseconds */
#define PM_TIME_USEC 1   /* microseconds */
#define PM_TIME_MSEC 2   /* milliseconds */
#define PM_TIME_SEC 3    /* seconds */
#define PM_TIME_MIN 4    /* minutes */
#define PM_TIME_HOUR 5   /* hours */
/*
 * pmUnits.scaleCount (e.g. count events, syscalls,
 * interrupts, etc.) -- these are simply powers of 10,
 * and not enumerated here.
 * e.g. 6 for 10^6, or -3 for 10^-3
 */
#define PM_COUNT_ONE 0 /* 1 */
</pre></div>
</div>
<p>Metric and instance domain help text are simple ASCII strings. As a result, there are no special data structures associated with them. There are two forms of help
text available for each metric and instance domain, however - one-line and long form.</p>
<p><strong>Example 3.4. Help Text Flags</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define PM_TEXT_ONELINE 1
#define PM_TEXT_HELP    2
</pre></div>
</div>
<p>Labels are stored and communicated within PCP using JSONB formatted strings in the <strong>json</strong> field of a <strong>pmLabelSet</strong> structure. This format is a restricted form
of JSON suitable for indexing and other operations. In JSONB form, insignificant whitespace is discarded, and order of label names is not preserved. Within the
PMCS, however, a lexicographically sorted key space is always maintained. Duplicate label names are not permitted. The label with highest precedence in the label
hierarchy (context level labels, domain level labels, and so on) is the only one presented.</p>
<p><strong>Example 3.5. pmLabel and pmLabelSet Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    uint     name : 16;      /* label name offset in JSONB string */
    uint     namelen : 8;    /* length of name excluding the null */
    uint     flags : 8;      /* information about this label */
    uint     value : 16;     /* offset of the label value */
    uint     valuelen : 16;  /* length of value in bytes */
} pmLabel;

/* flags identifying label hierarchy classes. */
#define PM_LABEL_CONTEXT        (1&lt;&lt;0)
#define PM_LABEL_DOMAIN         (1&lt;&lt;1)
#define PM_LABEL_INDOM          (1&lt;&lt;2)
#define PM_LABEL_CLUSTER        (1&lt;&lt;3)
#define PM_LABEL_ITEM           (1&lt;&lt;4)
#define PM_LABEL_INSTANCES      (1&lt;&lt;5)
/* flag identifying extrinsic labels. */
#define PM_LABEL_OPTIONAL       (1&lt;&lt;7)

typedef struct {
    uint     inst;          /* PM_IN_NULL or the instance ID */
    int      nlabels;       /* count of labels or error code */
    char     *json;         /* JSONB formatted labels string */
    uint     jsonlen : 16;  /* JSON string length byte count */
    uint     padding : 16;  /* zero, reserved for future use */
    pmLabel  *labels;       /* indexing into the JSON string */
} pmLabelSet;
</pre></div>
</div>
<p>The <strong>pmLabel labels</strong> array provides name and value indexes and lengths in the json string.</p>
<p>The <strong>flags</strong> field is a bitfield identifying the hierarchy level and whether this name:value pair is intrinsic (optional) or extrinsic (part of the mandatory,
identifying metadata for the metric or instance). All other fields are offsets and lengths in the JSONB string from an associated <strong>pmLabelSet</strong> structure.</p>
</div>
<div class="section" id="performance-metrics-values">
<h2><a class="toc-backref" href="#id9">3.5. Performance Metrics Values</a><a class="headerlink" href="#performance-metrics-values" title="Permalink to this headline">¶</a></h2>
<p>An application may fetch (or store) values for a set of performance metrics, each with a set of associated instances, using a single <strong>pmFetch</strong> (or <strong>pmStore</strong>)
function call. To accommodate this, values are delivered across the PMAPI in the form of a tree data structure, rooted at a <strong>pmResult</strong> structure. This encoding
is illustrated in <a class="reference internal" href="#figure-3-1-a-structured-result-for-performance-metrics-from-pmfetch">Figure 3.1. A Structured Result for Performance Metrics from pmFetch</a>, and uses the component data structures in
<a class="reference internal" href="#example-3-6-pmvalueblock-and-pmvalue-structures">Example 3.6. pmValueBlock and pmValue Structures</a>:</p>
<p id="example-3-6-pmvalueblock-and-pmvalue-structures"><strong>Example 3.6. pmValueBlock and pmValue Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    int inst;                 /* instance identifier */
    union {
        pmValueBlock *pval;   /* pointer to value-block */
        int           lval;   /* integer value insitu */
    } value;
} pmValue;
</pre></div>
</div>
<div class="figure" id="id1">
<span id="figure-3-1-a-structured-result-for-performance-metrics-from-pmfetch"></span><img alt="../_images/pmresult.png" src="../_images/pmresult.png" />
<p class="caption"><span class="caption-text">Figure 3.1. A Structured Result for Performance Metrics from pmFetch</span></p>
</div>
<p>The internal instance identifier is stored in the <strong>inst</strong> element. If a value for a particular metric-instance pair is a 32-bit integer (signed or unsigned), then
it will be stored in the <strong>lval</strong> element. If not, the value will be in a <strong>pmValueBlock</strong> structure, as shown in <a class="reference internal" href="#example-3-7-pmvalueblock-structure">Example 3.7. pmValueBlock Structure</a>, and will
be located via <strong>pval</strong>:</p>
<p>The <strong>pmValueBlock</strong> structure is as follows:</p>
<p id="example-3-7-pmvalueblock-structure"><strong>Example 3.7. pmValueBlock Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    unsigned int    vlen : 24;    /* bytes for vtype/vlen + vbuf */
    unsigned int    vtype : 8;    /* value type */
    char            vbuf[1];      /* the value */
} pmValueBlock;
</pre></div>
</div>
<p>The length of the <strong>pmValueBlock</strong> (including the <strong>vtype</strong> and <strong>vlen</strong> fields) is stored in <strong>vlen</strong>. Despite the prototype declaration of <strong>vbuf</strong>, this array
really accommodates <strong>vlen</strong> minus <strong>sizeof(vlen)</strong> bytes. The <strong>vtype</strong> field encodes the type of the value in the <strong>vbuf[]</strong> array, and is one of the
<strong>PM_TYPE_*</strong> macros defined in <strong>&lt;pcp/pmapi.h&gt;</strong>.</p>
<p>A <strong>pmValueSet</strong> structure, as shown in <a class="reference internal" href="#example-3-8-pmvalueset-structure">Example 3.8. pmValueSet Structure</a>, contains all of the values to be returned from <strong>pmFetch</strong> for a single performance
metric identified by the <strong>pmid</strong> field.</p>
<p id="example-3-8-pmvalueset-structure"><strong>Example 3.8. pmValueSet Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    pmID    pmid;          /* metric identifier */
    int     numval;        /* number of values */
    int     valfmt;        /* value style, insitu or ptr */
    pmValue vlist[1];      /* set of instances/values */
} pmValueSet;
</pre></div>
</div>
<p>If positive, the <strong>numval</strong> field identifies the number of value-instance pairs in the <strong>vlist</strong> array (despite the prototype declaration of size 1). If <strong>numval</strong>
is zero, there are no values available for the associated performance metric and <strong>vlist[0]</strong> is undefined. A negative value for <strong>numval</strong> indicates an error
condition (see the <strong>pmErrStr(3)</strong> man page) and <strong>vlist[0]</strong> is undefined. The <strong>valfmt</strong> field has the value <strong>PM_VAL_INSITU</strong> to indicate that the values for the
performance metrics should be located directly via the <strong>lval</strong> member of the <strong>value</strong> union embedded in the elements of <strong>vlist</strong>; otherwise, metric values are
located indirectly via the <strong>pval</strong> member of the elements of <strong>vlist</strong>.</p>
<p>The <strong>pmResult</strong> structure, as shown in <a class="reference internal" href="#example-3-9-pmresult-structure">Example 3.9. pmResult Structure</a>, contains a time stamp and an array of <strong>numpmid</strong> pointers to <strong>pmValueSet</strong>.</p>
<p id="example-3-9-pmresult-structure"><strong>Example 3.9. pmResult Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Result returned by pmFetch() */
typedef struct {
    struct timeval timestamp;    /* stamped by collector */
    int            numpmid;      /* number of PMIDs */
    pmValueSet     *vset[1];     /* set of value sets */
} pmResult
</pre></div>
</div>
<p>There is one <strong>pmValueSet</strong> pointer per PMID, with a one-to-one correspondence to the set of requested PMIDs passed to <strong>pmFetch</strong>.</p>
<p>Along with the metric values, the PMAPI returns a time stamp with each <strong>pmResult</strong> that serves to identify when the performance metric values were collected. The
time is in the format returned by <strong>gettimeofday</strong> and is typically very close to the time when the metric values were extracted from their respective domains.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a question of exactly when individual metrics may have been collected, especially given their origin in potentially different performance metric
domains, and variability in metric updating frequency by individual PMDAs. PCP uses a pragmatic approach, in which the PMAPI implementation returns all metrics
with values accurate as of the time stamp, to the maximum degree possible, and PMCD demands that all PMDAs deliver values within a small realtime window. The
resulting inaccuracy is small, and the additional burden of accurate individual timestamping for each returned metric value is neither warranted nor practical
(from an implementation viewpoint).</p>
</div>
<p>The PMAPI provides functions to extract, rescale, and print values from the above structures; refer to Section 3.8.11, “<a class="reference internal" href="#pmapi-ancillary-support-services">PMAPI Ancillary Support Services</a>”.</p>
</div>
<div class="section" id="performance-event-metrics">
<h2><a class="toc-backref" href="#id10">3.6. Performance Event Metrics</a><a class="headerlink" href="#performance-event-metrics" title="Permalink to this headline">¶</a></h2>
<p>In addition to performance metric values which are sampled by monitor tools, PCP supports the notion of performance event metrics which occur independently to any
sampling frequency. These event metrics (PM_TYPE_EVENT) are delivered using a novel approach which allows both sampled and event trace data to be delivered via the
same live wire protocol, the same on-disk archive format, and fundamentally using the same PMAPI services. In other words, a monitor tool may be sample and trace,
simultaneously, using the PMAPI services discussed here.</p>
<p>Event metrics are characterised by certain key properties, distinguishing them from the other metric types (counters, instantaneous, and discrete):</p>
<ul class="simple">
<li>Occur at times outside of any monitor tools control, and often have a fine-grained timestamp associated with each event.</li>
<li>Often have parameters associated with the event, which further describe each individual event, as shown in <a class="reference internal" href="#figure-3-2-sample-write-2-syscall-entry-point-encoding">Figure 3.2. Sample write(2) syscall entry point encoding</a>.</li>
<li>May occur in very rapid succession, at rates such that both the collector and monitor sides may not be able to track all events. This property requires the PCP
protocol to support the notion of “dropped” or “missed” events.</li>
<li>There may be inherent relationships between events, for example the start and commit (or rollback) of a database transaction could be separate events, linked by
a common transaction identifier (which would likely also be one of the parameters to each event). Begin-end and parent-child relationships are relatively common,
and these properties require the PCP protocol to support the notion of “flags” that can be associated with events.</li>
</ul>
<p>These differences aside, the representation of event metrics within PCP shares many aspects of the other metric types - event metrics appear in the Name Space (as
do each of the event parameters), each has an associated Performance Metric Identifier and Descriptor, may have an instance domain associated with them, and may be
recorded by <strong>pmlogger</strong> for subsequent replay.</p>
<div class="figure" id="id2">
<span id="figure-3-2-sample-write-2-syscall-entry-point-encoding"></span><img alt="../_images/syscallevent.png" src="../_images/syscallevent.png" />
<p class="caption"><span class="caption-text">Figure 3.2. Sample write(2) syscall entry point encoding</span></p>
</div>
<p>Event metrics and their associated information (parameters, timestamps, flags, and so on) are delivered to monitoring tools alongside sampled metrics as part of
the <strong>pmResult</strong> structure seen previously in <a class="reference internal" href="#example-3-9-pmresult-structure">Example 3.9. pmResult Structure</a>.</p>
<p>The semantics of <strong>pmFetch(3)</strong> specifying an event metric PMID are such that all events observed on the collector since the previous fetch (by this specific
monitor client) are to transfered to the monitor. Each event will have the metadata described earlier encoded with it (timestamps, flags, and so on) for each event.
The encoding of the series of events involves a compound data structure within the <strong>pmValueSet</strong> associated with the event metric PMID, as illustrated in
<a class="reference internal" href="#figure-3-3-result-format-for-event-performance-metrics-from-pmfetch">Figure 3.3. Result Format for Event Performance Metrics from pmFetch</a>.</p>
<div class="figure" id="id3">
<span id="figure-3-3-result-format-for-event-performance-metrics-from-pmfetch"></span><img alt="../_images/pmevents.png" src="../_images/pmevents.png" />
<p class="caption"><span class="caption-text">Figure 3.3. Result Format for Event Performance Metrics from pmFetch</span></p>
</div>
<p>At the highest level, the “series of events” is encapsulated within a <strong>pmEventArray</strong> structure, as in <a class="reference internal" href="#example-3-10-pmeventarray-and-pmeventrecord-structures">Example 3.10. pmEventArray and pmEventRecord Structures</a>:</p>
<p id="example-3-10-pmeventarray-and-pmeventrecord-structures"><strong>Example 3.10. pmEventArray and pmEventRecord Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    pmTimeval      er_timestamp;  /* 2 x 32-bit timestamp format */
    unsigned int     er_flags;      /* event record characteristics */
    int              er_nparams;    /* number of ea_param[] entries */
    pmEventParameter er_param[1];
} pmEventRecord;

typedef struct {
    unsigned int     ea_len :  24;  /* bytes for type/len + records */
    unsigned int     ea_type : 8;   /* value type */
    int              ea_nrecords;   /* number of ea_record entries */
    pmEventRecord    ea_record[1];
} pmEventArray;
</pre></div>
</div>
<p>Note that in the case of dropped events, the <strong>pmEventRecord</strong> structure is used to convey the number of events dropped - <em>er_flags</em> is used to indicate the
presence of dropped events, and <em>er_nparams</em> is used to hold a count. Unsurprisingly, the parameters (<em>er_param</em>) will be empty in this situation.</p>
<p>The <strong>pmEventParameter</strong> structure is as follows:</p>
<p id="example-3-11-pmeventparameter-structure"><strong>Example 3.11. pmEventParameter Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    pmID             ep_pmid;       /* parameter identifier */
    unsigned int     ep_type;       /* value type */
    int              ep_len;        /* bytes for type/len + vbuf */
    /* actual value (vbuf) here */
} pmEventParameter;
</pre></div>
</div>
<div class="section" id="event-monitor-considerations">
<h3><a class="toc-backref" href="#id11">3.6.1. Event Monitor Considerations</a><a class="headerlink" href="#event-monitor-considerations" title="Permalink to this headline">¶</a></h3>
<p>In order to simplify the decoding of event record arrays, the PMAPI provides the <strong>pmUnpackEventRecords</strong> function for monitor tools. This function is passed a
pointer to a <strong>pmValueSet</strong> associated with an event metric (within a <strong>pmResult</strong>) from a <strong>pmFetch(3)</strong>. For a given instance of that event metric, it returns an
array of “unpacked” <strong>pmResult</strong> structures for each event.</p>
<p>The control information (flags and optionally dropped events) is included as derived metrics within each result structure. As such, these values can be queried
similarly to other metrics, using their names - <strong>event.flags</strong> and <strong>event.missed</strong>. Note that these metrics will only exist after the first call to
<strong>pmUnpackEventRecords</strong>.</p>
<p>An example of decoding event metrics in this way is presented in <a class="reference internal" href="#example-3-12-unpacking-event-records-from-an-event-metric-pmvalueset">Example 3.12. Unpacking Event Records from an Event Metric pmValueSet</a>:</p>
<p id="example-3-12-unpacking-event-records-from-an-event-metric-pmvalueset"><strong>Example 3.12. Unpacking Event Records from an Event Metric pmValueSet</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum { event_flags = 0, event_missed = 1 };
static char *metadata[] = { &quot;event.flags&quot;, &quot;event.missed&quot; };
static pmID metapmid[2];

void dump_event(pmValueSet *vsp, int idx)
{
    pmResult    **res;
    int                r, sts, nrecords;

    nrecords = pmUnpackEventRecords(vsp, idx, &amp;res);
    if (nrecords &lt; 0)
        fprintf(stderr, &quot; pmUnpackEventRecords: %s\n&quot;, pmErrStr(nrecords));
    else
        printf(&quot; %d event records\n&quot;, nrecords);

    if ((sts = pmLookupName(2, &amp;metadata, &amp;metapmid)) &lt; 0) {
        fprintf(stderr, &quot;Event metadata error: %s\n&quot;, pmErrStr(sts));
        exit(1);
    }

    for (r = 0; r &lt; nrecords; r++)
        dump_event_record(res, r);

    if (nrecords &gt;= 0)
        pmFreeEventResult(res);
}

void dump_event_record(pmResult *res, int r)
{
    int         p;

    pmPrintStamp(stdout, &amp;res[r]-&gt;timestamp);
    if (res[r]-&gt;numpmid == 0)
               printf(&quot; ==&gt; No parameters\n&quot;);
    for (p = 0; p &lt; res[r]-&gt;numpmid; p++) {
        pmValueSet  *vsp = res[r]-&gt;vset[p];

        if (vsp-&gt;numval &lt; 0) {
            int error = vsp-&gt;numval;
            printf(&quot;%s: %s\n&quot;, pmIDStr(vsp-&gt;pmid), pmErrStr(error));
        } else if (vsp-&gt;pmid == metapmid[event_flags]) {
            int flags = vsp-&gt;vlist[0].value.lval;
            printf(&quot; flags 0x%x (%s)\n&quot;, flags, pmEventFlagsStr(flags));
        } else if (vsp-&gt;pmid == metapmid[event_missed]) {
            int count = vsp-&gt;vlist[0].value.lval;
            printf(&quot; ==&gt; %d missed event records\n&quot;, count);
        } else {
            dump_event_record_parameters(vsp);
        }
    }
}

void dump_event_record_parameters(pmValueSet *vsp)
{
    pmDesc      desc;
    char        *name;
    int         sts, j;

    if ((sts = pmLookupDesc(vsp-&gt;pmid, &amp;desc)) &lt; 0) {
        fprintf(stderr, &quot;pmLookupDesc: %s\n&quot;, pmErrStr(sts));
    } else
    if ((sts = pmNameID(vsp-&gt;pmid, &amp;name)) &lt; 0) {
        fprintf(stderr, &quot;pmNameID: %s\n&quot;, pmErrStr(sts));
    } else {
        printf(&quot;parameter %s&quot;, name);
        for (j = 0; j &lt; vsp-&gt;numval; j++) {
            pmValue *vp = &amp;vsp-&gt;vlist[j];
            if (vsp-&gt;numval &gt; 1) {
                printf(&quot;[%d]&quot;, vp-&gt;inst);
                pmPrintValue(stdout, vsp-&gt;valfmt, desc.type, vp, 1);
                putchar(&#39;\n&#39;);
            }
        }
        free(name);
    }
}
</pre></div>
</div>
</div>
<div class="section" id="event-collector-considerations">
<h3><a class="toc-backref" href="#id12">3.6.2. Event Collector Considerations</a><a class="headerlink" href="#event-collector-considerations" title="Permalink to this headline">¶</a></h3>
<p>There is a feedback mechanism that is inherent in the design of the PCP monitor-collector event metric value exchange, which protects both monitor and collector
components from becoming overrun by high frequency event arrivals. It is important that PMDA developers are aware of this mechanism and all of its implications.</p>
<p>Monitor tools can query new event arrival on whatever schedule they choose. There are no guarantees that this is a fixed interval, and no way for the PMDA to
attempt to dictate this interval (nor should there be).</p>
<p>As a result, a PMDA that provides event metrics must:</p>
<ul class="simple">
<li>Track individual client connections using the per-client PMDA extensions (PMDA_INTERFACE_5 or later).</li>
<li>Queue events, preferably in a memory-efficient manner, such that each interested monitor tool (there may be more than one) is informed of those events that
arrived since their last request.</li>
<li>Control the memory allocated to in-memory event storage. If monitors are requesting new events too slowly, compared to event arrival on the collector, the
“missed events” feedback mechanism must be used to inform the monitor. This mechanism is also part of the model by which a PMDA can fix the amount of memory it
uses. Once a fixed space is consumed, events can be dropped from the tail of the queue for each client, provided a counter is incremented and the client is
subsequently informed.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important that PMDAs are part of the performance solution, and not part of the performance problem! With event metrics, this is much more difficult to
achieve than with counters or other sampled values.</p>
</div>
<p>There is certainly elegance to this approach for event metrics, and the way they dovetail with other, sampled performance metrics is unique to PCP. Notice also
how the scheme naturally allows multiple monitor tools to consume the same events, no matter what the source of events is. The downside to this flexibility is
increased complexity in the PMDA when event metrics are used.</p>
<p>This complexity comes in the form of event queueing and memory management, as well as per-client state tracking. Routines are available as part of the <strong>pcp_pmda</strong>
library to assist, however - refer to the man page entries for <strong>pmdaEventNewQueue(3)</strong> and <strong>pmdaEventNewClient(3)</strong> for further details.</p>
<p>One final set of helper APIs is available to PMDA developers who incorporate event metrics. There is a need to build the <strong>pmEventArray</strong> structure, introduced in
<a class="reference internal" href="#example-3-10-pmeventarray-and-pmeventrecord-structures">Example 3.10. pmEventArray and pmEventRecord Structures</a>. This can be done directly, or using the helper routine <strong>pmdaEventNewArray(3)</strong>. If the latter, simpler
model is chosen, the closely related routines <strong>pmdaEventAddRecord, pmdaEventAddParam</strong> and <strong>pmdaEventAddMissedRecord</strong> would also usually be used.</p>
<p>Depending on the nature of the events being exported by a PMDA, it can be desirable to perform <strong>filtering</strong> of events on the collector system. This reduces the
amount of event traffic between monitor and collector systems (which may be filtered further on the monitor system, before presenting results). Some PMDAs have had
success using the <strong>pmStore(3)</strong> mechanism to allow monitor tools to send a filter to the PMDA - using either a special control metric for the store operation, or
the event metric itself. The filter sent will depend on the event metric, but it might be a regular expression, or a tracing script, or something else.</p>
<p>This technique has also been used to <strong>enable</strong> and <strong>disable</strong> event tracing entirely. It is often appropriate to make use of authentication and user credentials
when providing such a facility (PMDA_INTERFACE_6 or later).</p>
</div>
</div>
<div class="section" id="pmapi-programming-style-and-interaction">
<h2><a class="toc-backref" href="#id13">3.7. PMAPI Programming Style and Interaction</a><a class="headerlink" href="#pmapi-programming-style-and-interaction" title="Permalink to this headline">¶</a></h2>
<p>The following sections describe the PMAPI programming style:</p>
<ul class="simple">
<li>Variable length argument and results lists</li>
<li>Python specific issues</li>
<li>PMAPI error handling</li>
</ul>
<div class="section" id="variable-length-argument-and-results-lists">
<h3><a class="toc-backref" href="#id14">3.7.1. Variable Length Argument and Results Lists</a><a class="headerlink" href="#variable-length-argument-and-results-lists" title="Permalink to this headline">¶</a></h3>
<p>All arguments and results involving a “list of something” are encoded as an array with an associated argument or function value to identify the number of elements
in the array. This encoding scheme avoids both the <strong>varargs</strong> approach and sentinel-terminated lists. Where the size of a result is known at the time of a call,
it is the caller’s responsibility to allocate (and possibly free) the storage, and the called function assumes that the resulting argument is of an appropriate size.</p>
<p>Where a result is of variable size and that size cannot be known in advance (for example, <strong>pmGetChildren, pmGetInDom, pmNameInDom, pmNameID, pmLookupText</strong>,
<strong>pmLookupLabels</strong> and <strong>pmFetch</strong>), the underlying implementation uses dynamic allocation through <strong>malloc</strong> in the called function, with the caller responsible
for subsequently calling <strong>free</strong> to release the storage when no longer required.</p>
<p>In the case of the result from <strong>pmFetch</strong>, there is a function (<strong>pmFreeResult</strong>) to release the storage, due to the complexity of the data structure and the
need to make multiple calls to <strong>free</strong> in the correct sequence. Similarly, the <strong>pmLookupLabels</strong> function has an associated function (<strong>pmFreeLabelSets</strong>) to
release the storage.</p>
<p>As a general rule, if the called function returns an error status, then no allocation is done, the pointer to the variable sized result is undefined, and <strong>free</strong>,
<strong>pmFreeLabelSets</strong>, or <strong>pmFreeResult</strong> should not be called.</p>
</div>
<div class="section" id="python-specific-issues">
<h3><a class="toc-backref" href="#id15">3.7.2. Python Specific Issues</a><a class="headerlink" href="#python-specific-issues" title="Permalink to this headline">¶</a></h3>
<p>A pcp client may be written in the python language by making use of the python bindings for PMAPI. The bindings use the python ctypes module to provide an interface
to the PMAPI C language data structures. The primary imports that are needed by a client are:</p>
<ul>
<li><p class="first">cpmapi which provides access to PMAPI constants</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import cpmapi as c_api
</pre></div>
</div>
</li>
<li><p class="first">pmapi which provides access to PMAPI functions and data structures</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pcp import pmapi
</pre></div>
</div>
</li>
<li><p class="first">pmErr which provides access to the python bindings exception handler</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pcp.pmapi import pmErr
</pre></div>
</div>
</li>
<li><p class="first">pmgui which provides access to PMAPI record mode functions</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pcp import pmgui
</pre></div>
</div>
</li>
</ul>
<p>Creating and destroying a PMAPI context in the python environment is done by creating and destroying an object of the pmapi class. This is done in one of two ways,
either directly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>context = pmapi.pmContext()
</pre></div>
</div>
<p>or by automated processing of the command line arguments (refer to the <strong>pmGetOptions</strong> man page for greater detail).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>options = pmapi.pmOptions(...)
context = pmapi.pmContext.fromOptions(options, sys.argv)
</pre></div>
</div>
<p>Most PMAPI C functions have python equivalents with similar, although not identical, call signatures. Some of the python functions do not return native python
types, but instead return native C types wrapped by the ctypes library. In most cases these types are opaque, or nearly so; for example <em>pmid</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pmid = context.pmLookupName(&quot;mem.freemem&quot;)
desc = context.pmLookupDescs(pmid)
result = context.pmFetch(pmid)
...
</pre></div>
</div>
<p>See the comparison of a standalone C and python client application in <a class="reference internal" href="#example-3-25-pmapi-error-handling">Example 3.25. PMAPI Error Handling</a>.</p>
</div>
<div class="section" id="pmapi-error-handling">
<h3><a class="toc-backref" href="#id16">3.7.3. PMAPI Error Handling</a><a class="headerlink" href="#pmapi-error-handling" title="Permalink to this headline">¶</a></h3>
<p>Where error conditions may arise, the functions that compose the PMAPI conform to a single, simple error notification scheme, as follows:</p>
<ul class="simple">
<li>The function returns an <strong>int</strong>. Values greater than or equal to zero indicate no error, and perhaps some positive status: for example, the number of items processed.</li>
<li>Values less than zero indicate an error, as determined by a global table of error conditions and messages.</li>
</ul>
<p>A PMAPI library function along the lines of <strong>strerror</strong> is provided to translate error conditions into error messages; see the <strong>pmErrStr(3)</strong> and <strong>pmErrStr_r(3)</strong>
man pages. The error condition is returned as the function value from a previous PMAPI call; there is no global error indicator (unlike <strong>errno</strong>). This is to
accommodate multi-threaded performance tools.</p>
<p>The available error codes may be displayed with the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pmerr -l
</pre></div>
</div>
<p>Where possible, PMAPI routines are made as tolerant to failure as possible. In particular, routines which deal with compound data structures - results structures,
multiple name lookups in one call and so on, will attempt to return all data that can be returned successfully, and errors embedded in the result where there were
(partial) failures. In such cases a negative failure return code from the routine indicates catastrophic failure, otherwise success is returned and indicators for
the partial failures are returned embedded in the results.</p>
</div>
</div>
<div class="section" id="pmapi-procedural-interface">
<h2><a class="toc-backref" href="#id17">3.8. PMAPI Procedural Interface</a><a class="headerlink" href="#pmapi-procedural-interface" title="Permalink to this headline">¶</a></h2>
<p>The following sections describe all of the PMAPI functions that provide access to the PCP infrastructure on behalf of a client application:</p>
<ul class="simple">
<li>PMAPI Name Space services</li>
<li>PMAPI metric description services</li>
<li>PMAPI instance domain services</li>
<li>PMAPI context services</li>
<li>PMAPI timezone services</li>
<li>PMAPI metrics services</li>
<li>PMAPI fetchgroup services</li>
<li>PMAPI record-mode services</li>
<li>PMAPI archive-specific services</li>
<li>PMAPI time control services</li>
<li>PMAPI ancillary support services</li>
</ul>
<div class="section" id="pmapi-name-space-services">
<h3><a class="toc-backref" href="#id18">3.8.1. PMAPI Name Space Services</a><a class="headerlink" href="#pmapi-name-space-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) Name Space services.</p>
<div class="section" id="pmgetchildren-function">
<h4><a class="toc-backref" href="#id19">3.8.1.1. pmGetChildren Function</a><a class="headerlink" href="#pmgetchildren-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetChildren(const char*name, char***offspring)
Python:
[name1, name2...] = pmGetChildren(name)
</pre></div>
</div>
<p>Given a full pathname to a node in the current PMNS, as identified by <em>name</em>, return through <em>offspring</em> a list of the relative names of all the immediate descendents
of <em>name</em> in the current PMNS. As a special case, if <em>name</em> is an empty string, (that is, <strong>“”</strong> but not <strong>NULL</strong> or <strong>(char *)0</strong>), the immediate descendents of
the root node in the PMNS are returned.</p>
<p>For the python bindings a tuple containing the relative names of all the immediate descendents of <em>name</em> in the current PMNS is returned.</p>
<p>Normally, <strong>pmGetChildren</strong> returns the number of descendent names discovered, or a value less than zero for an error. The value zero indicates that the <em>name</em> is
valid, and associated with a leaf node in the PMNS.</p>
<p>The resulting list of pointers (<em>offspring</em>) and the values (relative metric names) that the pointers reference are allocated by <strong>pmGetChildren</strong> with a single
call to <strong>malloc</strong>, and it is the responsibility of the caller to issue a <strong>free</strong> (<em>offspring</em>) system call to release the space when it is no longer required.
When the result of <strong>pmGetChildren</strong> is less than one, <em>offspring</em> is undefined (no space is allocated, and so calling <strong>free</strong> is counterproductive).</p>
<p>The python bindings return a tuple containing the relative names of all the immediate descendents of <em>name</em>, where <em>name</em> is a full pathname to a node in the
current PMNS.</p>
</div>
<div class="section" id="pmgetchildrenstatus-function">
<h4><a class="toc-backref" href="#id20">3.8.1.2. pmGetChildrenStatus Function</a><a class="headerlink" href="#pmgetchildrenstatus-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetChildrenStatus(const char *name, char ***offspring, int **status)
Python:
([name1, name2...],[status1, status2...]) = pmGetChildrenStatus(name)
</pre></div>
</div>
<p>The <strong>pmGetChildrenStatus</strong> function is an extension of <strong>pmGetChildren</strong> that optionally returns status information about each of the descendent names.</p>
<p>Given a fully qualified pathname to a node in the current PMNS, as identified by <em>name</em>, <strong>pmGetChildrenStatus</strong> returns by means of <em>offspring</em> a list of the
relative names of all of the immediate descendent nodes of <em>name</em> in the current PMNS. If <em>name</em> is the empty string (“”), it returns the immediate descendents of
the root node in the PMNS.</p>
<p>If <em>status</em> is not NULL, then <strong>pmGetChildrenStatus</strong> also returns the status of each child by means of <em>status</em>. This refers to either a leaf node (with value
<strong>PMNS_LEAF_STATUS</strong>) or a non-leaf node (with value <strong>PMNS_NONLEAF_STATUS</strong>).</p>
<p>Normally, <strong>pmGetChildrenStatus</strong> returns the number of descendent names discovered, or else a value less than zero to indicate an error. The value zero indicates
that name is a valid metric name, being associated with a leaf node in the PMNS.</p>
<p>The resulting list of pointers (<em>offspring</em>) and the values (relative metric names) that the pointers reference are allocated by <strong>pmGetChildrenStatus</strong> with a
single call to <strong>malloc</strong>, and it is the responsibility of the caller to <strong>free</strong> (<em>offspring</em>) to release the space when it is no longer required. The same holds true
for the <em>status</em> array.</p>
<p>The python bindings return a tuple containing the relative names and statuses of all the immediate descendents of <em>name</em>, where <em>name</em> is a full pathname to a node
in the current PMNS.</p>
</div>
<div class="section" id="pmgetpmnslocation-function">
<h4><a class="toc-backref" href="#id21">3.8.1.3. pmGetPMNSLocation Function</a><a class="headerlink" href="#pmgetpmnslocation-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetPMNSLocation(void)
Python:
int loc = pmGetPMNSLocation()
</pre></div>
</div>
<p>If an application needs to know where the origin of a PMNS is, <strong>pmGetPMNSLocation</strong> returns whether it is an archive (<strong>PMNS_ARCHIVE</strong>), a local PMNS file
(<strong>PMNS_LOCAL</strong>), or a remote PMCD (<strong>PMNS_REMOTE</strong>). This information may be useful in determining an appropriate error message depending on PMNS location.</p>
<p>The python bindings return whether a PMNS is an archive <em>cpmapi.PMNS_ARCHIVE</em>, a local PMNS file <em>cpmapi.PMNS_LOCAL</em>, or a remote PMCD <em>cpmapi.PMNS_REMOTE</em>.
The constants are available by importing cpmapi.</p>
</div>
<div class="section" id="pmloadnamespace-function">
<h4><a class="toc-backref" href="#id22">3.8.1.4. pmLoadNameSpace Function</a><a class="headerlink" href="#pmloadnamespace-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLoadNameSpace(const char *filename)
Python:
int status = pmLoadNameSpace(filename)
</pre></div>
</div>
<p>In the highly unusual situation that an application wants to force using a local Performance Metrics Name Space (PMNS), the application can load the PMNS using
<strong>pmLoadNameSpace</strong>.</p>
<p>The <em>filename</em> argument designates the PMNS of interest. For applications that do not require a tailored Name Space, the special value <strong>PM_NS_DEFAULT</strong> may be used
for <em>filename</em>, to force a default local PMNS to be established. Externally, a PMNS is stored in an ASCII format.</p>
<p>The python bindings load a local tailored Name Space from <em>filename</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Do not use this routine in monitor tools. The distributed PMNS services avoid the need for a local PMNS; so applications should <strong>not</strong> use <strong>pmLoadNameSpace</strong>.
Without this call, the default PMNS is the one at the source of the performance metrics (PMCD or an archive).</p>
</div>
</div>
<div class="section" id="pmlookupname-function">
<h4><a class="toc-backref" href="#id23">3.8.1.5. pmLookupName Function</a><a class="headerlink" href="#pmlookupname-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupName(int numpmid, char *namelist[], pmID pmidlist[])
Python:
c_uint pmid [] = pmLookupName(&quot;MetricName&quot;)
c_uint pmid [] = pmLookupName((&quot;MetricName1&quot;, &quot;MetricName2&quot;, ...))
</pre></div>
</div>
<p>Given a list in <em>namelist</em> containing <em>numpmid</em> full pathnames for performance metrics from the current PMNS, <strong>pmLookupName</strong> returns the list of associated PMIDs
through the <em>pmidlist</em> parameter. Invalid metrics names are translated to the error PMID value of <strong>PM_ID_NULL</strong>.</p>
<p>The result from <strong>pmLookupName</strong> is the number of names translated in the absence of errors, or an error indication. Note that argument definition and the error
protocol guarantee a one-to-one relationship between the elements of <em>namelist</em> and <em>pmidlist</em>; both lists contain exactly <em>numpmid</em> elements.</p>
<p>The python bindings return an array of associated PMIDs corresponding to a tuple of <em>MetricNames</em>. The returned <em>pmid</em> tuple is passed to <strong>pmLookupDescs</strong> and
<strong>pmFetch</strong>.</p>
</div>
<div class="section" id="pmnameall-function">
<h4><a class="toc-backref" href="#id24">3.8.1.6. pmNameAll Function</a><a class="headerlink" href="#pmnameall-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNameAll(pmID pmid, char ***nameset)
Python:
[name1, name2...] = pmNameAll(pmid)
</pre></div>
</div>
<p>Given a performance metric ID in <em>pmid</em>, <strong>pmNameAll</strong> determines all the corresponding metric names, if any, in the PMNS, and returns these through <em>nameset</em>.</p>
<p>The resulting list of pointers <em>nameset</em> and the values (relative names) that the pointers reference are allocated by <strong>pmNameAll</strong> with a single call to <strong>malloc</strong>.
It is the caller’s responsibility to call <strong>free</strong> and release the space when it is no longer required.</p>
<p>In the absence of errors, <strong>pmNameAll</strong> returns the number of names in <strong>nameset</strong>.</p>
<p>For many PMNS instances, there is a 1:1 mapping between a name and a PMID, and under these circumstances, <strong>pmNameID</strong> provides a simpler interface in the absence
of duplicate names for a particular PMID.</p>
<p>The python bindings return a tuple of all metric names having this identical <em>pmid</em>.</p>
</div>
<div class="section" id="pmnameid-function">
<h4><a class="toc-backref" href="#id25">3.8.1.7. pmNameID Function</a><a class="headerlink" href="#pmnameid-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNameID(pmID pmid, char **name)
Python:
&quot;metric name&quot; = pmNameID(pmid)
</pre></div>
</div>
<p>Given a performance metric ID in <em>pmid</em>, <strong>pmNameID</strong> determines the corresponding metric name, if any, in the current PMNS, and returns this through <em>name</em>.</p>
<p>In the absence of errors, <strong>pmNameID</strong> returns zero. The <em>name</em> argument is a null byte terminated string, allocated by <strong>pmNameID</strong> using <strong>malloc</strong>. It is the
caller’s responsibility to call <strong>free</strong> and release the space when it is no longer required.</p>
<p>The python bindings return a metric name corresponding to a <em>pmid</em>.</p>
</div>
<div class="section" id="pmtraversepmns-function">
<h4><a class="toc-backref" href="#id26">3.8.1.8. pmTraversePMNS Function</a><a class="headerlink" href="#pmtraversepmns-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmTraversePMNS(const char *name, void (*dometric)(const char *))
Python:
int status = pmTraversePMNS(name, traverse_callback)
</pre></div>
</div>
<p>The function <strong>pmTraversePMNS</strong> may be used to perform a depth-first traversal of the PMNS. The traversal starts at the node identified by <em>name</em> –if <em>name</em> is an
empty string, the traversal starts at the root of the PMNS. Usually, <em>name</em> would be the pathname of a non-leaf node in the PMNS.</p>
<p>For each leaf node (actual performance metrics) found in the traversal, the user-supplied function <strong>dometric</strong> is called with the full pathname of that metric in
the PMNS as the single argument; this argument is a null byte-terminated string, and is constructed from a buffer that is managed internally to <strong>pmTraversePMNS</strong>.
Consequently, the value is valid only during the call to <strong>dometric</strong>–if the pathname needs to be retained, it should be copied using <strong>strdup</strong> before returning
from <strong>dometric</strong>; see the <strong>strdup(3)</strong> man page.</p>
<p>The python bindings perform a depth first traversal of the PMNS by scanning <em>namespace</em>, depth first, and call a python function <em>traverse_callback</em> for each node.</p>
</div>
<div class="section" id="pmunloadnamespace-function">
<h4><a class="toc-backref" href="#id27">3.8.1.9. pmUnloadNameSpace Function</a><a class="headerlink" href="#pmunloadnamespace-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmUnloadNameSpace(void)
Python:
pmUnLoadNameSpace(&quot;NameSpace&quot;)
</pre></div>
</div>
<p>If a local PMNS was loaded with <strong>pmLoadNameSpace</strong>, calling <strong>pmUnloadNameSpace</strong> frees up the memory associated with the PMNS and force all subsequent Name Space
functions to use the distributed PMNS. If <strong>pmUnloadNameSpace</strong> is called before calling <strong>pmLoadNameSpace</strong>, it has no effect.</p>
<p>As discussed in Section 3.8.1.4, “<a class="reference internal" href="#pmloadnamespace-function">pmLoadNameSpace Function</a>” there are few if any situations where clients need to call this routine in modern versions of PCP.</p>
</div>
</div>
<div class="section" id="pmapi-metrics-description-services">
<h3><a class="toc-backref" href="#id28">3.8.2. PMAPI Metrics Description Services</a><a class="headerlink" href="#pmapi-metrics-description-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metric description services.</p>
<div class="section" id="pmlookupdesc-function">
<h4><a class="toc-backref" href="#id29">3.8.2.1. pmLookupDesc Function</a><a class="headerlink" href="#pmlookupdesc-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupDesc(pmID pmid, pmDesc *desc)
Python:
pmDesc* pmdesc = pmLookupDesc(c_uint pmid)
(pmDesc* pmdesc)[] = pmLookupDescs(c_uint pmids[N])
(pmDesc* pmdesc)[] = pmLookupDescs(c_uint pmid)
</pre></div>
</div>
<p>Given a Performance Metric Identifier (PMID) as <em>pmid</em>, <strong>pmLookupDesc</strong> returns the associated <strong>pmDesc</strong> structure through the parameter <em>desc</em> from the current
PMAPI context. For more information about <strong>pmDesc</strong>, see Section 3.4, “<a class="reference internal" href="#performance-metric-descriptions">Performance Metric Descriptions</a>”.</p>
<p>The python bindings return the metric description structure <strong>pmDesc</strong> corresponding to <em>pmid</em>. The returned <em>pmdesc</em> is passed to <strong>pmExtractValue</strong> and
<strong>pmLookupInDom</strong>. The python bindings provide an entry <strong>pmLookupDescs</strong> that is similar to pmLookupDesc but does a metric description lookup for each element
in a PMID array <em>pmids</em>.</p>
</div>
<div class="section" id="pmlookupindomtext-function">
<h4><a class="toc-backref" href="#id30">3.8.2.2. pmLookupInDomText Function</a><a class="headerlink" href="#pmlookupindomtext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupInDomText(pmInDom indom, int level, char **buffer)
Python:
&quot;metric description&quot; = pmGetInDomText(pmDesc pmdesc)
</pre></div>
</div>
<p>Provided the source of metrics from the current PMAPI context is a host, retrieve descriptive text about the performance metrics instance domain identified by <em>indom</em>.</p>
<p>The <em>level</em> argument should be <strong>PM_TEXT_ONELINE</strong> for a one-line summary, or <strong>PM_TEXT_HELP</strong> for a more verbose description suited to a help dialogue. The space
pointed to by <em>buffer</em> is allocated in <strong>pmLookupInDomText</strong> with <strong>malloc</strong>, and it is the responsibility of the caller to free unneeded space; see the <strong>malloc(3)</strong>
and <strong>free(3)</strong> man pages.</p>
<p>The help text files used to implement <strong>pmLookupInDomText</strong> are often created using <strong>newhelp</strong> and accessed by the appropriate PMDA response to requests forwarded
to the PMDA by PMCD. Further details may be found in Section 2.4.4, “<a class="reference internal" href="WritingPMDA.html#pmda-help-text"><span class="std std-ref">PMDA Help Text</span></a>” .</p>
<p>The python bindings lookup the description text about the performance metrics pmDesc <em>pmdesc</em>. The default is a one line summary; for a more verbose description
add an optional second parameter <em>cpmapi.PM_TEXT_HELP</em>. The constant is available by importing cpmapi.</p>
</div>
<div class="section" id="pmlookuptext-function">
<h4><a class="toc-backref" href="#id31">3.8.2.3. pmLookupText Function</a><a class="headerlink" href="#pmlookuptext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupText(pmID pmid, int level, char **buffer)
Python:
&quot;metric description&quot; = pmLookupText(c_uint pmid)
</pre></div>
</div>
<p>Retrieve descriptive text about the performance metric identified by <em>pmid</em>. The argument <em>level</em> should be <strong>PM_TEXT_ONELINE</strong> for a one-line summary, or
<strong>PM_TEXT_HELP</strong> for a more verbose description, suited to a help dialogue.</p>
<p>The space pointed to by <em>buffer</em> is allocated in <strong>pmLookupText</strong> with <strong>malloc</strong>, and it is the responsibility of the caller to <strong>free</strong> the space when it is no
longer required; see the <strong>malloc(3)</strong> and <strong>free(3)</strong> man pages.</p>
<p>The help text files used to implement <strong>pmLookupText</strong> are created using <strong>newhelp</strong> and accessed by the appropriate PMDA in response to requests forwarded to the
PMDA by PMCD. Further details may be found in Section 2.4.4, “<a class="reference internal" href="WritingPMDA.html#pmda-help-text"><span class="std std-ref">PMDA Help Text</span></a>”.</p>
<p>The python bindings lookup the description text about the performance metrics pmID <em>pmid</em>. The default is a one line summary; for a more verbose description add an
optional second parameter <em>cpmapi.PM_TEXT_HELP</em>. The constant is available by importing cpmapi.</p>
</div>
<div class="section" id="pmlookuplabels-function">
<h4><a class="toc-backref" href="#id32">3.8.2.4. pmLookupLabels Function</a><a class="headerlink" href="#pmlookuplabels-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupLabels(pmID pmid, pmLabelSet **labelsets)
Python:
(pmLabelSet* pmlabelset)[] pmLookupLabels(c_uint pmid)
</pre></div>
</div>
<p>Retrieve <strong>name:value</strong> pairs providing additional identity and descriptive metadata about the performance metric identified by <em>pmid</em>.</p>
<p>The space pointed to by <em>labelsets</em> is allocated in <strong>pmLookupLabels</strong> with potentially multiple calls to <strong>malloc</strong> and it is the responsibility of the caller to
<strong>pmFreeLabelSets</strong> the space when it is no longer required; see the <strong>malloc(3)</strong> and <strong>pmFreeLabelSets(3)</strong> man pages.</p>
<p>Additional helper interfaces are also available, used internally by <strong>pmLookupLabels</strong> and to help with post-processing of <em>labelsets</em>. See the <strong>pmLookupLabels(3)</strong>
and <strong>pmMergeLabelSets(3)</strong> man pages.</p>
</div>
</div>
<div class="section" id="pmapi-instance-domain-services">
<h3><a class="toc-backref" href="#id33">3.8.3. PMAPI Instance Domain Services</a><a class="headerlink" href="#pmapi-instance-domain-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) instance domain services.</p>
<div class="section" id="pmgetindom-function">
<h4><a class="toc-backref" href="#id34">3.8.3.1. pmGetInDom Function</a><a class="headerlink" href="#pmgetindom-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetInDom(pmInDom indom, int **instlist, char ***namelist)
Python:
([instance1, instance2...] [name1, name2...]) pmGetInDom(pmDesc pmdesc)
</pre></div>
</div>
<p>In the current PMAPI context, locate the description of the instance domain <em>indom</em>, and return through <em>instlist</em> the internal instance identifiers for all
instances, and through <em>namelist</em> the full external identifiers for all instances. The number of instances found is returned as the function value (or less than
zero to indicate an error).</p>
<p>The resulting lists of instance identifiers (<em>instlist</em> and <em>namelist</em>), and the names that the elements of <em>namelist</em> point to, are allocated by <strong>pmGetInDom</strong>
with two calls to <strong>malloc</strong>, and it is the responsibility of the caller to use <strong>free</strong> (<em>instlist</em>) and <strong>free</strong> (<em>namelist</em>) to release the space when it is no
longer required. When the result of <strong>pmGetInDom</strong> is less than one, both <em>instlist</em> and <em>namelist</em> are undefined (no space is allocated, and so calling <strong>free</strong>
is a bad idea); see the <strong>malloc(3)</strong> and <strong>free(3)</strong> man pages.</p>
<p>The python bindings return a tuple of the instance identifiers and instance names for an instance domain <em>pmdesc</em>.</p>
</div>
<div class="section" id="pmlookupindom-function">
<h4><a class="toc-backref" href="#id35">3.8.3.2. pmLookupInDom Function</a><a class="headerlink" href="#pmlookupindom-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupInDom(pmInDom indom, const char *name)
Python:
int instid = pmLookupInDom(pmDesc pmdesc, &quot;Instance&quot;)
</pre></div>
</div>
<p>For the instance domain <em>indom</em>, in the current PMAPI context, locate the instance with the external identification given by <em>name</em>, and return the internal
instance identifier.</p>
<p>The python bindings return the instance id corresponding to <em>“Instance”</em> in the instance domain <em>pmdesc</em>.</p>
</div>
<div class="section" id="pmnameindom-function">
<h4><a class="toc-backref" href="#id36">3.8.3.3. pmNameInDom Function</a><a class="headerlink" href="#pmnameindom-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNameInDom(pmInDom indom, int inst, char **name)
Python:
&quot;instance id&quot; = pmNameInDom(pmDesc pmdesc, c_uint instid)
</pre></div>
</div>
<p>For the instance domain <em>indom</em>, in the current PMAPI context, locate the instance with the internal instance identifier given by <em>inst</em>, and return the full
external identification through <em>name</em>. The space for the value of <em>name</em> is allocated in <strong>pmNameInDom</strong> with <strong>malloc</strong>, and it is the responsibility of the
caller to free the space when it is no longer required; see the <strong>malloc(3)</strong> and <strong>free(3)</strong> man pages.</p>
<p>The python bindings return the text name of an instance corresponding to an instance domain <em>pmdesc</em> with instance identifier <em>instid</em>.</p>
</div>
</div>
<div class="section" id="pmapi-context-services">
<h3><a class="toc-backref" href="#id37">3.8.4. PMAPI Context Services</a><a class="headerlink" href="#pmapi-context-services" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#table-3-1-context-components-of-pmapi-functions">Table 3.1. Context Components of PMAPI Functions</a> shows which of the three components of a PMAPI context (metrics source, instance profile, and collection time)
are relevant for various PMAPI functions. Those PMAPI functions not shown in this table either manipulate the PMAPI context directly, or are executed independently
of the current PMAPI context.</p>
<p id="table-3-1-context-components-of-pmapi-functions"><strong>Table 3.1. Context Components of PMAPI Functions</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="40%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Function name</strong></td>
<td><strong>Metrics Source</strong></td>
<td><strong>Instance Profile</strong></td>
<td><strong>Collection Time</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr class="row-even"><td><strong>pmAddProfile</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmDelProfile</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmDupContext</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmFetch</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmFetchArchive</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>Yes</td>
<td>( 1 )</td>
</tr>
<tr class="row-odd"><td><strong>pmGetArchiveEnd</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 1 )</td>
</tr>
<tr class="row-even"><td><strong>pmGetArchiveLabel</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 1 )</td>
</tr>
<tr class="row-odd"><td><strong>pmGetChildren</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmGetChildrenStatus</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmGetContextHostName</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmGetPMNSLocation</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmGetInDom</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>Yes</td>
<td>( 2 )</td>
</tr>
<tr class="row-even"><td><strong>pmGetInDomArchive</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 1 )</td>
</tr>
<tr class="row-odd"><td><strong>pmLookupDesc</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 3 )</td>
</tr>
<tr class="row-even"><td><strong>pmLookupInDom</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>Yes</td>
<td>( 2 )</td>
</tr>
<tr class="row-odd"><td><strong>pmLookupInDomArchive</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 1,2 )</td>
</tr>
<tr class="row-even"><td><strong>pmLookupInDomText</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmLookupLabels</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmLookupName</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmLookupText</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmNameAll</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmNameID</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>pmNameInDom</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>Yes</td>
<td>( 2 )</td>
</tr>
<tr class="row-odd"><td><strong>pmNameInDomArchive</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 1,2 )</td>
</tr>
<tr class="row-even"><td><strong>pmSetMode</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>Yes</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>pmStore</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>( 4 )</td>
</tr>
<tr class="row-even"><td><strong>pmTraversePMNS</strong></td>
<td>Yes</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>Operation supported only for PMAPI contexts where the source of metrics is an archive.</li>
<li>A specific instance domain is included in the arguments to these functions, and the result is independent of the instance profile for any PMAPI context.</li>
<li>The metadata that describes a performance metric is sensitive to the source of the metrics, but independent of any instance profile and of the collection time.</li>
<li>This operation is supported only for contexts where the source of the metrics is a host. Further, the instance identifiers are included in the argument to the
function, and the effects upon the current values of the metrics are immediate (retrospective changes are not allowed). Consequently, from the current PMAPI
context, neither the instance profile nor the collection time influence the result of this function.</li>
</ol>
<div class="section" id="pmnewcontext-function">
<h4><a class="toc-backref" href="#id38">3.8.4.1. pmNewContext Function</a><a class="headerlink" href="#pmnewcontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNewContext(int type, const char *name)
</pre></div>
</div>
<p>The <strong>pmNewContext</strong> function may be used to establish a new PMAPI context. The source of metrics is identified by <em>name</em>, and may be a host specification (<em>type</em>
is <strong>PM_CONTEXT_HOST</strong>) or a comma-separated list of names referring to a set of archive logs (<em>type</em> is <strong>PM_CONTEXT_ARCHIVE</strong>). Each element of the list may
either be the base name common to all of the physical files of an archive log or the name of a directory containing archive logs.</p>
<p>A host specification usually contains a simple hostname, an internet address (IPv4 or IPv6), or the path to the PMCD Unix domain socket. It can also specify
properties of the connection to PMCD, such as the protocol to use (secure and encrypted, or native) and whether PMCD should be reached via a <strong>pmproxy</strong> host.
Various other connection attributes, such as authentication information (user name, password, authentication method, and so on) can also be specified. Further
details can be found in the <strong>PCPIntro(3)</strong> man page, and the companion <em>Performance Co-Pilot Tutorials and Case Studies</em> document.</p>
<p>In the case where <em>type</em> is <strong>PM_CONTEXT_ARCHIVE</strong>, there are some restrictions on the archives within the specified set:</p>
<ul class="simple">
<li>The archives must all have been generated on the same host.</li>
<li>The archives must not overlap in time.</li>
<li>The archives must all have been created using the same time zone.</li>
<li>The pmID of each metric should be the same in all of the archives. Multiple pmIDs are currently tolerated by using the first pmID defined for each metric and ignoring subsequent pmIDs.</li>
<li>The type of each metric must be the same in all of the archives.</li>
<li>The semantics of each metric must be the same in all of the archives.</li>
<li>The units of each metric must be the same in all of the archives.</li>
<li>The instance domain of each metric must be the same in all of the archives.</li>
</ul>
<p>In the case where <em>type</em> is <strong>PM_CONTEXT_LOCAL</strong>, <em>name</em> is ignored, and the context uses a stand-alone connection to the PMDA methods used by PMCD. When this
type of context is in effect, the range of accessible performance metrics is constrained to DSO PMDAs listed in the <strong>pmcd</strong> configuration file <code class="docutils literal notranslate"><span class="pre">${PCP_PMCDCONF_PATH}</span></code>.
The reason this is done, as opposed to all of the DSO PMDAs found below <code class="docutils literal notranslate"><span class="pre">${PCP_PMDAS_DIR}</span></code> for example, is that DSO PMDAs listed there are very likely to have
their metric names reflected in the local Name Space file, which will be loaded for this class of context.</p>
<p>The initial instance profile is set up to select all instances in all instance domains, and the initial collection time is the current time at the time of each
request for a host, or the time at the start of the first log for a set of archives. In the case of archives, the initial collection time results in the earliest
set of metrics being returned from the set of archives at the first <strong>pmFetch</strong>.</p>
<p>Once established, the association between a PMAPI context and a source of metrics is fixed for the life of the context; however, functions are provided to
independently manipulate both the instance profile and the collection time components of a context.</p>
<p>The function returns a “handle” that may be used in subsequent calls to <strong>pmUseContext</strong>. This new PMAPI context stays in effect for all subsequent context
sensitive calls across the PMAPI until another call to <strong>pmNewContext</strong> is made, or the context is explicitly changed with a call to <strong>pmDupContext</strong> or
<strong>pmUseContext</strong>.</p>
<p>For the python bindings creating and destroying a PMAPI context is done by creating and destroying an object of the pmapi class.</p>
</div>
<div class="section" id="pmdestroycontext-function">
<h4><a class="toc-backref" href="#id39">3.8.4.2. pmDestroyContext Function</a><a class="headerlink" href="#pmdestroycontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmDestroyContext(int handle)
</pre></div>
</div>
<p>The PMAPI context identified by <em>handle</em> is destroyed. Typically, this implies terminating a connection to PMCD or closing an archive file, and orderly clean-up.
The PMAPI context must have been previously created using <strong>pmNewContext</strong> or <strong>pmDupContext</strong>.</p>
<p>On success, <strong>pmDestroyContext</strong> returns zero. If <em>handle</em> was the current PMAPI context, then the current context becomes undefined. This means the application
must explicitly re-establish a valid PMAPI context with <strong>pmUseContext</strong>, or create a new context with <strong>pmNewContext</strong> or <strong>pmDupContext</strong>, before the next PMAPI
operation requiring a PMAPI context.</p>
<p>For the python bindings creating and destroying a PMAPI context is done by creating and destroying an object of the pmapi class.</p>
</div>
<div class="section" id="pmdupcontext-function">
<h4><a class="toc-backref" href="#id40">3.8.4.3. pmDupContext Function</a><a class="headerlink" href="#pmdupcontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmDupContext(void)
</pre></div>
</div>
<p>Replicate the current PMAPI context (source, instance profile, and collection time). This function returns a handle for the new context, which may be used with
subsequent calls to <strong>pmUseContext</strong>. The newly replicated PMAPI context becomes the current context.</p>
</div>
<div class="section" id="pmusecontext-function">
<h4><a class="toc-backref" href="#id41">3.8.4.4. pmUseContext Function</a><a class="headerlink" href="#pmusecontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmUseContext(int handle)
</pre></div>
</div>
<p>Calling <strong>pmUseContext</strong> causes the current PMAPI context to be set to the context identified by <em>handle</em>. The value of <em>handle</em> must be one returned from an
earlier call to <strong>pmNewContext</strong> or <strong>pmDupContext</strong>.</p>
<p>Below the PMAPI, all contexts used by an application are saved in their most recently modified state, so <strong>pmUseContext</strong> restores the context to the state it was
in the last time the context was used, not the state of the context when it was established.</p>
</div>
<div class="section" id="pmwhichcontext-function">
<h4><a class="toc-backref" href="#id42">3.8.4.5. pmWhichContext Function</a><a class="headerlink" href="#pmwhichcontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmWhichContext(void)
Python:
int ctx_idx = pmWhichContext()
</pre></div>
</div>
<p>Returns the handle for the current PMAPI context (source, instance profile, and collection time).</p>
<p>The python bindings return the handle of the current PMAPI context.</p>
</div>
<div class="section" id="pmaddprofile-function">
<h4><a class="toc-backref" href="#id43">3.8.4.6. pmAddProfile Function</a><a class="headerlink" href="#pmaddprofile-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmAddProfile(pmInDom indom, int numinst, int instlist[])
Python:
int status = pmAddProfile(pmDesc pmdesc, [c_uint instid])
</pre></div>
</div>
<p>Add new instance specifications to the instance profile of the current PMAPI context. At its simplest, instances identified by the <em>instlist</em> argument for the
<em>indom</em> instance domain are added to the instance profile. The list of instance identifiers contains <em>numinst</em> values.</p>
<p>If <em>indom</em> equals <strong>PM_INDOM_NULL</strong>, or <em>numinst</em> is zero, then all instance domains are selected. If <em>instlist</em> is NULL, then all instances are selected. To
enable all available instances in all domains, use this syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pmAddProfile(PM_INDOM_NULL, 0, NULL).
</pre></div>
</div>
<p>The python bindings add the list of instances <em>instid</em> to the instance profile of the instance <em>pmdesc</em>.</p>
</div>
<div class="section" id="pmdelprofile-function">
<h4><a class="toc-backref" href="#id44">3.8.4.7. pmDelProfile Function</a><a class="headerlink" href="#pmdelprofile-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmDelProfile(pmInDom indom, int numinst, int instlist[])
Python:
int status = pmDelProfile(pmDesc pmdesc, c_uint instid)
int status = pmDelProfile(pmDesc pmdesc, [c_uint instid])
</pre></div>
</div>
<p>Delete instance specifications from the instance profile of the current PMAPI context. In the simplest variant, the list of instances identified by the <em>instlist</em>
argument for the <em>indom</em> instance domain is removed from the instance profile. The list of instance identifiers contains <em>numinst</em> values.</p>
<p>If <em>indom</em> equals <strong>PM_INDOM_NULL</strong>, then all instance domains are selected for deletion. If <em>instlist</em> is NULL, then all instances in the selected domains are
removed from the profile. To disable all available instances in all domains, use this syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pmDelProfile(PM_INDOM_NULL, 0, NULL)
</pre></div>
</div>
<p>The python bindings delete the list of instances <em>instid</em> from the instance profile of the instance domain <em>pmdesc</em>.</p>
</div>
<div class="section" id="pmsetmode-function">
<h4><a class="toc-backref" href="#id45">3.8.4.8. pmSetMode Function</a><a class="headerlink" href="#pmsetmode-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmSetMode(int mode, const struct timeval *when, int delta)
Python:
int status = pmSetMode(mode, timeVal timeval, int delta)
</pre></div>
</div>
<p>This function defines the collection time and mode for accessing performance metrics and metadata in the current PMAPI context. This mode affects the semantics of
subsequent calls to the following PMAPI functions: <strong>pmFetch, pmFetchArchive, pmLookupDesc, pmGetInDom, pmLookupInDom</strong> , and <strong>pmNameInDom</strong>.</p>
<p>The <strong>pmSetMode</strong> function requires the current PMAPI context to be of type <strong>PM_CONTEXT_ARCHIVE</strong>.</p>
<p>The <em>when</em> parameter defines a time origin, and all requests for metadata (metrics descriptions and instance identifiers from the instance domains) are processed
to reflect the state of the metadata as of the time origin. For example, use the last state of this information at, or before, the time origin.</p>
<p>If the <em>mode</em> is <strong>PM_MODE_INTERP</strong> then, in the case of <strong>pmFetch</strong>, the underlying code uses an interpolation scheme to compute the values of the metrics from
the values recorded for times in the proximity of the time origin.</p>
<p>If the <em>mode</em> is <strong>PM_MODE_FORW</strong>, then, in the case of <strong>pmFetch</strong>, the collection of recorded metric values is scanned forward, until values for at least one of
the requested metrics is located after the time origin. Then all requested metrics stored in the PCP archive at that time are returned with a corresponding time
stamp. This is the default mode when an archive context is first established with <strong>pmNewContext</strong>.</p>
<p>If the <em>mode</em> is <strong>PM_MODE_BACK</strong>, then the situation is the same as for <strong>PM_MODE_FORW</strong>, except a <strong>pmFetch</strong> is serviced by scanning the collection of recorded
metrics backward for metrics before the time origin.</p>
<p>After each successful <strong>pmFetch</strong>, the time origin is reset to the time stamp returned through the <strong>pmResult</strong>.</p>
<p>The <strong>pmSetMode</strong> parameter <em>delta</em> defines an additional number of time unit that should be used to adjust the time origin (forward or backward) after the new
time origin from the <strong>pmResult</strong> has been determined. This is useful when moving through archives with a mode of <strong>PM_MODE_INTERP</strong>. The high-order bits of the
<em>mode</em> parameter field is also used to optionally set the units of time for the <strong>delta</strong> field. To specify the units of time, use the <strong>PM_XTB_SET</strong> macro with
one of the values <strong>PM_TIME_NSEC, PM_TIME_MSEC, PM_TIME_SEC</strong>, or so on as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PM_MODE_INTERP | PM_XTB_SET(PM_TIME_XXXX)
</pre></div>
</div>
<p>If no units are specified, the default is to interpret <em>delta</em> as milliseconds.</p>
<p>Using these mode options, an application can implement replay, playback, fast forward, or reverse for performance metric values held in a set of PCP archive logs
by alternating calls to <strong>pmSetMode</strong> and <strong>pmFetch</strong>.</p>
<p>In <a class="reference internal" href="#example-3-13-dumping-values-in-temporal-sequence">Example 3.13. Dumping Values in Temporal Sequence</a>, the code fragment may be used to dump only those values stored in correct temporal sequence, for the
specified performance metric <strong>my.metric.name</strong>:</p>
<p id="example-3-13-dumping-values-in-temporal-sequence"><strong>Example 3.13. Dumping Values in Temporal Sequence</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> int     sts;
 pmID    pmid;
 char    *name = “my.metric.name”;

 sts = pmNewContext(PM_CONTEXT_ARCHIVE, “myarchive”);
 sts = pmLookupName(1, &amp;name, &amp;pmid);
 for ( ; ; ) {
     sts = pmFetch(1, &amp;pmid, &amp;result);
     if (sts &lt; 0)
         break;
     /* dump value(s) from result-&gt;vset[0]-&gt;vlist[] */
     pmFreeResult(result);
}
</pre></div>
</div>
<p>Alternatively, the code fragment in <a class="reference internal" href="#example-3-14-replaying-interpolated-metrics">Example 3.14. Replaying Interpolated Metrics</a> may be used to replay interpolated metrics from an archive in reverse
chronological order, at ten-second intervals (of recorded time):</p>
<p id="example-3-14-replaying-interpolated-metrics"><strong>Example 3.14. Replaying Interpolated Metrics</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> int             sts;
 pmID            pmid;
 char            *name = “my.metric.name”;
 struct timeval  endtime;

 sts = pmNewContext(PM_CONTEXT_ARCHIVE, “myarchive”);
 sts = pmLookupName(1, &amp;name, &amp;pmid);
 sts = pmGetArchiveEnd(&amp;endtime);
 sts = pmSetMode(PM_MODE_INTERP, &amp;endtime, -10000);
 while (pmFetch(1, &amp;pmid, &amp;result) != PM_ERR_EOL) {
     /*
      * process interpolated metric values as of result-&gt;timestamp
      */
     pmFreeResult(result);
}
</pre></div>
</div>
<p>The python bindings define the collection <em>time</em> and <em>mode</em> for reading archive files. <em>mode</em> can be one of: c_api.PM_MODE_LIVE, c_api.PM_MODE_INTERP, c_api.FORW,
c_api.BACK. wjocj are available by importing cpmapi.</p>
</div>
<div class="section" id="pmreconnectcontext-function">
<h4><a class="toc-backref" href="#id46">3.8.4.9. pmReconnectContext Function</a><a class="headerlink" href="#pmreconnectcontext-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmReconnectContext(int handle)
Python:
int status = pmReconnectContext()
</pre></div>
</div>
<p>As a result of network, host, or PMCD (Performance Metrics Collection Daemon) failure, an application’s connection to PMCD may be established and then lost.</p>
<p>The function <strong>pmReconnectContext</strong> allows an application to request that the PMAPI context identified by <em>handle</em> be re-established, provided the associated PMCD
is accessible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>handle</em> may or may not be the current context.</p>
</div>
<p>To avoid flooding the system with reconnect requests, <strong>pmReconnectContext</strong> attempts a reconnection only after a suitable delay from the previous attempt. This
imposed restriction on the reconnect re-try time interval uses a default exponential back-off so that the initial delay is 5 seconds after the first unsuccessful
attempt, then 10 seconds, then 20 seconds, then 40 seconds, and then 80 seconds thereafter. The intervals between reconnection attempts may be modified using the
environment variable <strong>PMCD_RECONNECT_TIMEOUT</strong> and the time to wait before an attempted connection is deemed to have failed is controlled by the <strong>PMCD_CONNECT_TIMEOUT</strong>
environment variable; see the <strong>PCPIntro(1)</strong> man page.</p>
<p>If the reconnection succeeds, <strong>pmReconnectContext</strong> returns <em>handle</em>. Note that even in the case of a successful reconnection, <strong>pmReconnectContext</strong> does not
change the current PMAPI context.</p>
<p>The python bindings reestablish the connection for the context.</p>
</div>
<div class="section" id="pmgetcontexthostname-function">
<h4><a class="toc-backref" href="#id47">3.8.4.10. pmGetContextHostName Function</a><a class="headerlink" href="#pmgetcontexthostname-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmGetContextHostName(int id)
char *pmGetContextHostName_r(int id, char *buf, int buflen)
Python:
&quot;hostname&quot; = pmGetContextHostName()
</pre></div>
</div>
<p>Given a valid PCP context identifier previously created with <strong>pmNewContext</strong> or <strong>pmDupContext</strong>, the <strong>pmGetContextHostName</strong> function provides a possibility to
retrieve a host name associated with a context regardless of the context type.</p>
<p>This function will use the <strong>pmcd.hostname</strong> metric if it is available, and so is able to provide an accurate hostname in the presence of connection tunnelling
and port forwarding.</p>
<p>If <em>id</em> is not a valid PCP context identifier, this function returns a zero length string and therefore never fails.</p>
<p>In the case of <strong>pmGetContextHostName</strong>, the string value is held in a single static buffer, so concurrent calls may not produce the desired results. The
<strong>pmGetContextHostName_r</strong> function allows a buffer and length to be passed in, into which the message is stored; this variant uses no shared storage and can be
used in a thread-safe manner.</p>
<p>The python bindings query the current context hostname.</p>
</div>
</div>
<div class="section" id="pmapi-timezone-services">
<h3><a class="toc-backref" href="#id48">3.8.5. PMAPI Timezone Services</a><a class="headerlink" href="#pmapi-timezone-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) timezone services.</p>
<div class="section" id="pmnewcontextzone-function">
<h4><a class="toc-backref" href="#id49">3.8.5.1. pmNewContextZone Function</a><a class="headerlink" href="#pmnewcontextzone-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNewContextZone(void)
Python:
pmNewContextZone()
</pre></div>
</div>
<p>If the current PMAPI context is an archive, the <strong>pmNewContextZone</strong> function uses the timezone from the archive label record in the first archive of the set to
set the current reporting timezone. The current reporting timezone affects the timezone used by <strong>pmCtime</strong> and <strong>pmLocaltime</strong>.</p>
<p>If the current PMAPI context corresponds to a host source of metrics, <strong>pmNewContextZone</strong> executes a <strong>pmFetch</strong> to retrieve the value for the metric <strong>pmcd.timezone</strong>
and uses that to set the current reporting timezone.</p>
<p>In both cases, the function returns a value to identify the current reporting timezone that may be used in a subsequent call to <strong>pmUseZone</strong> to restore this reporting timezone.</p>
<p><strong>PM_ERR_NOCONTEXT</strong> indicates the current PMAPI context is not valid. A return value less than zero indicates a fatal error from a system call, most likely <strong>malloc</strong>.</p>
</div>
<div class="section" id="pmnewzone-function">
<h4><a class="toc-backref" href="#id50">3.8.5.2. pmNewZone Function</a><a class="headerlink" href="#pmnewzone-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNewZone(const char *tz)
Python:
int tz_handle = pmNewZone(int tz)
</pre></div>
</div>
<p>The <strong>pmNewZone</strong> function sets the current reporting timezone, and returns a value that may be used in a subsequent call to <strong>pmUseZone</strong> to restore this
reporting timezone. The current reporting timezone affects the timezone used by <strong>pmCtime</strong> and <strong>pmLocaltime</strong>.</p>
<p>The <em>tz</em> argument defines a timezone string, in the format described for the <strong>TZ</strong> environment variable. See the <strong>environ(7)</strong> man page.</p>
<p>A return value less than zero indicates a fatal error from a system call, most likely <strong>malloc</strong>.</p>
<p>The python bindings create a new zone handle and set reporting timezone for the timezone defined by <em>tz</em>.</p>
</div>
<div class="section" id="pmusezone-function">
<h4><a class="toc-backref" href="#id51">3.8.5.3. pmUseZone Function</a><a class="headerlink" href="#pmusezone-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmUseZone(const int tz_handle)
Python:
int status = pmUseZone(int tz_handle)
</pre></div>
</div>
<p>In the <strong>pmUseZone</strong> function, <em>tz_handle</em> identifies a reporting timezone as previously established by a call to <strong>pmNewZone</strong> or <strong>pmNewContextZone</strong>, and this
becomes the current reporting timezone. The current reporting timezone effects the timezone used by <strong>pmCtime</strong> and <strong>pmLocaltime</strong>).</p>
<p>A return value less than zero indicates the value of <em>tz_handle</em> is not legal.</p>
<p>The python bindings set the current reporting timezone defined by timezone <em>tz_handle</em>.</p>
</div>
<div class="section" id="pmwhichzone-function">
<h4><a class="toc-backref" href="#id52">3.8.5.4. pmWhichZone Function</a><a class="headerlink" href="#pmwhichzone-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmWhichZone(char **tz)
Python:
&quot;zone string&quot; = pmWhichZone()
</pre></div>
</div>
<p>The <strong>pmWhichZone</strong> function returns the handle of the current timezone, as previously established by a call to <strong>pmNewZone</strong> or <strong>pmNewContextZone</strong>. If the call
is successful (that is, there exists a current reporting timezone), a non-negative integer is returned and tz is set to point to a static buffer containing the
timezone string itself. The current reporting timezone effects the timezone used by <strong>pmCtime</strong> and <strong>pmLocaltime</strong>.</p>
<p>A return value less than zero indicates there is no current reporting timezone.</p>
<p>The python bindings return the current reporting timezone.</p>
</div>
</div>
<div class="section" id="pmapi-metrics-services">
<h3><a class="toc-backref" href="#id53">3.8.6. PMAPI Metrics Services</a><a class="headerlink" href="#pmapi-metrics-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metrics services.</p>
<div class="section" id="pmfetch-function">
<h4><a class="toc-backref" href="#id54">3.8.6.1. pmFetch Function</a><a class="headerlink" href="#pmfetch-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmFetch(int numpmid, pmID pmidlist[], pmResult **result)
Python:
pmResult* pmresult = pmFetch(c_uint pmid[])
</pre></div>
</div>
<p>The most common PMAPI operation is likely to be calls to <strong>pmFetch</strong>, specifying a list of PMIDs (for example, as constructed by <strong>pmLookupName</strong>) through <em>pmidlist</em>
and <em>numpmid</em>. The call to <strong>pmFetch</strong> is executed in the context of a source of metrics, instance profile, and collection time, previously established by calls to
the functions described in Section 3.8.4, “<a class="reference internal" href="#pmapi-context-services">PMAPI Context Services</a>”.</p>
<p>The principal result from <strong>pmFetch</strong> is returned as a tree structured <em>result</em>, described in the Section 3.5, “<a class="reference internal" href="#performance-metrics-values">Performance Metrics Values</a>”.</p>
<p>If one value (for example, associated with a particular instance) for a requested metric is unavailable at the requested time, then there is no associated <strong>pmValue</strong>
structure in the result. If there are no available values for a metric, then <em>numval</em> is zero and the associated <strong>pmValue[]</strong> instance is empty; <em>valfmt</em> is
undefined in these circumstances, but <em>pmid</em> is correctly set to the PMID of the metric with no values.</p>
<p>If the source of the performance metrics is able to provide a reason why no values are available for a particular metric, this reason is encoded as a standard
error code in the corresponding <em>numval</em>; see the <strong>pmerr(1)</strong> and <strong>pmErrStr(3)</strong> man pages. Since all error codes are negative, values for a requested metric
are unavailable if <em>numval</em> is less than or equal to zero.</p>
<p>The argument definition and the result specifications have been constructed to ensure that for each PMID in the requested <em>pmidlist</em> there is exactly one
<strong>pmValueSet</strong> in the result, and that the PMIDs appear in exactly the same sequence in both <em>pmidlist</em> and <em>result</em>. This makes the number and order of entries
in <em>result</em> completely deterministic, and greatly simplifies the application programming logic after the call to <strong>pmFetch</strong>.</p>
<p>The result structure returned by <strong>pmFetch</strong> is dynamically allocated using one or more calls to <strong>malloc</strong> and specialized allocation strategies, and should be
released when no longer required by calling <strong>pmFreeResult</strong>. Under no circumstances should <strong>free</strong> be called directly to release this space.</p>
<p>As common error conditions are encoded in the result data structure, only serious events (such as loss of connection to PMCD, <strong>malloc</strong> failure, and so on) would
cause an error value to be returned by <strong>pmFetch</strong>. Otherwise, the value returned by the <strong>pmFetch</strong> function is zero.</p>
<p>In <a class="reference internal" href="#example-3-15-pmapi-metrics-services">Example 3.15. PMAPI Metrics Services</a>, the code fragment dumps the values (assumed to be stored in the <em>lval</em> element of the <strong>pmValue</strong> structure) of
selected performance metrics once every 10 seconds:</p>
<p id="example-3-15-pmapi-metrics-services"><strong>Example 3.15. PMAPI Metrics Services</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int       i, j, sts;
pmID      pmidlist[10];
pmResult  *result;
time_t    now;

/* set up PMAPI context, numpmid and pmidlist[] ... */
while ((sts = pmFetch(10, pmidlist, &amp;result)) &gt;= 0) {
    now = (time_t)result-&gt;timestamp.tv_sec;
    printf(&quot;\n@ %s&quot;, ctime(&amp;now));
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        printf(&quot;PMID: %s&quot;, pmIDStr(result-&gt;vset[i]-&gt;pmid));
        for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
            printf(&quot; 0x%x&quot;, result-&gt;vset[i]-&gt;vlist[j].value.lval);
            putchar(&#39;\n&#39;);
        }
    }
    pmFreeResult(result);
    sleep(10);
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a response is not received back from PMCD within 10 seconds, the <strong>pmFetch</strong> times out and returns <strong>PM_ERR_TIMEOUT</strong>. This is most likely to occur when the
PMAPI client and PMCD are communicating over a slow network connection, but may also occur when one of the hosts is extremely busy. The time out period may be
modified using the <strong>PMCD_REQUEST_TIMEOUT</strong> environment variable; see the <strong>PCPIntro(1)</strong> man page.</p>
</div>
<p>The python bindings fetch a pmResult corresponding to a <em>pmid</em> list, which is returned from <strong>pmLookupName</strong>. The returned <em>pmresult</em> is passed to <strong>pmExtractValue</strong>.</p>
</div>
<div class="section" id="pmfreeresult-function">
<h4><a class="toc-backref" href="#id55">3.8.6.2. pmFreeResult Function</a><a class="headerlink" href="#pmfreeresult-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pmFreeResult(pmResult *result)
Python:
pmFreeResult(pmResult* pmresult)
</pre></div>
</div>
<p>Release the storage previously allocated for a result by <strong>pmFetch</strong>.</p>
<p>THe python bindings free a <em>pmresult</em> previously allocated by <strong>pmFetch</strong>.</p>
</div>
<div class="section" id="pmstore-function">
<h4><a class="toc-backref" href="#id56">3.8.6.3. pmStore Function</a><a class="headerlink" href="#pmstore-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmStore(const pmResult *request)
Python:
pmResult* pmresult = pmStore(pmResult* pmresult)
</pre></div>
</div>
<p>In some special cases it may be helpful to modify the current values of performance metrics in one or more underlying domains, for example to reset a counter to
zero, or to modify a <em>metric</em>, which is a control variable within a Performance Metric Domain.</p>
<p>The <strong>pmStore</strong> function is a lightweight inverse of <strong>pmFetch</strong>. The caller must build the <strong>pmResult</strong> data structure (which could have been returned from an
earlier <strong>pmFetch</strong> call) and then call <strong>pmStore</strong>. It is an error to pass a <em>request</em> to <strong>pmStore</strong> in which the <strong>numval</strong> field within any of the <strong>pmValueSet</strong>
structure has a value less than one.</p>
<p>The current PMAPI context must be one with a host as the source of metrics, and the current value of the nominated metrics is changed. For example, <strong>pmStore</strong>
cannot be used to make retrospective changes to information in a PCP archive log.</p>
</div>
</div>
<div class="section" id="pmapi-fetchgroup-services">
<h3><a class="toc-backref" href="#id57">3.8.7. PMAPI Fetchgroup Services</a><a class="headerlink" href="#pmapi-fetchgroup-services" title="Permalink to this headline">¶</a></h3>
<p>The fetchgroup functions implement a registration-based mechanism to fetch groups of performance metrics, including automation for general unit, rate, type
conversions and convenient instance and value encodings. They constitute a powerful and compact alternative to the classic Performance Metrics Application
Programming Interface (PMAPI) sequence of separate lookup, check, fetch, iterate, extract, and convert functions.</p>
<p>A fetchgroup consists of a PMAPI context and a list of metrics that the application is interested in fetching. For each metric of interest, a conversion
specification and a destination <strong>pmAtomValue</strong> pointer is given. Then, at each subsequent fetchgroup-fetch operation, all metrics are fetched, decoded/converted,
and deposited in the desired field of the destination <strong>pmAtomValues</strong>. See <a class="reference internal" href="#example-3-18-pmatomvalue-structure">Example 3.18. pmAtomValue Structure</a> for more on that data type. Similarly, a
per-metric-instance status value is optionally available for detailed diagnostics reflecting fetch/conversion.</p>
<p>The <strong>pmfetchgroup(3)</strong> man pages give detailed information on the C API; we only list some common cases here. The simplified Python binding to the same API is
summarized below. One difference is that runtime errors in C are represented by status integers, but in Python are mapped to <strong>pmErr</strong> exceptions. Another is that
supplying metric type codes are mandatory in the C API but optional in Python, since the latter language supports dynamic typing. Another difference is Python’s
wrapping of output metric values in callable “holder” objects. We demonstrate all of these below.</p>
<div class="section" id="fetchgroup-setup">
<h4><a class="toc-backref" href="#id58">3.8.7.1. Fetchgroup setup</a><a class="headerlink" href="#fetchgroup-setup" title="Permalink to this headline">¶</a></h4>
<p>To create a fetchgroup and its private PMAPI context, the <strong>pmCreateFetchGroup</strong> function is used, with parameters similar to <strong>pmNewContext</strong>
(see Section 3.8.4.1, “<a class="reference internal" href="#pmnewcontext-function">pmNewContext Function</a>”).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sts;
pmFG fg;
sts = pmCreateFetchGroup(&amp; fg, PM_CONTEXT_ARCHIVE, &quot;./foo.meta&quot;);
assert(sts == 0);
Python
fg = pmapi.fetchgroup(c_api.PM_CONTEXT_ARCHIVE, &#39;./foo.meta&#39;)
</pre></div>
</div>
<p>If special PMAPI query, PMNS enumeration, or configuration upon the context is needed, the private context may be carefully accessed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ctx = pmGetFetchGroupContext(fg);
sts = pmUseContext(ctx);
assert(sts == 0);
sts = pmSetMode(...);
Python
ctx = fg.get_context()
ctx.pmSetMode(...)
</pre></div>
</div>
<p>A fetchgroup is born empty. It needs to be extended with metrics to read. Scalars are easy. We specify the metric name, an instance-domain instance if necessary,
a unit-scaling and/or rate-conversion directive if desired, and a type code (see <a class="reference internal" href="#example-3-2-pmdesc-structure">Example 3.2. pmDesc Structure</a>). In C, the value destination is specified by
pointer. In Python, a value-holder is returned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static pmAtomValue ncpu, loadavg, idle;
sts = pmExtendFetchGroup_item(fg, &quot;hinv.ncpu&quot;, NULL, NULL,
                              &amp; ncpu, PM_TYPE_32, NULL);
assert (sts == 0);
sts = pmExtendFetchGroup_item(fg, &quot;kernel.all.load&quot;, &quot;5 minute&quot;, NULL,
                              &amp; loadavg, PM_TYPE_DOUBLE, NULL);
assert (sts == 0);
sts = pmExtendFetchGroup_item(fg, &quot;kernel.all.cpu.idle&quot;, NULL, &quot;s/100s&quot;,
                              &amp; idle, PM_TYPE_STRING, NULL);
assert (sts == 0);
Python
ncpu = fg.extend_item(&#39;hinv.cpu&#39;)
loadavg = fg.extend_item(&#39;kernel.all.load&#39;, instance=&#39;5 minute&#39;)
idle = fg.extend_item(&#39;kernel.all.cpu.idle, scale=&#39;s/100s&#39;)
</pre></div>
</div>
<p>Registering metrics with whole instance domains are also possible; these result in a vector of <strong>pmAtomValue</strong> instances, instance names and codes, and status
codes, so the fetchgroup functions take more optional parameters. In Python, a value-holder-iterator object is returned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum { max_disks = 100 };
static unsigned num_disks;
static pmAtomValue disk_reads[max_disks];
static int disk_read_stss[max_disks];
static char *disk_names[max_disks];
sts = pmExtendFetchGroup_indom(fg, &quot;disk.dm.read&quot;, NULL,
                               NULL, disk_names, disk_reads, PM_TYPE_32,
                               disk_read_stss, max_disks, &amp; num_disks,
                               NULL);
Python
values = fg.extend_indom(&#39;disk.dm.read&#39;)
</pre></div>
</div>
<p>Registering interest in the future fetch-operation timestamp is also possible. In python, a datetime-holder object is returned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct timeval tv;
sts = pmExtendFetchGroup_timestamp(fg, &amp; tv);
Python
tv = fg.extend_timestamp()
</pre></div>
</div>
</div>
<div class="section" id="fetchgroup-operation">
<h4><a class="toc-backref" href="#id59">3.8.7.2. Fetchgroup operation</a><a class="headerlink" href="#fetchgroup-operation" title="Permalink to this headline">¶</a></h4>
<p>Now it’s time for the program to process the metrics. In the C API, each metric value is put into status integers (if requested), and one field of the <strong>pmAtomValue</strong>
union - whichever was requested with the <strong>PM_TYPE_*</strong> code. In the Python API, each metric value is accessed by calling the value-holder objects.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sts = pmFetchGroup(fg);
assert (sts == 0);
printf(&quot;%s&quot;, ctime(&amp; tv.tv_sec));
printf(&quot;#cpus: %d, loadavg: %g, idle: %s\n&quot;, ncpu.l, loadavg.d, idle.cp);
for (i=0; i&lt;num_disks; i++)
    if (disk_read_stss[i] == 0)
        printf(&quot;disk %s reads %d\n&quot;, disk_names[i], disk_reads[i].l);
Python
fg.fetch()
print(tv())
print(&quot;#cpus: %d, loadavg: %g, idle: %d\n&quot; % (ncpu(), loadavg(), idle()))
for icode, iname, value in values():
    print(&#39;disk %s reads %d&#39; % (iname, value()))
</pre></div>
</div>
<p>The program may fetch and process the values only once, or in a loop. The program need not - <em>must not</em> - modify or free any of the output values/pointers supplied
by the fetchgroup functions.</p>
</div>
<div class="section" id="fetchgroup-shutdown">
<h4><a class="toc-backref" href="#id60">3.8.7.3. Fetchgroup shutdown</a><a class="headerlink" href="#fetchgroup-shutdown" title="Permalink to this headline">¶</a></h4>
<p>Should the program wish to shut down a fetchgroup explicitly, thereby closing the private PMAPI context, there is a function for that.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sts = pmDestroyFetchGroup(fg);
Python
del fg # or nothing
</pre></div>
</div>
</div>
</div>
<div class="section" id="pmapi-record-mode-services">
<h3><a class="toc-backref" href="#id61">3.8.8. PMAPI Record-Mode Services</a><a class="headerlink" href="#pmapi-record-mode-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) record-mode services. These services allow a monitor
tool to establish connections to <strong>pmlogger</strong> co-processes, which they create and control for the purposes of recording live performance data from (possibly)
multiple hosts. Since <strong>pmlogger</strong> records for one host only, these services can administer a group of loggers, and set up archive folios to track the logs. Tools
like <strong>pmafm</strong> can subsequently use those folios to replay recorded data with the initiating tool. <strong>pmchart</strong> uses these concepts when providing its Record mode
functionality.</p>
<div class="section" id="pmrecordaddhost-function">
<h4><a class="toc-backref" href="#id62">3.8.8.1. pmRecordAddHost Function</a><a class="headerlink" href="#pmrecordaddhost-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmRecordAddHost(const char *host, int isdefault, pmRecordHost **rhp)
Python:
(int status, pmRecordHost* rhp) = pmRecordAddHost(&quot;host string&quot;, 1, &quot;configure string&quot;)
</pre></div>
</div>
<p>The <strong>pmRecordAddHost</strong> function adds hosts once <strong>pmRecordSetup</strong> has established a new recording session. The <strong>pmRecordAddHost</strong> function along with the
<strong>pmRecordSetup</strong> and <strong>pmRecordControl</strong> functions are used to create a PCP archive.</p>
<p><strong>pmRecordAddHost</strong> is called for each host that is to be included in the recording session. A new <strong>pmRecordHost</strong> structure is returned via <em>rhp</em>. It is assumed
that PMCD is running on the host as this is how <strong>pmlogger</strong> retrieves the required performance metrics.</p>
<p>If this host is the default host for the recording session, <em>isdefault</em> is nonzero. This ensures that the corresponding archive appears first in the PCP archive
<em>folio</em>. Hence the tools used to replay the archive <em>folio</em> make the correct determination of the archive associated with the default host. At most one host per
recording session may be nominated as the default host.</p>
<p>The calling application writes the desired <strong>pmlogger</strong> configuration onto the stdio stream returned via the <strong>f_config</strong> field in the <strong>pmRecordHost</strong> structure.</p>
<p><strong>pmRecordAddHost</strong> returns 0 on success and a value less than 0 suitable for decoding with <strong>pmErrStr</strong> on failure. The value <strong>EINVAL</strong> has the same
interpretation as <strong>errno</strong> being set to <strong>EINVAL</strong>.</p>
</div>
<div class="section" id="pmrecordcontrol-function">
<h4><a class="toc-backref" href="#id63">3.8.8.2. pmRecordControl Function</a><a class="headerlink" href="#pmrecordcontrol-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmRecordControl(pmRecordHost *rhp, int request, const char *options)
Python:
int status = pmRecordControl(&quot;host string&quot;, 1, &quot;configure string&quot;)
</pre></div>
</div>
<p>Arguments may be optionally added to the command line that is used to launch <strong>pmlogger</strong> by calling the <strong>pmRecordControl</strong> function with a request of
<strong>PM_REC_SETARG</strong>. The <strong>pmRecordControl</strong> along with the <strong>pmRecordSetup</strong> and <strong>pmRecordAddHost</strong> functions are used to create a PCP archive.</p>
<p>The argument is passed via <em>options</em> and one call to <strong>pmRecordControl</strong> is required for each distinct argument. An argument may be added for a particular <strong>pmlogger</strong>
instance identified by <em>rhp</em>. If the <em>rhp</em> argument is NULL, the argument is added for all <strong>pmlogger</strong> instances that are launched in the current recording session.</p>
<p>Independent of any calls to <strong>pmRecordControl</strong> with a request of <strong>PM_REC_SETARG</strong>, each <strong>pmlogger</strong> instance is automatically launched with the following arguments:
<strong>-c, -h, -l, -x</strong>, and the basename for the PCP archive log.</p>
<p>To commence the recording session, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_ON</strong>, and <em>rhp</em> must be NULL. This launches one <strong>pmlogger</strong> process for each
host in the recording session and initializes the <strong>fd_ipc, logfile, pid</strong>, and <strong>status</strong> fields in the associated <strong>pmRecordHost</strong> structure(s).</p>
<p>To terminate a <strong>pmlogger</strong> instance identified by <em>rhp</em>, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_OFF</strong>. If the rhp argument to <strong>pmRecordControl</strong> is
NULL, the termination request is broadcast to all <strong>pmlogger</strong> processes in the current recording session. An informative dialogue is generated directly by each
<strong>pmlogger</strong> process.</p>
<p>To display the current status of the <strong>pmlogger</strong> instance identified by <em>rhp</em>, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_STATUS</strong>. If the <em>rhp</em>
argument to <strong>pmRecordControl</strong> is NULL, the status request is broadcast to all <strong>pmlogger</strong> processes in the current recording session. The display is generated
directly by each <strong>pmlogger</strong> process.</p>
<p>To detach a <strong>pmlogger</strong> instance identified by <em>rhp</em>, allow it to continue independent of the application that launched the recording session and call
<strong>pmRecordControl</strong> with a request of <strong>PM_REC_DETACH</strong>. If the <em>rhp</em> argument to <strong>pmRecordControl</strong> is NULL, the detach request is broadcast to all <strong>pmlogger</strong>
processes in the current recording session.</p>
<p><strong>pmRecordControl</strong> returns 0 on success and a value less than 0 suitable for decoding with <strong>pmErrStr</strong> on failure. The value <strong>EINVAL</strong> has the same
interpretation as <strong>errno</strong> being set to <strong>EINVAL</strong>.</p>
<p><strong>pmRecordControl</strong> returns <strong>PM_ERR_IPC</strong> if the associated <strong>pmlogger</strong> process has already exited.</p>
</div>
<div class="section" id="pmrecordsetup-function">
<h4><a class="toc-backref" href="#id64">3.8.8.3. pmRecordSetup Function</a><a class="headerlink" href="#pmrecordsetup-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FILE *pmRecordSetup(const char *folio, const char *creator, int replay)
Python:
int status = pmRecordSetup(&quot;folio string&quot;, &quot;creator string&quot;, int replay)
</pre></div>
</div>
<p>The <strong>pmRecordSetup</strong> function along with the <strong>pmRecordAddHost</strong> and <strong>pmRecordControl</strong> functions may be used to create a PCP archive on the fly to support
record-mode services for PMAPI client applications.</p>
<p>Each record mode session involves one or more PCP archive logs; each is created using a dedicated <strong>pmlogger</strong> process, with an overall Archive Folio format as
understood by the <strong>pmafm</strong> command, to name and collect all of the archive logs associated with a single recording session.</p>
<p>The <strong>pmRecordHost</strong> structure is used to maintain state information between the creator of the recording session and the associated <strong>pmlogger</strong> process(es).
The structure, shown in <a class="reference internal" href="#example-3-16-pmrecordhost-structure">Example 3.16. pmRecordHost Structure</a>, is defined as:</p>
<p id="example-3-16-pmrecordhost-structure"><strong>Example 3.16. pmRecordHost Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    FILE   *f_config;    /* caller writes pmlogger configuration here */
    int    fd_ipc;       /* IPC channel to pmlogger */
    char   *logfile;     /* full pathname for pmlogger error logfile */
    pid_t  pid;          /* process id for pmlogger */
    int    status;       /* exit status, -1 if unknown */
} pmRecordHost;
</pre></div>
</div>
<p>In <a class="reference internal" href="#procedure-3-1-creating-a-recording-session">Procedure 3.1. Creating a Recording Session</a>, the functions are used in combination to create a recording session.</p>
<p id="procedure-3-1-creating-a-recording-session"><strong>Procedure 3.1. Creating a Recording Session</strong></p>
<ol class="arabic simple">
<li>Call <strong>pmRecordSetup</strong> to establish a new recording session. A new Archive Folio is created using the name <em>folio</em>. If the <em>folio</em> file or directory already
exists, or if it cannot be created, this is an error. The application that is creating the session is identified by creator (most often this would be the same
as the global PMAPI application name, as returned <strong>pmGetProgname()</strong>). If the application knows how to create its own configuration file to replay the recorded
session, replay should be nonzero. The <strong>pmRecordSetup</strong> function returns a stdio stream onto which the application writes the text of any required replay
configuration file.</li>
<li>For each host that is to be included in the recording session, call <strong>pmRecordAddHost</strong>. A new <strong>pmRecordHost</strong> structure is returned via <em>rhp</em>. It is assumed
that PMCD is running on the host as this is how <strong>pmlogger</strong> retrieves the required performance metrics. See Section 3.8.8.1, “<a class="reference internal" href="#pmrecordaddhost-function">pmRecordAddHost Function</a>”
for more information.</li>
<li>Optionally, add arguments to the command line that is used to launch <strong>pmlogger</strong> by calling <strong>pmRecordControl</strong> with a request of <strong>PM_REC_SETARG</strong>.
The argument is passed via options and one call to <strong>pmRecordControl</strong> is required for each distinct argument. See Section 3.8.8.2, “<a class="reference internal" href="#pmrecordcontrol-function">pmRecordControl Function</a>”
for more information.</li>
<li>To commence the recording session, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_ON</strong>, and <em>rhp</em> must be NULL.</li>
<li>To terminate a <strong>pmlogger</strong> instance identified by <em>rhp</em>, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_OFF</strong>.</li>
<li>To display the current status of the <strong>pmlogger</strong> instance identified by <em>rhp</em>, call <strong>pmRecordControl</strong> with a request of <strong>PM_REC_STATUS</strong>.</li>
<li>To detach a <strong>pmlogger</strong> instance identified by <em>rhp</em>, allow it to continue independent of the application that launched the recording session, call
<strong>pmRecordControl</strong> with a request of <strong>PM_REC_DETACH</strong>.</li>
</ol>
<p>The calling application should not close any of the returned stdio streams; <strong>pmRecordControl</strong> performs this task when recording is commenced.</p>
<p>Once <strong>pmlogger</strong> has been started for a recording session, <strong>pmlogger</strong> assumes responsibility for any dialogue with the user in the event that the application
that launched the recording session should exit, particularly without terminating the recording session.</p>
<p>By default, information and dialogues from <strong>pmlogger</strong> is displayed using <strong>pmconfirm</strong>. This default is based on the assumption that most applications launching
a recording session are GUI-based. In the event that <strong>pmconfirm</strong> fails to display the information (for example, because the <strong>DISPLAY</strong> environment variable is
not set), <strong>pmlogger</strong> writes on its own stderr stream (not the stderr stream of the launching process). The output is assigned to the <strong>xxxxxx.host.log</strong> file.
For convenience, the full pathname to this file is provided via the <strong>logfile</strong> field in the <strong>pmRecordHost</strong> structure.</p>
<p>If the <em>options</em> argument to <strong>pmRecordControl</strong> is not NULL, this string may be used to pass additional arguments to <strong>pmconfirm</strong> in those cases where a
dialogue is to be displayed. One use of this capability is to provide a -geometry string to control the placement of the dialogue.</p>
<p>Premature termination of a launched <strong>pmlogger</strong> process may be determined using the <strong>pmRecordHost</strong> structure, by calling <strong>select</strong> on the <strong>fd_ipc</strong>
field or polling the <strong>status</strong> field that will contain the termination status from <strong>waitpid</strong> if known, or -1.</p>
<p>These functions create a number of files in the same directory as the <em>folio</em> file named in the call to <strong>pmRecordSetup</strong>. In all cases, the <em>xxxxxx</em> component is
the result of calling <strong>mkstemp</strong>.</p>
<ul>
<li><p class="first">If replay is nonzero, <em>xxxxxx</em> is the creator’s replay configuration file, else an empty control file, used to guarantee uniqueness.</p>
</li>
<li><p class="first">The <em>folio</em> file is the PCP Archive Folio, suitable for use with the <strong>pmafm</strong> command.</p>
</li>
<li><p class="first">The <strong>xxxxxx.host.config</strong> file is the <strong>pmlogger</strong> configuration for each host. If the same host is used in different calls to <strong>pmRecordAddHost</strong> within the
same recording session, one of the letters ‘a’ through ‘z’ is appended to the <em>xxxxxx</em> part of all associated file names to ensure uniqueness.</p>
<blockquote>
<div><p><strong>xxxxxx.host.log</strong> is stdout and stderr for the <strong>pmlogger</strong> instance for each host.</p>
</div></blockquote>
</li>
<li><p class="first">The <strong>xxxxxx.host.{0,meta,index}</strong> files comprise a single PCP archive for each host.</p>
</li>
</ul>
<p><strong>pmRecordSetup</strong> may return NULL in the event of an error. Check <strong>errno</strong> for the real cause. The value <strong>EINVAL</strong> typically means that the order of calls to
these functions is not correct; that is, there is an obvious state associated with the current recording session that is maintained across calls to the functions.</p>
<p>For example, calling <strong>pmRecordControl</strong> before calling <strong>pmRecordAddHost</strong> at least once, or calling <strong>pmRecordAddHost</strong> before calling <strong>pmRecordSetup</strong> would
produce an <strong>EINVAL</strong> error.</p>
</div>
</div>
<div class="section" id="pmapi-archive-specific-services">
<h3><a class="toc-backref" href="#id65">3.8.9. PMAPI Archive-Specific Services</a><a class="headerlink" href="#pmapi-archive-specific-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide archive-specific services.</p>
<div class="section" id="pmgetarchivelabel-function">
<h4><a class="toc-backref" href="#id66">3.8.9.1. pmGetArchiveLabel Function</a><a class="headerlink" href="#pmgetarchivelabel-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetArchiveLabel(pmLogLabel *lp)
Python:
pmLogLabel loglabel = pmGetArchiveLabel()
</pre></div>
</div>
<p>Provided the current PMAPI context is associated with a set of PCP archive logs, the <strong>pmGetArchiveLabel</strong> function may be used to fetch the label record from the
first archive in the set of archives. The structure returned through <em>lp</em> is as shown in <a class="reference internal" href="#example-3-17-pmloglabel-structure">Example 3.17. pmLogLabel Structure</a>:</p>
<p id="example-3-17-pmloglabel-structure"><strong>Example 3.17. pmLogLabel Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Label Record at the start of every log file - as exported above the PMAPI ...
 */
#define PM_TZ_MAXLEN    40
#define PM_LOG_MAXHOSTLEN   64
#define PM_LOG_MAGIC    0x50052600
#define PM_LOG_VERS01   0x1
#define PM_LOG_VERS02   0x2
#define PM_LOG_VOL_TI   -2      /* temporal index */
#define PM_LOG_VOL_META -1      /* meta data */
typedef struct {
    int            ll_magic;          /* PM_LOG_MAGIC | log format version no. */
    pid_t          ll_pid;            /* PID of logger */
    struct timeval ll_start;          /* start of this log */
    char           ll_hostname[PM_LOG_MAXHOSTLEN]; /* name of collection host */
    char           ll_tz[PM_TZ_MAXLEN];            /* $TZ at collection host */
} pmLogLabel;
</pre></div>
</div>
<p>The python bindings get the label record from the archive.</p>
</div>
<div class="section" id="pmgetarchiveend-function">
<h4><a class="toc-backref" href="#id67">3.8.9.2. pmGetArchiveEnd Function</a><a class="headerlink" href="#pmgetarchiveend-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetArchiveEnd(struct timeval *tvp)
Python:
timeval tv = status = pmGetArchiveEnd()
</pre></div>
</div>
<p>Provided the current PMAPI context is associated with a set of PCP archive logs, <strong>pmGetArchiveEnd</strong> finds the logical end of the last archive file in the set
(after the last complete record in the archive), and returns the last recorded time stamp with <em>tvp</em>. This timestamp may be passed to <strong>pmSetMode</strong> to reliably
position the context at the last valid log record, for example, in preparation for subsequent reading in reverse chronological order.</p>
<p>For archive logs that are not concurrently being written, the physical end of file and the logical end of file are co-incident. However, if an archive log is
being written by <strong>pmlogger</strong> at the same time that an application is trying to read the archive, the logical end of file may be before the physical end of file
due to write buffering that is not aligned with the logical record boundaries.</p>
<p>The python bindings get the last recorded timestamp from the archive.</p>
</div>
<div class="section" id="pmgetindomarchive-function">
<h4><a class="toc-backref" href="#id68">3.8.9.3. pmGetInDomArchive Function</a><a class="headerlink" href="#pmgetindomarchive-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmGetInDomArchive(pmInDom indom, int **instlist, char ***namelist )
Python:
((instance1, instance2...) (name1, name2...)) pmGetInDom(pmDesc pmdesc)
</pre></div>
</div>
<p>Provided the current PMAPI context is associated with a set of PCP archive logs, <strong>pmGetInDomArchive</strong> scans the metadata to generate the union of all instances
for the instance domain <em>indom</em> that can be found in the set of archive logs, and returns through <em>instlist</em> the internal instance identifiers, and through <em>namelist</em>
the full external identifiers.</p>
<p>This function is a specialized version of the more general PMAPI function <strong>pmGetInDom</strong>.</p>
<p>The function returns the number of instances found (a value less than zero indicates an error).</p>
<p>The resulting lists of instance identifiers (<em>instlist</em> and <em>namelist</em>), and the names that the elements of <em>namelist</em> point to, are allocated by <strong>pmGetInDomArchive</strong>
with two calls to <strong>malloc</strong>, and it is the responsibility of the caller to use <strong>free**(*instlist*) and **free**(*namelist*) to release the space when it is no
longer required; see the **malloc(3)</strong> and <strong>free(3)</strong> man pages.</p>
<p>When the result of <strong>pmGetInDomArchive</strong> is less than one, both <em>instlist</em> and <em>namelist</em> are undefined (no space is allocated; so calling <strong>free</strong> is a singularly bad idea).</p>
<p>The python bindings return a tuple of the instance IDs and names for the union of all instances for the instance domain <em>pmdesc</em> that can be found in the archive log.</p>
</div>
<div class="section" id="pmlookupindomarchive-function">
<h4><a class="toc-backref" href="#id69">3.8.9.4. pmLookupInDomArchive Function</a><a class="headerlink" href="#pmlookupindomarchive-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmLookupInDomArchive(pmInDom indom, const char *name)
Python:
c_uint instid = pmLookupInDomArchive(pmDesc pmdesc, &quot;Instance&quot;)
</pre></div>
</div>
<p>Provided the current PMAPI context is associated with a set of PCP archive logs, <strong>pmLookupInDomArchive</strong> scans the metadata for the instance domain <em>indom</em>,
locates the first instance with the external identification given by <em>name</em>, and returns the internal instance identifier.</p>
<p>This function is a specialized version of the more general PMAPI function <strong>pmLookupInDom</strong>.</p>
<p>The <strong>pmLookupInDomArchive</strong> function returns a positive instance identifier on success.</p>
<p>The python bindings return the instance id in <em>pmdesc</em> corresponding to <em>Instance</em>.</p>
</div>
<div class="section" id="pmnameindomarchive-function">
<h4><a class="toc-backref" href="#id70">3.8.9.5. pmNameInDomArchive Function</a><a class="headerlink" href="#pmnameindomarchive-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmNameInDomArchive(pmInDom indom, int inst, char **name)
Python:
&quot;instance id&quot; = pmNameInDomArchive(pmDesc pmdesc, c_uint instid)
</pre></div>
</div>
<p>Provided the current PMAPI context is associated with a set of PCP archive logs, <strong>pmNameInDomArchive</strong> scans the metadata for the instance domain <em>indom</em>,
locates the first instance with the internal instance identifier given by <strong>inst</strong>, and returns the full external instance identification through <em>name</em>. This
function is a specialized version of the more general PMAPI function <strong>pmNameInDom</strong>.</p>
<p>The space for the value of <em>name</em> is allocated in <strong>pmNameInDomArchive</strong> with <strong>malloc</strong>, and it is the responsibility of the caller to free the space when it is
no longer required; see the <strong>malloc(3)</strong> and <strong>free(3)</strong> man pages.</p>
<p>The python bindings return the text name of an instance corresponding to an instance domain <em>pmdesc</em> with instance identifier <em>instid</em>.</p>
</div>
<div class="section" id="pmfetcharchive-function">
<h4><a class="toc-backref" href="#id71">3.8.9.6. pmFetchArchive Function</a><a class="headerlink" href="#pmfetcharchive-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmFetchArchive(pmResult **result)
Python:
pmResult* pmresult = pmFetchArchive()
</pre></div>
</div>
<p>This is a variant of <strong>pmFetch</strong> that may be used only when the current PMAPI context is associated with a set of PCP archive logs. The <em>result</em> is instantiated
with all of the metrics (and instances) from the next archive record; consequently, there is no notion of a list of desired metrics, and the instance profile is
ignored.</p>
<p>It is expected that <strong>pmFetchArchive</strong> would be used to create utilities that scan archive logs (for example, <strong>pmdumplog</strong> and <strong>pmlogsummary</strong>), and the more
common access to the archives would be through the <strong>pmFetch</strong> interface.</p>
</div>
</div>
<div class="section" id="pmapi-time-control-services">
<h3><a class="toc-backref" href="#id72">3.8.10. PMAPI Time Control Services</a><a class="headerlink" href="#pmapi-time-control-services" title="Permalink to this headline">¶</a></h3>
<p>The PMAPI provides a common framework for client applications to control time and to synchronize time with other applications. The user interface component of
this service is fully described in the companion <em>Performance Co-Pilot User’s and Administrator’s Guide</em>. See also the <strong>pmtime(1)</strong> man page.</p>
<p>This service is most useful when processing sets of PCP archive logs, to control parameters such as the current archive position, update interval, replay rate,
and timezone, but it can also be used in live mode to control a subset of these parameters. Applications such as <strong>pmchart, pmgadgets, pmstat</strong>, and <strong>pmval</strong>
use the time control services to connect to an instance of the time control server process, <strong>pmtime</strong>, which provides a uniform graphical user interface to the
time control services.</p>
<p>A full description of the PMAPI time control functions along with code examples can be found in man pages as listed in <a class="reference internal" href="#table-3-2-time-control-functions-in-pmapi">Table 3.2. Time Control Functions in PMAPI</a>:</p>
<p id="table-3-2-time-control-functions-in-pmapi"><strong>Table 3.2. Time Control Functions in PMAPI</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Man Page</strong></td>
<td><strong>Synopsis of Time Control Function</strong></td>
</tr>
<tr class="row-even"><td><strong>pmCtime(3)</strong></td>
<td>Formats the date and time for a reporting timezone.</td>
</tr>
<tr class="row-odd"><td><strong>pmLocaltime(3)</strong></td>
<td>Converts the date and time for a reporting timezone.</td>
</tr>
<tr class="row-even"><td><strong>pmParseTimeWindow(3)</strong></td>
<td>Parses time window command line arguments.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeConnect(3)</strong></td>
<td>Connects to a time control server via a command socket.</td>
</tr>
<tr class="row-even"><td><strong>pmTimeDisconnect(3)</strong></td>
<td>Closes the command socket to the time control server.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeGetPort(3)</strong></td>
<td>Obtains the port name of the current time control server.</td>
</tr>
<tr class="row-even"><td><strong>pmTimeRecv(3)</strong></td>
<td>Blocks until the time control server sends a command message.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeSendAck(3)</strong></td>
<td>Acknowledges completion of the step command.</td>
</tr>
<tr class="row-even"><td><strong>pmTimeSendBounds(3)</strong></td>
<td>Specifies beginning and end of archive time period.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeSendMode(3)</strong></td>
<td>Requests time control server to change to a new VCR mode.</td>
</tr>
<tr class="row-even"><td><strong>pmTimeSendPosition(3)</strong></td>
<td>Requests time control server to change position or update intervals.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeSendTimezone(3)</strong></td>
<td>Requests time control server to change timezones.</td>
</tr>
<tr class="row-even"><td><strong>pmTimeShowDialog(3)</strong></td>
<td>Changes the visibility of the time control dialogue.</td>
</tr>
<tr class="row-odd"><td><strong>pmTimeGetStatePixmap(3)</strong></td>
<td>Returns array of pixmaps representing supplied time control state.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pmapi-ancillary-support-services">
<h3><a class="toc-backref" href="#id73">3.8.11. PMAPI Ancillary Support Services</a><a class="headerlink" href="#pmapi-ancillary-support-services" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section provide services that are complementary to, but not necessarily a part of, the distributed manipulation of performance
metrics delivered by the PCP components.</p>
<div class="section" id="pmgetconfig-function">
<h4><a class="toc-backref" href="#id74">3.8.11.1. pmGetConfig Function</a><a class="headerlink" href="#pmgetconfig-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char *pmGetConfig(const char *variable)
Python:
&quot;env variable value = pmGetConfig(&quot;env variable&quot;)
</pre></div>
</div>
<p>The <strong>pmGetConfig</strong> function searches for a variable first in the environment and then, if one is not found, in the PCP configuration file and returns the string
result. If a variable is not already in the environment, it is added with a call to the <strong>setenv</strong> function before returning.</p>
<p>The default location of the PCP configuration file is <strong>/etc/pcp.conf</strong>, but this location may be changed by setting <strong>PCP_CONF</strong> in the environment to a new
location, as described in the <strong>pcp.conf(5)</strong> man page.</p>
<p>If the variable is not found in either the environment or the PCP configuration file (or the PCP configuration file is not found and <strong>PCP_CONF</strong> is not set in
the environment), then a fatal error message is printed and the process will exit. Although this sounds drastic, it is the only course of action available because
the PCP configuration or installation is fatally flawed.</p>
<p>If this function returns, the returned value points to a string in the environment; and so although the function returns the same type as the <strong>getenv</strong> function
(which should probably be a <strong>const char *</strong>), changing the content of the string is not recommended.</p>
<p>The python bindings return a value for environment variable <em>“env variable”</em> from environment or pcp config file.</p>
</div>
<div class="section" id="pmerrstr-function">
<h4><a class="toc-backref" href="#id75">3.8.11.2. pmErrStr Function</a><a class="headerlink" href="#pmerrstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmErrStr(int code)
char *pmErrStr_r(int code, char *buf, int buflen);
Python:
&quot;error string text&quot; = pmErrStr(int error_code)
</pre></div>
</div>
<p>This function translates an error code into a text string, suitable for generating a diagnostic message. By convention within PCP, all error codes are negative.
The small values are assumed to be negated versions of the platform error codes as defined in <strong>errno.h</strong>, and the strings returned are according to <strong>strerror</strong>.
The large, negative error codes are PMAPI error conditions, and <strong>pmErrStr</strong> returns an appropriate PMAPI error string, as determined by <em>code</em>.</p>
<p>In the case of <strong>pmErrStr</strong>, the string value is held in a single static buffer, so concurrent calls may not produce the desired results. The <strong>pmErrStr_r</strong>
function allows a buffer and length to be passed in, into which the message is stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings return the error string corresponding to the <em>error code</em>.</p>
</div>
<div class="section" id="pmextractvalue-function">
<h4><a class="toc-backref" href="#id76">3.8.11.3. pmExtractValue Function</a><a class="headerlink" href="#pmextractvalue-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmExtractValue(int valfmt, const pmValue *ival, int itype,
pmAtomValue *oval, int otype)
Python:
pmAtomValue atomval = pmExtractValue(int valfmt, const pmValue * ival,
              int itype,
              pmAtomValue *oval,
                int otype)
</pre></div>
</div>
<p>The <strong>pmValue</strong> structure is embedded within the <strong>pmResult</strong> structure, which is used to return one or more performance metrics; see the <strong>pmFetch</strong> man page.</p>
<p>All performance metric values may be encoded in a <strong>pmAtomValue</strong> union, defined in <a class="reference internal" href="#example-3-18-pmatomvalue-structure">Example 3.18. pmAtomValue Structure</a>:</p>
<p id="example-3-18-pmatomvalue-structure"><strong>Example 3.18. pmAtomValue Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Generic Union for Value-Type conversions */
typedef union {
    __int32_t  l;     /* 32-bit signed */
    __uint32_t ul;    /* 32-bit unsigned */
    __int64_t  ll;    /* 64-bit signed */
    __uint64_t ull;   /* 64-bit unsigned */
    float      f;     /* 32-bit floating point */
    double     d;     /* 64-bit floating point */
    char       *cp;   /* char ptr */
    void       *vp;   /* void ptr */
} pmAtomValue;
</pre></div>
</div>
<p>The <strong>pmExtractValue</strong> function provides a convenient mechanism for extracting values from the <strong>pmValue</strong> part of a <strong>pmResult</strong> structure, optionally converting
the data type, and making the result available to the application programmer.</p>
<p>The <em>itype</em> argument defines the data type of the input value held in <em>ival</em> according to the storage format defined by <em>valfmt</em> (see the <strong>pmFetch</strong> man page).
The <em>otype</em> argument defines the data type of the result to be placed in <em>oval</em>. The value for <em>itype</em> is typically extracted from a <strong>pmDesc</strong> structure,
following a call to <strong>pmLookupDesc</strong> for a particular performance metric.</p>
<p><a class="reference internal" href="#table-3-3-pmapi-type-conversion">Table 3.3. PMAPI Type Conversion</a> defines the various possibilities for the type conversion. The input type (<em>itype</em>) is shown vertically, and the output type
(<em>otype</em>) horizontally. The following rules apply:</p>
<ul class="simple">
<li>Y means the conversion is always acceptable.</li>
<li>N means conversion can never be performed (function returns <strong>PM_ERR_CONV</strong>).</li>
<li>P means the conversion may lose accuracy (but no error status is returned).</li>
<li>T means the result may be subject to high-order truncation (if this occurs the function returns <strong>PM_ERR_TRUNC</strong>).</li>
<li>S means the conversion may be impossible due to the sign of the input value (if this occurs the function returns <strong>PM_ERR_SIGN</strong>).</li>
</ul>
<p>If an error occurs, <em>oval</em> is set to zero (or NULL).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that some of the conversions involving the <strong>PM_TYPE_STRING</strong> and <strong>PM_TYPE_AGGREGATE</strong> types are indeed possible, but are marked N; the rationale is that
<strong>pmExtractValue</strong> should not attempt to duplicate functionality already available in the C library through <strong>sscanf</strong> and <strong>sprintf</strong>. No conversion involving
the type <strong>PM_TYPE_EVENT</strong> is supported.</p>
</div>
<p id="table-3-3-pmapi-type-conversion"><strong>Table 3.3. PMAPI Type Conversion</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="10%" />
<col width="7%" />
<col width="10%" />
<col width="11%" />
<col width="10%" />
<col width="13%" />
<col width="10%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">TYPE</th>
<th class="head">32</th>
<th class="head">U32</th>
<th class="head">64</th>
<th class="head">U64</th>
<th class="head">FLOAT</th>
<th class="head">DBLE</th>
<th class="head">STRING</th>
<th class="head">AGGR</th>
<th class="head">EVENT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>32</td>
<td>Y</td>
<td>S</td>
<td>Y</td>
<td>S</td>
<td>P</td>
<td>P</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-odd"><td>U32</td>
<td>T</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>P</td>
<td>P</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-even"><td>64</td>
<td>T</td>
<td>T,S</td>
<td>Y</td>
<td>S</td>
<td>P</td>
<td>P</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-odd"><td>u64</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>Y</td>
<td>P</td>
<td>P</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-even"><td>FLOAT</td>
<td>P,T</td>
<td>P,T,S</td>
<td>P,T</td>
<td>P,T,S</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-odd"><td>DBLE</td>
<td>P,T</td>
<td>P,T,S</td>
<td>P,T</td>
<td>P,T,S</td>
<td>P</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-even"><td>STRING</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="row-odd"><td>AGGR</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr class="row-even"><td>EVENT</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>In the cases where multiple conversion errors could occur, the first encountered error is returned, and the order of checking is not defined.</p>
<p>If the output conversion is to one of the pointer types, such as <em>otype</em> <strong>PM_TYPE_STRING</strong> or <strong>PM_TYPE_AGGREGATE</strong>, then the value buffer is allocated by
<strong>pmExtractValue</strong> using <strong>malloc</strong>, and it is the caller’s responsibility to free the space when it is no longer required; see the <strong>malloc(3)</strong> and <strong>free(3)</strong>
man pages.</p>
<p>Although this function appears rather complex, it has been constructed to assist the development of performance tools that convert values, whose type is known only
through the <strong>type</strong> field in a <strong>pmDesc</strong> structure, into a canonical type for local processing.</p>
<p>The python bindings extract a value from a pmValue struct <em>ival</em> stored in format <em>valfmt</em> (see <strong>pmFetch</strong>), and convert its type from <em>itype</em> to <em>otype</em>.</p>
</div>
<div class="section" id="pmconvscale-function">
<h4><a class="toc-backref" href="#id77">3.8.11.4. pmConvScale Function</a><a class="headerlink" href="#pmconvscale-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int
pmConvScale(int type, const pmAtomValue *ival, const pmUnits *iunit,
pmAtomValue *oval, pmUnits *ounit)
Python:
pmAtomValue atomval = pmConvScale(int itype, pmAtomValue value,
              pmDesc* pmdesc , int descidx, int otype)
</pre></div>
</div>
<p>Given a performance metric value pointed to by <em>ival</em>, multiply it by a scale factor and return the value in <em>oval</em>. The scaling takes place from the units defined
by <em>iunit</em> into the units defined by <em>ounit</em>. Both input and output units must have the same dimensionality.</p>
<p>The performance metric type for both input and output values is determined by <em>type</em>, the value for which is typically extracted from a <strong>pmDesc</strong> structure,
following a call to <strong>pmLookupDesc</strong> for a particular performance metric.</p>
<p><strong>pmConvScale</strong> is most useful when values returned through <strong>pmFetch</strong> (and possibly extracted using <strong>pmExtractValue</strong>) need to be normalized into some canonical
scale and units for the purposes of computation.</p>
<p>The python bindings convert a <em>value</em> pointed to by <em>pmdesc</em> entry <em>descidx</em> to a different scale <em>otype</em>.</p>
</div>
<div class="section" id="pmunitsstr-function">
<h4><a class="toc-backref" href="#id78">3.8.11.5. pmUnitsStr Function</a><a class="headerlink" href="#pmunitsstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmUnitsStr(const pmUnits *pu)
char *pmUnitsStr_r(const pmUnits *pu, char *buf, int buflen)
Python:
&quot;units string&quot; = pmUnitsStr(pmUnits pmunits)
</pre></div>
</div>
<p>As an aid to labeling graphs and tables, or for error messages, <strong>pmUnitsStr</strong> takes a dimension and scale specification as per <em>pu</em>, and returns the corresponding
text string.</p>
<p><em>pu</em> is typically from a <strong>pmDesc</strong> structure, for example, as returned by <strong>pmLookupDesc</strong>.</p>
<p>If <em>*pu</em> were <strong>{1, -2, 0, PM_SPACE_MBYTE, PM_TIME_MSEC, 0}</strong>, then the result string would be <strong>Mbyte/sec^2</strong>.</p>
<p>In the case of <strong>pmUnitsStr</strong>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <strong>pmUnitsStr_r</strong>
function allows a buffer and length to be passed in, into which the units are stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings translate a pmUnits struct <em>pmunits</em> to a readable string.</p>
</div>
<div class="section" id="pmidstr-function">
<h4><a class="toc-backref" href="#id79">3.8.11.6. pmIDStr Function</a><a class="headerlink" href="#pmidstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmIDStr(pmID pmid)
char *pmIDStr_r(pmID pmid, char *buf, int buflen)
Python:
&quot;ID string&quot; = pmIDStr(int pmID)
</pre></div>
</div>
<p>For use in error and diagnostic messages, return a human readable version of the specified PMID, with each of the internal <strong>domain, cluster</strong>, and <strong>item</strong>
subfields appearing as decimal numbers, separated by periods.</p>
<p>In the case of <strong>pmIDStr</strong>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <strong>pmIDStr_r</strong> function
allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings translate a pmID <em>pmid</em> to a readable string.</p>
</div>
<div class="section" id="pmindomstr-function">
<h4><a class="toc-backref" href="#id80">3.8.11.7. pmInDomStr Function</a><a class="headerlink" href="#pmindomstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmInDomStr(pmInDom indom)
char *pmInDomStr_r(pmInDom indom, char *buf, int buflen)
Python:
&quot;indom&quot; = pmGetInDom(pmDesc pmdesc)
</pre></div>
</div>
<p>For use in error and diagnostic messages, return a human readable version of the specified instance domain identifier, with each of the internal <strong>domain</strong> and
<strong>serial</strong> subfields appearing as decimal numbers, separated by periods.</p>
<p>In the case of <strong>pmInDomStrr</strong>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <strong>pmInDomStr_r</strong>
function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings translate an instance domain ID pointed to by a pmDesc <strong>pmdesc</strong> to a readable string.</p>
</div>
<div class="section" id="pmtypestr-function">
<h4><a class="toc-backref" href="#id81">3.8.11.8. pmTypeStr Function</a><a class="headerlink" href="#pmtypestr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmTypeStr(int type)
char *pmTypeStr_r(int type, char *buf, int buflen)
Python:
&quot;type&quot; = pmTypeStr(int type)
</pre></div>
</div>
<p>Given a performance metric type, produce a terse ASCII equivalent, appropriate for use in error and diagnostic messages.</p>
<p>Examples are “32” (for <strong>PM_TYPE_32</strong>), “U64” (for <strong>PM_TYPE_U64</strong>), “AGGREGATE” (for <strong>PM_TYPE_AGGREGATE</strong>), and so on.</p>
<p>In the case of <strong>pmTypeStr</strong>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <strong>pmTypeStr_r</strong>
function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings translate a performance metric type to a readable string. Constants are available for the types, e.g. c_api.PM_TYPE_FLOAT, by importing cpmapi.</p>
</div>
<div class="section" id="pmatomstr-function">
<h4><a class="toc-backref" href="#id82">3.8.11.9. ⁠pmAtomStr Function</a><a class="headerlink" href="#pmatomstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmAtomStr(const pmAtomValue *avp, int type)
char *pmAtomStr_r(const pmAtomValue *avp, int typechar *buf, int buflen)
Python:
&quot;value&quot; = pmAtomStr(atom, type)
</pre></div>
</div>
<p>Given the <strong>pmAtomValue</strong> identified by <em>avp</em>, and a performance metric <em>type</em>, generate the corresponding metric value as a string, suitable for diagnostic or
report output.</p>
<p>In the case of <strong>pmAtomStr</strong>, the string value is held in a single static buffer; so concurrent calls may not produce the desired results. The <strong>pmAtomStr_r</strong>
function allows a buffer and length to be passed in, into which the identifier is stored; this variant uses no shared storage and can be used in a thread-safe manner.</p>
<p>The python bindings translate a pmAtomValue <strong>atom</strong> having performance metric <strong>type</strong> to a readable string. Constants are available for the types, e.g. c_api.PM_TYPE_U32, by importing cpmapi.</p>
</div>
<div class="section" id="pmnumberstr-function">
<h4><a class="toc-backref" href="#id83">3.8.11.10. pmNumberStr Function</a><a class="headerlink" href="#pmnumberstr-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char *pmNumberStr(double value)
char *pmNumberStr_r(double value, char *buf, int buflen)
</pre></div>
</div>
<p>The <strong>pmNumberStr</strong> function returns the address of a static 8-byte buffer that holds a null-byte terminated representation of value suitable for output with fixed-width fields.</p>
<p>The value is scaled using multipliers in powers of one thousand (the decimal kilo) and has a bias that provides greater precision for positive numbers as opposed
to negative numbers. The format depends on the sign and magnitude of <em>value</em>.</p>
</div>
<div class="section" id="pmprintvalue-function">
<h4><a class="toc-backref" href="#id84">3.8.11.11. pmPrintValue Function</a><a class="headerlink" href="#pmprintvalue-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pmPrintValue(FILE *f, int valfmt, int type, const pmValue *val,
int minwidth)
Python:
pmPrintValue(FILE* file, pmResult pmresult, pmdesc, vset_index, vlist_index, min_width)
</pre></div>
</div>
<p>The value of a single performance metric (as identified by <em>val</em>) is printed on the standard I/O stream identified by <em>f</em>. The value of the performance metric is
interpreted according to the format of <em>val</em> as defined by <em>valfmt</em> (from a <strong>pmValueSet</strong> within a <strong>pmResult</strong>) and the generic description of the metric’s type
from a <strong>pmDesc</strong> structure, passed in through.</p>
<p>If the converted value is less than <em>minwidth</em> characters wide, it will have leading spaces to pad the output to a width of <em>minwidth</em> characters.</p>
<p><a class="reference internal" href="#example-3-19-using-pmprintvalue-to-print-values">Example 3.19. Using pmPrintValue to Print Values</a> illustrates using <strong>pmPrintValue</strong> to print the values from a <strong>pmResult</strong> structure returned via <strong>pmFetch</strong>:</p>
<p id="example-3-19-using-pmprintvalue-to-print-values"><strong>Example 3.19. Using pmPrintValue to Print Values</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int         numpmid, i, j, sts;
pmID        pmidlist[10];
pmDesc      desc[10];
pmResult    *result;

/* set up PMAPI context, numpmid and pmidlist[] ... */
/* get metric descriptors */
for (i = 0; i &lt; numpmid; i++) {
    if ((sts = pmLookupDesc(pmidlist[i], &amp;desc[i])) &lt; 0) {
        printf(&quot;pmLookupDesc(pmid=%s): %s\n&quot;,
                      pmIDStr(pmidlist[i]), pmErrStr(sts));
        exit(1);
    }
}
if ((sts = pmFetch(numpmid, pmidlist, &amp;result)) &gt;= 0) {
    /* once per metric */
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        printf(&quot;PMID: %s&quot;, pmIDStr(result-&gt;vset[i]-&gt;pmid));
        /* once per instance for this metric */
        for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
            printf(&quot; [%d]&quot;, result-&gt;vset[i]-&gt;vlist[j].inst);
            pmPrintValue(stdout, result-&gt;vset[i]-&gt;valfmt,
                         desc[i].type,
                         &amp;result-&gt;vset[i]-&gt;vlist[j],
                         8);
        }
        putchar(&#39;\n&#39;);
    }
    pmFreeResult(result);
}
else
    printf(&quot;pmFetch: %s\n&quot;, pmErrStr(sts));
</pre></div>
</div>
<p>Print the value of a <em>pmresult</em> pointed to by <em>vset_index/vlist_index</em> and described by <em>pmdesc</em>. The format of a pmResult is described in <em>pmResult</em> The python
bindings can use sys.__stdout__ as a value for file to display to stdout.</p>
</div>
<div class="section" id="pmflush-function">
<h4><a class="toc-backref" href="#id85">3.8.11.12. pmflush Function</a><a class="headerlink" href="#pmflush-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmflush(void);
Python:
int status = pmflush()
</pre></div>
</div>
<p>The <strong>pmflush</strong> function causes the internal buffer which is shared with <strong>pmprintf</strong> to be either displayed in a window, printed on standard error, or flushed to
a file and the internal buffer to be cleared.</p>
<p>The <strong>PCP_STDERR</strong> environment variable controls the output technique used by <strong>pmflush</strong>:</p>
<ul class="simple">
<li>If <strong>PCP_STDERR</strong> is unset, the text is written onto the stderr stream of the caller.</li>
<li>If <strong>PCP_STDERR</strong> is set to the literal reserved word <strong>DISPLAY</strong>, then the text is displayed as a GUI dialogue using <strong>pmconfirm</strong>.</li>
</ul>
<p>The <strong>pmflush</strong> function returns a value of zero on successful completion. A negative value is returned if an error was encountered, and this can be passed to
<strong>pmErrStr</strong> to obtain the associated error message.</p>
</div>
<div class="section" id="pmprintf-function">
<h4><a class="toc-backref" href="#id86">3.8.11.13. pmprintf Function</a><a class="headerlink" href="#pmprintf-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmprintf(const char *fmt, ... /*args*/);
Python:
pmprintf(&quot;fmt&quot;, ... /*args*/);
</pre></div>
</div>
<p>The <strong>pmprintf</strong> function appends the formatted message string to an internal buffer shared by the <strong>pmprintf</strong> and <strong>pmflush</strong> functions, without actually
producing any output. The <em>fmt</em> argument is used to control the conversion, formatting, and printing of the variable length <em>args</em> list.</p>
<p>The <strong>pmprintf</strong> function uses the <strong>mkstemp</strong> function to securely create a <strong>pcp</strong>-prefixed temporary file in <code class="docutils literal notranslate"><span class="pre">${PCP_TMP_DIR}</span></code>. This temporary file is deleted
when <strong>pmflush</strong> is called.</p>
<p>On successful completion, <strong>pmprintf</strong> returns the number of characters transmitted. A negative value is returned if an error was encountered, and this can be
passed to <strong>pmErrStr</strong> to obtain the associated error message.</p>
</div>
<div class="section" id="pmsortinstances-function">
<h4><a class="toc-backref" href="#id87">3.8.11.14. pmSortInstances Function</a><a class="headerlink" href="#pmsortinstances-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pmSortInstances(pmResult *result)
Python:
pmSortInstances (pmResult* pmresult)
</pre></div>
</div>
<p>The <strong>pmSortInstances</strong> function may be used to guarantee that for each performance metric in the result from <strong>pmFetch</strong>, the instances are in ascending internal
instance identifier sequence. This is useful when trying to compute rates from two consecutive <strong>pmFetch</strong> results, where the underlying instance domain or metric
availability is not static.</p>
</div>
<div class="section" id="pmparseinterval-function">
<h4><a class="toc-backref" href="#id88">3.8.11.15. pmParseInterval Function</a><a class="headerlink" href="#pmparseinterval-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmParseInterval(const char *string, struct timeval *rslt, char **errmsg)
Python:
(struct timeval, &quot;error message&quot;) = pmParseInterval(&quot;time string&quot;)
</pre></div>
</div>
<p>The <strong>pmParseInterval</strong> function parses the argument string specifying an interval of time and fills in the <strong>tv_sec</strong> and <strong>tv_usec</strong> components of the <strong>rslt</strong>
structure to represent that interval. The input string is most commonly the argument following a <strong>-t</strong> command line option to a PCP application, and the syntax
is fully described in the <strong>PCPIntro(1)</strong> man page.</p>
<p><strong>pmParseInterval</strong> returns 0 and <em>errmsg</em> is undefined if the parsing is successful. If the given string does not conform to the required syntax, the function
returns -1 and a dynamically allocated error message string in <em>errmsg</em>.</p>
<p>The error message is terminated with a newline and includes the text of the input string along with an indicator of the position at which the error was detected as
shown in the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>4minutes 30mumble
           ^ -- unexpected value
</pre></div>
</div>
<p>In the case of an error, the caller is responsible for calling <strong>free</strong> to release the space allocated for <em>errmsg</em>.</p>
</div>
<div class="section" id="pmparsemetricspec-function">
<h4><a class="toc-backref" href="#id89">3.8.11.16. pmParseMetricSpec Function</a><a class="headerlink" href="#pmparsemetricspec-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pmParseMetricSpec(const char *string, int isarch, char *source,
                      pmMetricSpec **rsltp, char **errmsg)
Python:
(pmMetricSpec metricspec, &quot;error message&quot;) =
                      pmParseMetricSpec(&quot;metric specification&quot;, isarch, source)
</pre></div>
</div>
<p>The <strong>pmParseMetricSpec</strong> function accepts a <em>string</em> specifying the name of a PCP performance metric, and optionally the source (either a hostname, a set of PCP
archive logs, or a local context) and instances for that metric. The syntax is described in the <strong>PCPIntro(1)</strong> man page.</p>
<p>If neither host nor archive component of the metric specification is provided, the <strong>isarch</strong> and <strong>source</strong> arguments are used to fill in the returned <strong>pmMetricSpec</strong>
structure. In <a class="reference internal" href="#example-3-20-pmmetricspec-structure">Example 3.20. pmMetricSpec Structure</a>, the <strong>pmMetricSpec</strong> structure, which is returned via <em>rsltp</em>, represents the parsed string.</p>
<p id="example-3-20-pmmetricspec-structure"><strong>Example 3.20. pmMetricSpec Structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct {
    int     isarch;      /* source type: 0 -&gt; host, 1 -&gt; archive, 2 -&gt; local context */
    char    *source;     /* name of source host or archive */
    char    *metric;     /* name of metric */
    int     ninst;       /* number of instances, 0 -&gt; all */
    char    *inst[1];    /* array of instance names */
} pmMetricSpec;
</pre></div>
</div>
<p>The <strong>pmParseMetricSpec</strong> function returns 0 if the given string was successfully parsed. In this case, all the storage allocated by <strong>pmParseMetricSpec</strong> can be
released by a single call to the <strong>free</strong> function by using the address returned from <strong>pmMetricSpec</strong> via <em>rsltp</em>. The convenience macro <strong>pmFreeMetricSpec</strong> is a
thinly disguised wrapper for <strong>free</strong>.</p>
<p>The <strong>pmParseMetricSpec</strong> function returns 0 if the given string was successfully parsed. It returns <strong>PM_ERR_GENERIC</strong> and a dynamically allocated error message
string in <em>errmsg</em> if the given string does not parse. In this situation, the error message string can be released with the <strong>free</strong> function.</p>
<p>In the case of an error, <em>rsltp</em> is undefined. In the case of success, <em>errmsg</em> is undefined. If <em>rsltp-&gt;ninst</em> is 0, then <em>rsltp-&gt;inst[0]</em> is undefined.</p>
</div>
</div>
</div>
<div class="section" id="pmapi-programming-issues-and-examples">
<h2><a class="toc-backref" href="#id90">3.9. PMAPI Programming Issues and Examples</a><a class="headerlink" href="#pmapi-programming-issues-and-examples" title="Permalink to this headline">¶</a></h2>
<p>The following issues and examples are provided to enable you to create better custom performance monitoring tools.</p>
<p>The source code for a sample client (<strong>pmclient</strong>) using the PMAPI is shipped as part of the PCP package. See the <strong>pmclient(1)</strong> man page, and the source code,
located in <code class="docutils literal notranslate"><span class="pre">${PCP_DEMOS_DIR}/pmclient</span></code>.</p>
<div class="section" id="symbolic-association-between-a-metric-s-name-and-value">
<h3><a class="toc-backref" href="#id91">3.9.1. Symbolic Association between a Metric’s Name and Value</a><a class="headerlink" href="#symbolic-association-between-a-metric-s-name-and-value" title="Permalink to this headline">¶</a></h3>
<p>A common problem in building specific performance tools is how to maintain the association between a performance metric’s name, its access (instantiation) method,
and the application program variable that contains the metric’s value. Generally this results in code that is easily broken by bug fixes or changes in the
underlying data structures. The PMAPI provides a uniform method for instantiating and accessing the values independent of the underlying implementation, although
it does not solve the name-variable association problem. However, it does provide a framework within which a manageable solution may be developed.</p>
<p>Fundamentally, the goal is to be able to name a metric and reference the metric’s value in a manner that is independent of the order of operations on other metrics;
for example, to associate the <strong>LOADAV</strong> macro with the name <strong>kernel.all.load</strong>, and then be able to use <strong>LOADAV</strong> to get at the value of the corresponding metric.</p>
<p>The one-to-one association between the ordinal position of the metric names is input to <strong>pmLookupName</strong> and the PMIDs returned by this function, and the one-to-one
association between the PMIDs input to <strong>pmFetch</strong> and the values returned by this function provide the basis for an automated solution.</p>
<p>The tool <strong>pmgenmap</strong> takes the specification of a list of metric names and symbolic tags, in the order they should be passed to <strong>pmLookupName</strong> and <strong>pmFetch</strong>.
For example, <strong>pmclient</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          cat ${PCP_DEMOS_DIR}/pmclient/pmnsmap.spec
pmclient_init {
    hinv.ncpu                  NUMCPU
}

pmclient_sample {
    kernel.all.load    LOADAV
    kernel.percpu.cpu.user     CPU_USR
    kernel.percpu.cpu.sys      CPU_SYS
    mem.freemem                FREEMEM
    disk.all.total             DKIOPS
}
</pre></div>
</div>
<p>This <strong>pmgenmap</strong> input produces the C code in <a class="reference internal" href="#example-3-21-c-code-produced-by-pmgenmap-input">Example 3.21. C Code Produced by pmgenmap Input</a>. It is suitable for including with the <strong>#include</strong> statement:</p>
<p id="example-3-21-c-code-produced-by-pmgenmap-input"><strong>Example 3.21. C Code Produced by pmgenmap Input</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Performance Metrics Name Space Map
 * Built by runme.sh from the file
 * pmnsmap.spec
 * on Thu Jan  9 14:13:49 EST 2014
 *
 * Do not edit this file!
 */

char *pmclient_init[] = {
#define NUMCPU 0
              &quot;hinv.ncpu&quot;,

};


char *pmclient_sample[] = {
#define LOADAV 0
              &quot;kernel.all.load&quot;,
#define CPU_USR        1
            &quot;kernel.percpu.cpu.user&quot;,
#define CPU_SYS        2
              &quot;kernel.percpu.cpu.sys&quot;,
#define FREEMEM        3
              &quot;mem.freemem&quot;,
#define DKIOPS 4
              &quot;disk.all.total&quot;,

};
</pre></div>
</div>
</div>
<div class="section" id="initializing-new-metrics">
<h3><a class="toc-backref" href="#id92">3.9.2. Initializing New Metrics</a><a class="headerlink" href="#initializing-new-metrics" title="Permalink to this headline">¶</a></h3>
<p>Using the code generated by <strong>pmgenmap</strong>, you are now able to easily initialize the application’s metric specifications as shown in
<a class="reference internal" href="#example-3-22-initializing-metric-specifications">Example 3.22. Initializing Metric Specifications</a>:</p>
<p id="example-3-22-initializing-metric-specifications"><strong>Example 3.22. Initializing Metric Specifications</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* C code fragment from pmclient.c */
numpmid = sizeof(pmclient_sample) / sizeof(char *);
if ((pmidlist = (pmID *)malloc(numpmid * sizeof(pmidlist[0]))) == NULL) {...}
if ((sts = pmLookupName(numpmid, pmclient_sample, pmidlist)) &lt; 0) {...}


# The equivalent python code would be
pmclient_sample = (&quot;kernel.all.load&quot;, &quot;kernel.percpu.cpu.user&quot;,
              &quot;kernel.percpu.cpu.sys&quot;, &quot;mem.freemem&quot;, &quot;disk.all.total&quot;)
pmidlist = context.pmLookupName(pmclient_sample)
</pre></div>
</div>
<p>At this stage, <strong>pmidlist</strong> contains the PMID for the five metrics of interest.</p>
</div>
<div class="section" id="iterative-processing-of-values">
<h3><a class="toc-backref" href="#id93">3.9.3. Iterative Processing of Values</a><a class="headerlink" href="#iterative-processing-of-values" title="Permalink to this headline">¶</a></h3>
<p>Assuming the tool is required to report values every <em>delta</em> seconds, use code similar to that in <a class="reference internal" href="#example-3-23-iterative-processing">Example 3.23. Iterative Processing</a>:</p>
<p id="example-3-23-iterative-processing"><strong>Example 3.23. Iterative Processing</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* censored C code fragment from pmclient.c */
while (samples == -1 || samples-- &gt; 0) {
   if ((sts = pmFetch(numpmid, pmidlist, &amp;crp)) &lt; 0) { ... }
   for (i = 0; i &lt; numpmid; i++)
      if ((sts = pmLookupDesc(pmidlist[i], &amp;desclist[i])) &lt; 0) { ... }
   ...
   pmExtractValue(crp-&gt;vset[FREEMEM]-&gt;valfmt, crp-&gt;vset[FREEMEM]-&gt;vlist,
                  desclist[FREEMEM].type, &amp;tmp, PM_TYPE_FLOAT);
   pmConvScale(PM_TYPE_FLOAT, &amp;tmp, &amp;desclist[FREEMEM].units,
                    &amp;atom, &amp;mbyte_scale);
   ip-&gt;freemem = atom.f;
   ...
   __pmtimevalSleep(delta);
}


# The equivalent python code would be
FREEMEM = 3
desclist = context.pmLookupDescs(metric_names)
while (samples &gt; 0):
    crp = context.pmFetch(metric_names)
    val = context.pmExtractValue(crp.contents.get_valfmt(FREEMEM),
                             crp.contents.get_vlist(FREEMEM, 0),
                             desclist[FREEMEM].contents.type,
                             c_api.PM_TYPE_FLOAT)
    atom = ctx.pmConvScale(c_api.PM_TYPE_FLOAT, val, desclist, FREEMEM,
                          c_api.PM_SPACE_MBYTE)
    (tvdelta, errmsg) = c_api.pmParseInterval(delta)
    c_api.pmtimevalSleep(delta)
</pre></div>
</div>
</div>
<div class="section" id="accommodating-program-evolution">
<h3><a class="toc-backref" href="#id94">3.9.4. Accommodating Program Evolution</a><a class="headerlink" href="#accommodating-program-evolution" title="Permalink to this headline">¶</a></h3>
<p>The flexibility provided by the PMAPI and the <strong>pmgenmap</strong> utility is demonstrated by <a class="reference internal" href="#example-3-24-adding-a-metric">Example 3.24. Adding a Metric</a>. Consider the requirement for reporting a
third metric <strong>mem.physmem</strong>. This example shows how to add the line to the specification file:</p>
<p id="example-3-24-adding-a-metric"><strong>Example 3.24. Adding a Metric</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mem.freemem PHYSMEM
</pre></div>
</div>
<p>Then regenerate the <strong>#include</strong> file, and augment pmclient.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  pmExtractValue(crp-&gt;vset[PHYSMEM]-&gt;valfmt, crp-&gt;vset[PHYSMEM]-&gt;vlist,
                 desclist[PHYSMEM].type, &amp;tmp, PM_TYPE_FLOAT);
  pmConvScale(PM_TYPE_FLOAT, &amp;tmp, &amp;desclist[PHYSMEM].units,
                   &amp;atom, &amp;mbyte_scale);


# The equivalent python code would be:
val = context.pmExtractValue(crp.contents.get_valfmt(PHYSMEM),
                       crp.contents.get_vlist(PHYSMEM, 0),
                       desclist[PHYSMEM].contents.type,
                       c_api.PM_TYPE_FLOAT);
</pre></div>
</div>
</div>
<div class="section" id="handling-pmapi-errors">
<h3><a class="toc-backref" href="#id95">3.9.5. Handling PMAPI Errors</a><a class="headerlink" href="#handling-pmapi-errors" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference internal" href="#example-3-25-pmapi-error-handling">Example 3.25. PMAPI Error Handling</a>, the simple but complete PMAPI application demonstrates the recommended style for handling PMAPI error conditions. The
python bindings use the exception mechanism to raise an exception in error cases. The python client can handle this condition by catching the <strong>pmErr</strong> exception.
For simplicity, no command line argument processing is shown here - in practice most tools use the <strong>pmGetOptions</strong> helper interface to assist with initial context
creation and setup.</p>
<p id="example-3-25-pmapi-error-handling"><strong>Example 3.25. PMAPI Error Handling</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;pcp/pmapi.h&gt;

int
main(int argc, char* argv[])
{
    int                 sts = 0;
    char                *host = &quot;local:&quot;;
    char                *metric = &quot;mem.freemem&quot;;
    pmID                pmid;
    pmDesc              desc;
    pmResult            *result;

    sts = pmNewContext(PM_CONTEXT_HOST, host);
    if (sts &lt; 0) {
        fprintf(stderr, &quot;Error connecting to pmcd on %s: %s\n&quot;,
                host, pmErrStr(sts));
        exit(1);
    }
    sts = pmLookupName(1, &amp;metric, &amp;pmid);
    if (sts &lt; 0) {
        fprintf(stderr, &quot;Error looking up %s: %s\n&quot;, metric,
                pmErrStr(sts));
        exit(1);
    }
    sts = pmLookupDesc(pmid, &amp;desc);
    if (sts &lt; 0) {
        fprintf(stderr, &quot;Error getting descriptor for %s:%s: %s\n&quot;,
                host, metric, pmErrStr(sts));
        exit(1);
    }
    sts = pmFetch(1, &amp;pmid, &amp;result);
    if (sts &lt; 0) {
        fprintf(stderr, &quot;Error fetching %s:%s: %s\n&quot;, host, metric,
                pmErrStr(sts));
        exit(1);
    }
    sts = result-&gt;vset[0]-&gt;numval;
    if (sts &lt; 0) {
        fprintf(stderr, &quot;Error fetching %s:%s: %s\n&quot;, host, metric,
                pmErrStr(sts));
        exit(1);
    }
    fprintf(stdout, &quot;%s:%s = &quot;, host, metric);
    if (sts == 0)
        puts(&quot;(no value)&quot;);
    else {
        pmValueSet      *vsp = result-&gt;vset[0];
        pmPrintValue(stdout, vsp-&gt;valfmt, desc.type,
                             &amp;vsp-&gt;vlist[0], 5);
        printf(&quot; %s\n&quot;, pmUnitsStr(&amp;desc.units));
    }
    return 0;
}
</pre></div>
</div>
<p>The equivalent python code would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import sys
import traceback
from pcp import pmapi
from cpmapi import PM_TYPE_U32

try:
    context = pmapi.pmContext()
    pmid = context.pmLookupName(&quot;mem.freemem&quot;)
    desc = context.pmLookupDescs(pmid)
    result = context.pmFetch(pmid)
    freemem = context.pmExtractValue(result.contents.get_valfmt(0),
                                 result.contents.get_vlist(0, 0),
                                 desc[0].contents.type,
                                 PM_TYPE_U32)
    print &quot;freemem is &quot; + str(int(freemem.ul))

except pmapi.pmErr, error:
    print &quot;%s: %s&quot; % (sys.argv[0], error.message())
except Exception, error:
    sys.stderr.write(str(error) + &quot;\n&quot;)
    sys.stderr.write(traceback.format_exc() + &quot;\n&quot;)
</pre></div>
</div>
</div>
<div class="section" id="compiling-and-linking-pmapi-applications">
<h3><a class="toc-backref" href="#id96">3.9.6. Compiling and Linking PMAPI Applications</a><a class="headerlink" href="#compiling-and-linking-pmapi-applications" title="Permalink to this headline">¶</a></h3>
<p>Typical PMAPI applications require the following line to include the function prototype and data structure definitions used by the PMAPI.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;pcp/pmapi.h&gt;
</pre></div>
</div>
<p>Some applications may also require these header files: <strong>&lt;pcp/libpcp.h&gt;</strong> and <strong>&lt;pcp/pmda.h&gt;</strong>.</p>
<p>The run-time environment of the PMAPI is mostly found in the <strong>libpcp</strong> library; so to link a generic PMAPI application requires something akin to the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cc mycode.c -lpcp
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="InstrumentingApplications.html" class="btn btn-neutral float-right" title="4. Instrumenting Applications" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="WritingPMDA.html" class="btn btn-neutral float-left" title="2. Writing A PMDA" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Performance Co-Pilot

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>