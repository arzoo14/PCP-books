

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Instrumenting Applications &mdash; pcp  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PMWEBAPI" href="../REST_API/PMWEBAPI.html" />
    <link rel="prev" title="3. PMAPI–The Performance Metrics API" href="PMAPI.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> pcp
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/AboutUAGGuide.html">About User’s and Administrator’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="AboutPGGuide.html">About Programmer’s Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User's and Administrator's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../UAG/IntroductionToPcp.html">1. Introduction to PCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/InstallingAndConfiguringPcp.html">2. Installing and Configuring Performance Co-Pilot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CommonConventionsAndArguments.html">3. Common Conventions and Arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/MonitoringSystemPerformance.html">4. Monitoring System Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PerformanceMetricsInferenceEngine.html">5. Performance Metrics Inference Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/ArchiveLogging.html">6. Archive Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/PcpDeploymentStrategies.html">7. Performance Co-Pilot Deployment Strategies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../UAG/CustomizingAndExtendingPcpServices.html">8. Customizing and Extending PCP Services</a></li>
</ul>
<p class="caption"><span class="caption-text">Programmer's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ProgrammingPcp.html">1. Programming Performance Co-Pilot</a></li>
<li class="toctree-l1"><a class="reference internal" href="WritingPMDA.html">2. Writing A PMDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="PMAPI.html">3. PMAPI–The Performance Metrics API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Instrumenting Applications</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#application-and-performance-co-pilot-relationship">4.1. Application and Performance Co-Pilot Relationship</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-instrumentation-and-sampling">4.2. Performance Instrumentation and Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mmv-pmda-design">4.3. MMV PMDA Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-values-api">4.4. Memory Mapped Values API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#starting-and-stopping-instrumentation">4.4.1. Starting and Stopping Instrumentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-a-handle-on-mapped-values">4.4.2. Getting a Handle on Mapped Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#updating-mapped-values">4.4.3. Updating Mapped Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elapsed-time-measures">4.4.4. Elapsed Time Measures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#performance-instrumentation-and-tracing">4.5. Performance Instrumentation and Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trace-pmda-design">4.6. Trace PMDA Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#application-interaction">4.6.1. Application Interaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sampling-techniques">4.6.2. Sampling Techniques</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-periodic-sampling">4.6.2.1. Simple Periodic Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rolling-window-periodic-sampling">4.6.2.2. Rolling-Window Periodic Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rolling-window-periodic-sampling-example">4.6.2.3. Rolling-Window Periodic Sampling Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-the-trace-pmda">4.6.3. Configuring the Trace PMDA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#trace-api">4.7. Trace API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transactions">4.7.1. Transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#point-tracing">4.7.2. Point Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#observations-and-counters">4.7.3. Observations and Counters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-the-trace-library">4.7.4. Configuring the Trace Library</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">REST API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../REST_API/PMWEBAPI.html">PMWEBAPI</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>4. Instrumenting Applications</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/PG/InstrumentingApplications.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="instrumenting-applications">
<span id="instrumentingapplications"></span><h1>4. Instrumenting Applications<a class="headerlink" href="#instrumenting-applications" title="Permalink to this headline">¶</a></h1>
<p>This chapter provides an introduction to ways of instrumenting applications using PCP.</p>
<p>The first section covers the use of the Memory Mapped Value (MMV) Performance Metrics Domain Agent (PMDA) to generate customized metrics from an application.
This provides a robust, extremely efficient mechanism for transferring custom instrumentation into the PCP infrastructure. It has been successfully deployed in
production environments for many years, has proven immensely valuable in these situations, and can be used to instrument applications written in a number of
programming languages.</p>
<p>The Memory Mapped Value library and PMDA is supported on every PCP platform, and is enabled by default.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A particularly expansive Java API is available from the separate <a class="reference external" href="https://code.google.com/archive/p/parfait/">Parfait</a> project. It supports both the existing
JVM instrumentation, and custom application metric extensions.</p>
</div>
<p>The chapter also includes information on how to use the MMV library (<strong>libpcp_mmv</strong>) for instrumenting an application. The example programs are installed in
<code class="docutils literal notranslate"><span class="pre">${PCP_DEMOS_DIR}/mmv</span></code>.</p>
<p>The second section covers the design of the Trace PMDA, in an effort to explain how to configure the agent optimally for a particular problem domain. This information
supplements the functional coverage which the man pages provide to both the agent and the library interfaces.</p>
<p>This part of the chapter also includes information on how to use the Trace PMDA and its associated library (<strong>libpcp_trace</strong>) for instrumenting applications. The
example programs are installed in <code class="docutils literal notranslate"><span class="pre">${PCP_DEMOS_DIR}/trace</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current PCP trace library is a relatively heavy-weight solution, issuing multiple system calls per trace point, runs over a TCP/IP socket even locally and
performs no event batching. As such it is not appropriate for production application instrumentation at this stage.</p>
</div>
<p>A revised application tracing library and PMDA are planned which will be light-weight, suitable for production system tracing, and support event metrics and other
advances in end-to-end distributed application tracing.</p>
<p>The application instrumentation libraries are designed to encourage application developers to embed calls in their code that enable application performance data to
be exported. When combined with system-level performance data, this feature allows total performance and resource demands of an application to be correlated with
application activity.</p>
<p>For example, developers can provide the following application performance metrics:</p>
<ul class="simple">
<li>Computation state (especially for codes with major shifts in resource demands between phases of their execution)</li>
<li>Problem size and parameters, that is, degree of parallelism throughput in terms of sub-problems solved, iteration count, transactions, data sets inspected, and so on</li>
<li>Service time by operation type</li>
</ul>
<div class="section" id="application-and-performance-co-pilot-relationship">
<h2>4.1. Application and Performance Co-Pilot Relationship<a class="headerlink" href="#application-and-performance-co-pilot-relationship" title="Permalink to this headline">¶</a></h2>
<p>The relationship between an application, the <strong>pcp_mmv</strong> and <strong>pcp_trace</strong> instrumentation libraries, the MMV and Trace PMDAs, and the rest of the PCP
infrastructure is shown in <a class="reference internal" href="#figure-4-1-application-and-pcp-relationship">Figure 4.1. Application and PCP Relationship</a>:</p>
<div class="figure" id="id1">
<span id="figure-4-1-application-and-pcp-relationship"></span><img alt="../_images/instrumentation.png" src="../_images/instrumentation.png" />
<p class="caption"><span class="caption-text">Figure 4.1. Application and PCP Relationship</span></p>
</div>
<p>Once the application performance metrics are exported into the PCP framework, all of the PCP tools may be leveraged to provide performance monitoring and management, including:</p>
<ul class="simple">
<li>Two- and three-dimensional visualization of resource demands and performance, showing concurrent system activity and application activity.</li>
<li>Transport of performance data over the network for distributed performance management.</li>
<li>Archive logging for historical records of performance, most useful for problem diagnosis, postmortem analysis, performance regression testing, capacity planning,
and benchmarking.</li>
<li>Automated alarms when bad performance is observed. These apply both in real-time or when scanning archives of historical application performance.</li>
</ul>
</div>
<div class="section" id="performance-instrumentation-and-sampling">
<h2>4.2. Performance Instrumentation and Sampling<a class="headerlink" href="#performance-instrumentation-and-sampling" title="Permalink to this headline">¶</a></h2>
<p>The <strong>pcp_mmv</strong> library provides function calls to assist with extracing important performance metrics from a program into a shared, in-memory location such that
the MMV PMDA can examine and serve that information on behalf of PCP client tool requests. The <strong>pcp_mmv</strong> library is described in the <strong>mmv_stats_init(3)</strong>,
<strong>mmv_lookup_value_desc(3)</strong>, <strong>mmv_inc_value(3)</strong> man pages. Additionally, the format of the shared memory mappings is described in detail in <strong>mmv(5)</strong>.</p>
</div>
<div class="section" id="mmv-pmda-design">
<h2>4.3. MMV PMDA Design<a class="headerlink" href="#mmv-pmda-design" title="Permalink to this headline">¶</a></h2>
<p>An application instrumented with memory mapped values directly updates the memory that backs the metric values it exports. The MMV PMDA reads those values directly,
from the <strong>same</strong> memory that the application is updating, when current values are sampled on behalf of PMAPI client tools. This relationship, and a simplified MMV
API, are shown in <a class="reference internal" href="#figure-4-2-memory-mapped-page-sharing">Figure 4.2. Memory Mapped Page Sharing</a>.</p>
<div class="figure" id="id2">
<span id="figure-4-2-memory-mapped-page-sharing"></span><img alt="../_images/pmdammv.png" src="../_images/pmdammv.png" />
<p class="caption"><span class="caption-text">Figure 4.2. Memory Mapped Page Sharing</span></p>
</div>
<p>It is worth noting that once the metrics of an application have been registered via the <strong>pcp_mmv</strong> library initialisation API, subsequent interactions with the
library are not intrusive to the instrumented application. At the points where values are updated, the only cost involved is the memory mapping update, which is a
single memory store operation. There is no need to explicitly transfer control to the MMV PMDA, nor allocate memory, nor make system or library calls. The PMDA will
only sample the values at times driven by PMAPI client tools, and this places no overhead on the instrumented application.</p>
</div>
<div class="section" id="memory-mapped-values-api">
<h2>4.4. Memory Mapped Values API<a class="headerlink" href="#memory-mapped-values-api" title="Permalink to this headline">¶</a></h2>
<p>The <strong>libpcp_mmv</strong> Application Programming Interface (API) can be called from C, C++, Perl and Python (a separate project, Parfait, services the needs of Java
applications). Each language has access to the complete set of functionality offered by <strong>libpcp_mmv</strong>. In most cases, the calling conventions differ only slightly
between languages - in the case of Java and Parfait, they differ significantly however.</p>
<div class="section" id="starting-and-stopping-instrumentation">
<h3>4.4.1. Starting and Stopping Instrumentation<a class="headerlink" href="#starting-and-stopping-instrumentation" title="Permalink to this headline">¶</a></h3>
<p>Instrumentation is begun with an initial call to <strong>mmv_stats_init</strong>, and ended with a call to <strong>mmv_stats_stop</strong>. These calls manipulate global state shared by the
library and application. These are the only calls requiring synchonization and a single call to each is typically performed early and late in the life of the
application (although they can be used to reset the library state as well, at any time). As such, the choice of synchonization primitive is left to the application,
and none is currently performed by the library.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *mmv_stats_init(const char *name, int cluster, mmv_stats_flags_t flags,
                     const mmv_metric_t *stats, int nstats,
                     const mmv_indom_t *indoms, int nindoms)
</pre></div>
</div>
<p>The <em>name</em> should be a simple symbolic name identifying the application. It is usually used as the first application-specific part of the exported metric names, as
seen from the MMV PMDA. This behavior can be overriden using the <em>flags</em> parameter, with the MMV_FLAG_NOPREFIX flag. In the example below, full metric names such as
<strong>mmv.acme.products.count</strong> will be created by the MMV PMDA. With the MMV_FLAG_NOPREFIX flag set, that would instead become <strong>mmv.products.count</strong>. It is recommended
to not disable the prefix - doing so requires the applications to ensure naming conflicts do not arise in the MMV PMDA metric names.</p>
<p>The <em>cluster</em> identifier is used by the MMV PMDA to further distinguish different applications, and is directly used for the MMV PMDA PMID cluster field described in
<a class="reference internal" href="WritingPMDA.html#example-2-3-pmid-int-structure"><span class="std std-ref">Example 2.3. __pmID_int Structure</span></a>, for all MMV PMDA metrics.</p>
<p>All remaining parameters to <strong>mmv_stats_init</strong> define the metrics and instance domains that exist within the application. These are somewhat analagous to the final
parameters of <strong>pmdaInit(3)</strong>, and are best explained using <a class="reference internal" href="#example-4-1-memory-mapped-value-instance-structures">Example 4.1. Memory Mapped Value Instance Structures</a> and <a class="reference internal" href="#example-4-2-memory-mapped-value-metrics-structures">Example 4.2. Memory Mapped Value Metrics Structures</a>.
As mentioned earlier, the full source code for this example instrumented application can be found in <code class="docutils literal notranslate"><span class="pre">${PCP_DEMOS_DIR}/mmv</span></code>.</p>
<p id="example-4-1-memory-mapped-value-instance-structures"><strong>Example 4.1. Memory Mapped Value Instance Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;pcp/pmapi.h&gt;
#include &lt;pcp/mmv_stats.h&gt;

static mmv_instances_t products[] = {
    {   .internal = 0, .external = &quot;Anvils&quot; },
    {   .internal = 1, .external = &quot;Rockets&quot; },
    {   .internal = 2, .external = &quot;Giant_Rubber_Bands&quot; },
};
#define ACME_PRODUCTS_INDOM 61
#define ACME_PRODUCTS_COUNT (sizeof(products)/sizeof(products[0]))

static mmv_indom_t indoms[] = {
    {   .serial = ACME_PRODUCTS_INDOM,
        .count = ACME_PRODUCTS_COUNT,
        .instances = products,
        .shorttext = &quot;Acme products&quot;,
        .helptext = &quot;Most popular products produced by the Acme Corporation&quot;,
    },
};
</pre></div>
</div>
<p>The above data structures initialize an instance domain of the set of products produced in a factory by the fictional “Acme Corporation”. These structures are
directly comparable to several concepts we have seen already (and for good reason - the MMV PMDA must interpret the applications intentions and properly export
instances on its behalf):</p>
<ul class="simple">
<li>mmv_instances_t maps to pmdaInstid, as in <a class="reference internal" href="WritingPMDA.html#example-2-7-pmdainstid-structure"><span class="std std-ref">Example 2.7. pmdaInstid Structure</span></a></li>
<li>mmv_indom_t maps to pmdaIndom, as in <a class="reference internal" href="WritingPMDA.html#example-2-8-pmdaindom-structure"><span class="std std-ref">Example 2.8. pmdaIndom Structure</span></a> - the major difference is the addition of oneline and long help text, the purpose of
which should be self-explanatory at this stage.</li>
<li><em>serial</em> numbers, as in <a class="reference internal" href="WritingPMDA.html#example-2-9-pmindom-int-structure"><span class="std std-ref">Example 2.9. __pmInDom_int Structure</span></a></li>
</ul>
<p>Next, we shall create three metrics, all of which use this instance domain. These are the <strong>mmv.acme.products</strong> metrics, and they reflect the rates at which products
are built by the machines in the factory, how long these builds take for each product, and how long each product type spends queued (while waiting for factory capacity
to become available).</p>
<p id="example-4-2-memory-mapped-value-metrics-structures"><strong>Example 4.2. Memory Mapped Value Metrics Structures</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static mmv_metric_t metrics[] = {
    {   .name = &quot;products.count&quot;,
        .item = 7,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,0,1,0,0,PM_COUNT_ONE),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = &quot;Acme factory product throughput&quot;,
        .helptext =
&quot;Monotonic increasing counter of products produced in the Acme Corporation\n&quot;
&quot;factory since starting the Acme production application.  Quality guaranteed.&quot;,
    },
    {   .name = &quot;products.time&quot;,
        .item = 8,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,1,0,0,PM_TIME_USEC,0),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = &quot;Machine time spent producing Acme products&quot;,
        .helptext =
&quot;Machine time spent producing Acme Corporation products.  Does not include\n&quot;
&quot;time in queues waiting for production machinery.&quot;,
    },
    {   .name = &quot;products.queuetime&quot;,
        .item = 10,
        .type = MMV_TYPE_U64,
        .semantics = MMV_SEM_COUNTER,
        .dimension = MMV_UNITS(0,1,0,0,PM_TIME_USEC,0),
        .indom = ACME_PRODUCTS_INDOM,
        .shorttext = &quot;Queued time while producing Acme products&quot;,
        .helptext =
&quot;Time spent in the queue waiting to build Acme Corporation products,\n&quot;
&quot;while some other Acme product was being built instead of this one.&quot;,
    },
};
#define INDOM_COUNT (sizeof(indoms)/sizeof(indoms[0]))
#define METRIC_COUNT (sizeof(metrics)/sizeof(metrics[0]))
</pre></div>
</div>
<p>As was the case with the “products” instance domain before, these metric-defining data structures are directly comparable to PMDA data structures described earlier:</p>
<ul class="simple">
<li>mmv_metric_t maps to a pmDesc structure, as in <a class="reference internal" href="PMAPI.html#example-3-2-pmdesc-structure"><span class="std std-ref">Example 3.2. pmDesc Structure</span></a></li>
<li>MMV_TYPE, MMV_SEM, and MMV_UNITS map to PMAPI constructs for type, semantics, dimensionality and scale, as in <a class="reference internal" href="PMAPI.html#example-3-3-pmunits-and-pmdesc-structures"><span class="std std-ref">Example 3.3. pmUnits and pmDesc Structures</span></a></li>
<li><em>item</em> number, as in <a class="reference internal" href="WritingPMDA.html#example-2-3-pmid-int-structure"><span class="std std-ref">Example 2.3. __pmID_int Structure</span></a></li>
</ul>
<p>For the most part, all types and macros map directly to their core PCP counterparts, which the MMV PMDA will use when exporting the metrics. One important exception
is the introduction of the metric type MMV_TYPE_ELAPSED, which is discussed further in Section 4.4.4, “<a class="reference internal" href="#elapsed-time-measures">Elapsed Time Measures</a>”.</p>
<p>The compound metric types - aggregate and event type metrics - are not supported by the MMV format.</p>
</div>
<div class="section" id="getting-a-handle-on-mapped-values">
<h3>4.4.2. Getting a Handle on Mapped Values<a class="headerlink" href="#getting-a-handle-on-mapped-values" title="Permalink to this headline">¶</a></h3>
<p>Once metrics (and the instance domains they use) have been registered, the memory mapped file has been created and is ready for use. In order to be able to update
the individual metric values, however, we must find get a handle to the value. This is done using the <strong>mmv_lookup_value_desc</strong> function, as shown in
<a class="reference internal" href="#example-4-3-memory-mapped-value-handles">Example 4.3. Memory Mapped Value Handles</a>.</p>
<p id="example-4-3-memory-mapped-value-handles"><strong>Example 4.3. Memory Mapped Value Handles</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define ACME_CLUSTER 321        /* PMID cluster identifier */

int
main(int argc, char * argv[])
{
    void *base;
    pmAtomValue *count[ACME_PRODUCTS_COUNT];
    pmAtomValue *machine[ACME_PRODUCTS_COUNT];
    pmAtomValue *inqueue[ACME_PRODUCTS_COUNT];
    unsigned int working;
    unsigned int product;
    unsigned int i;

    base = mmv_stats_init(&quot;acme&quot;, ACME_CLUSTER, 0,
                          metrics, METRIC_COUNT, indoms, INDOM_COUNT);
    if (!base) {
        perror(&quot;mmv_stats_init&quot;);
        return 1;
    }

    for (i = 0; i &lt; ACME_PRODUCTS_COUNT; i++) {
        count[i] = mmv_lookup_value_desc(base,
                        &quot;products.count&quot;, products[i].external);
        machine[i] = mmv_lookup_value_desc(base,
                        &quot;products.time&quot;, products[i].external);
        inqueue[i] = mmv_lookup_value_desc(base,
                        &quot;products.queuetime&quot;, products[i].external);
    }
</pre></div>
</div>
<p>Space in the mapping file for every value is set aside at initialization time (by the <strong>mmv_stats_init</strong> function) - that is, space for each and every metric, and
each value (instance) of each metric when an instance domain is used. To find the handle to the space set aside for one individual value requires the tuple of base
memory address of the mapping, metric name, and instance name. In the case of metrics with no instance domain, the final instance name parameter should be either
NULL or the empty string.</p>
</div>
<div class="section" id="updating-mapped-values">
<h3>4.4.3. Updating Mapped Values<a class="headerlink" href="#updating-mapped-values" title="Permalink to this headline">¶</a></h3>
<p>At this stage we have individual handles (pointers) to each instrumentation point, we can now start modifying these values and observing changes through the PCP
infrastructure. Notice that each handle is simply the canonical <strong>pmAtomValue</strong> pointer, as defined in <a class="reference internal" href="PMAPI.html#example-3-18-pmatomvalue-structure"><span class="std std-ref">Example 3.18. pmAtomValue Structure</span></a>,
which is a union providing sufficient space to hold any single value.</p>
<p>This pointer can be either manipulated directly, or using helper functions provided by the <strong>pcp_mmv</strong> API, such as the <strong>mmv_stats_inc</strong> and <strong>mmv_stats_set</strong> functions.</p>
<p id="example-4-4-memory-mapped-value-updates"><strong>Example 4.4. Memory Mapped Value Updates</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while (1) {
    /* choose a random number between 0-N -&gt; product */
    product = rand() % ACME_PRODUCTS_COUNT;

    /* assign a time spent &quot;working&quot; on this product */
    working = rand() % 50000;

    /* pretend to &quot;work&quot; so process doesn&#39;t burn CPU */
    usleep(working);

    /* update the memory mapped values for this one: */
    /* one more product produced and work time spent */
    mmv_inc_value(base, machine[product], working); /* API */
    count[product]-&gt;ull += 1;     /* or direct mmap update */

    /* all other products are &quot;queued&quot; for this time */
    for (i = 0; i &lt; ACME_PRODUCTS_COUNT; i++)
        if (i != product)
            mmv_inc_value(base, inqueue[i], working);
}
</pre></div>
</div>
<p>At this stage, it will be informative to compile and run the complete example program, which can be found in <code class="docutils literal notranslate"><span class="pre">${PCP_DEMOS_DIR}/mmv/acme.c</span></code>. There is an associated
<strong>Makefile</strong> to build it, in the same directory. Running the <strong>acme</strong> binary creates the instrumentation shown in <a class="reference internal" href="#example-4-5-memory-mapped-value-reports">Example 4.5. Memory Mapped Value Reports</a>, with
live values letting us explore simple queueing effects in products being created on the ACME factory floor.</p>
<p id="example-4-5-memory-mapped-value-reports"><strong>Example 4.5. Memory Mapped Value Reports</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              pminfo -m mmv.acme
mmv.acme.products.queuetime PMID: 70.321.10
mmv.acme.products.time PMID: 70.321.8
mmv.acme.products.count PMID: 70.321.7

pmval -f2 -s3 mmv.acme.products.time
metric:    mmv.acme.products.time
host:      localhost
semantics: cumulative counter (converting to rate)
units:     microsec (converting to time utilization)
samples:   3
interval:  1.00 sec

               Anvils               Rockets    Giant_Rubber_Bands
                 0.37                  0.12                  0.50
                 0.35                  0.25                  0.38
                 0.57                  0.20                  0.23
</pre></div>
</div>
<p>Experimentation with the algorithm from <a class="reference internal" href="#example-4-4-memory-mapped-value-updates">Example 4.4. Memory Mapped Value Updates</a> is encouraged. In particular, observe the effects of rate conversion (counter
metric type) of a metric with units of “time” (PM_TIME_*). The reported values are calculated over a sampling interval, which also has units of “time”, forming a
utilization. This is extremely valuable performance analysis currency - comparable metrics would include processor utilization, disk spindle utilization, and so
forth.</p>
</div>
<div class="section" id="elapsed-time-measures">
<h3>4.4.4. Elapsed Time Measures<a class="headerlink" href="#elapsed-time-measures" title="Permalink to this headline">¶</a></h3>
<p>One problem with the instrumentation model embodied by the <strong>pcp_mmv</strong> library is providing timing information for long-running operations. For instrumenting
long-running operations, like uploading downloading a file, the overall operation may be broken into smaller, discrete units of work which can be easily
instrumented in terms of operations and througput measures. In other cases, there are no divisible units for long-running operations (for example a black-box
library call) and instrumenting these operations presents a challenge. Sometimes the best that can be done is adding the instrumentation point at the completion
of the operation, and simply accept the “bursty” nature of this approach. In these problematic cases, the work completed in one sampling-interval may have begun
several intervals before, from the point of view of the monitoring tool, which can lead to misleading results.</p>
<p>One technique that is available to combat this is through use of the MMV_TYPE_ELAPSED metric type, which provides the concept of a “timed section” of code. This
mechanism stores the start time of an operation along with the mapped metric value (an “elapsed time” counter), via the <strong>mmv_stats_interval_start</strong> instrumentation
function. Then, with help from the MMV PMDA which recognizes this type, the act of sampling the metric value causes an <strong>interim</strong> timestamp to be taken (by the
MMV PMDA, not the application) and <strong>combined</strong> with the initial timestamp to form a more accurate reflection of time spent within the timed section, which
effectively smooths out the bursty nature of the instrumentation.</p>
<p>The completion of each timed section of code is marked by a call to <strong>mmv_stats_interval_end</strong> which signifies to the MMV PMDA that the operation is not active,
and no extra “in-progress” time should be applied to the exported value. At that time, the elapsed time for the entire operation is calculated and accounted toward
metrics value.</p>
</div>
</div>
<div class="section" id="performance-instrumentation-and-tracing">
<h2>4.5. Performance Instrumentation and Tracing<a class="headerlink" href="#performance-instrumentation-and-tracing" title="Permalink to this headline">¶</a></h2>
<p>The <strong>pcp_trace</strong> library provides function calls for identifying sections of a program as transactions or events for examination by the trace PMDA, a user command
called <strong>pmdatrace</strong>. The <strong>pcp_trace</strong> library is described in the <strong>pmdatrace(3)</strong> man page.</p>
<p>The monitoring of transactions using the Performance Co-Pilot (PCP) infrastructure begins with a <strong>pmtracebegin</strong> call. Time is recorded from there to the
corresponding <strong>pmtraceend</strong> call (with matching tag identifier). A transaction in progress can be cancelled by calling <strong>pmtraceabort</strong>.</p>
<p>A second form of program instrumentation is available with the <strong>pmtracepoint</strong> function. This is a simpler form of monitoring that exports only the number of
times a particular point in a program is passed. The <strong>pmtraceobs</strong> and <strong>pmtracecount</strong> functions have similar semantics, but the former allows an arbitrary
numeric value to be passed to the trace PMDA.</p>
<p>The <strong>pmdatrace</strong> command is a PMDA that exports transaction performance metrics from application processes using the <strong>pcp_trace</strong> library; see the <strong>pmdatrace(1)</strong>
man page for details.</p>
</div>
<div class="section" id="trace-pmda-design">
<h2>4.6. Trace PMDA Design<a class="headerlink" href="#trace-pmda-design" title="Permalink to this headline">¶</a></h2>
<p>Trace PMDA design covers application interaction, sampling techniques, and configuring the trace PMDA.</p>
<div class="section" id="application-interaction">
<h3>4.6.1. Application Interaction<a class="headerlink" href="#application-interaction" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#figure-4-3-trace-pmda-overview">Figure 4.3. Trace PMDA Overview</a> describes the general state maintained within the trace PMDA.</p>
<div class="figure" id="id3">
<span id="figure-4-3-trace-pmda-overview"></span><img alt="../_images/trace.png" src="../_images/trace.png" />
<p class="caption"><span class="caption-text">Figure 4.3. Trace PMDA Overview</span></p>
</div>
<p>Applications that are linked with the <strong>libpcp_trace</strong> library make calls through the trace Application Programming Interface (API). These calls result in
interprocess communication of trace data between the application and the trace PMDA. This data consists of an identification tag and the performance data
associated with that particular tag. The trace PMDA aggregates the incoming information and periodically updates the exported summary information to describe
activity in the recent past.</p>
<p>As each protocol data unit (PDU) is received, its data is stored in the current working buffer. At the same time, the global counter associated with the particular
tag contained within the PDU is incremented. The working buffer contains all performance data that has arrived since the previous time interval elapsed. For additional
information about the working buffer, see Section 4.6.2.2, “<a class="reference internal" href="#rolling-window-periodic-sampling">Rolling-Window Periodic Sampling</a>”.</p>
</div>
<div class="section" id="sampling-techniques">
<h3>4.6.2. Sampling Techniques<a class="headerlink" href="#sampling-techniques" title="Permalink to this headline">¶</a></h3>
<p>The trace PMDA employs a rolling-window periodic sampling technique. The arrival time of the data at the trace PMDA in conjunction with the length of the sampling
period being maintained by the PMDA determines the recency of the data exported by the PMDA. Through the use of rolling-window sampling, the trace PMDA is able to
present a more accurate representation of the available trace data at any given time than it could through use of simple periodic sampling.</p>
<p>The rolling-window sampling technique affects the metrics in <a class="reference internal" href="#example-4-6-rolling-window-sampling-technique">Example 4.6. Rolling-Window Sampling Technique</a>:</p>
<p id="example-4-6-rolling-window-sampling-technique"><strong>Example 4.6. Rolling-Window Sampling Technique</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trace.observe.rate
trace.counter.rate
trace.point.rate
trace.transact.ave_time
trace.transact.max_time
trace.transact.min_time
trace.transact.rate
</pre></div>
</div>
<p>The remaining metrics are either global counters, control metrics, or the last seen observation value. Section 4.7, “<a class="reference internal" href="#trace-api">Trace API</a>”, documents in more detail all
metrics exported by the trace PMDA.</p>
<div class="section" id="simple-periodic-sampling">
<h4>4.6.2.1. Simple Periodic Sampling<a class="headerlink" href="#simple-periodic-sampling" title="Permalink to this headline">¶</a></h4>
<p>The simple periodic sampling technique uses a single historical buffer to store the history of events that have occurred over the sampling interval. As events occur,
they are recorded in the working buffer. At the end of each sampling interval, the working buffer (which at that time holds the historical data for the sampling
interval just finished) is copied into the historical buffer, and the working buffer is cleared. It is ready to hold new events from the sampling interval now
starting.</p>
</div>
<div class="section" id="rolling-window-periodic-sampling">
<h4>4.6.2.2. Rolling-Window Periodic Sampling<a class="headerlink" href="#rolling-window-periodic-sampling" title="Permalink to this headline">¶</a></h4>
<p>In contrast to simple periodic sampling with its single historical buffer, the rolling-window periodic sampling technique maintains a number of separate buffers.
One buffer is marked as the current working buffer, and the remainder of the buffers hold historical data. As each event occurs, the current working buffer is
updated to reflect it.</p>
<p>At a specified interval, the current working buffer and the accumulated data that it holds is moved into the set of historical buffers, and a new working buffer is
used. The specified interval is a function of the number of historical buffers maintained.</p>
<p>The primary advantage of the rolling-window sampling technique is seen at the point where data is actually exported. At this point, the data has a higher probability
of reflecting a more recent sampling period than the data exported using simple periodic sampling.</p>
<p>The data collected over each sample duration and exported using the rolling-window sampling technique provides a more up-to-date representation of the activity
during the most recently completed sample duration than simple periodic sampling as shown in <a class="reference internal" href="#figure-4-4-sample-duration-comparison">Figure 4.4. Sample Duration Comparison</a>.</p>
<div class="figure" id="id4">
<span id="figure-4-4-sample-duration-comparison"></span><img alt="../_images/trace-sampling.png" src="../_images/trace-sampling.png" />
<p class="caption"><span class="caption-text">Figure 4.4. Sample Duration Comparison</span></p>
</div>
<p>The trace PMDA allows the length of the sample duration to be configured, as well as the number of historical buffers that are maintained. The rolling-window
approach is implemented in the trace PMDA as a ring buffer (see <a class="reference internal" href="#figure-4-3-trace-pmda-overview">Figure 4.3. Trace PMDA Overview</a>).</p>
<p>When the current working buffer is moved into the set of historical buffers, the least recent historical buffer is cleared of data and becomes the new working buffer.</p>
</div>
<div class="section" id="rolling-window-periodic-sampling-example">
<h4>4.6.2.3. Rolling-Window Periodic Sampling Example<a class="headerlink" href="#rolling-window-periodic-sampling-example" title="Permalink to this headline">¶</a></h4>
<p>Consider the scenario where you want to know the rate of transactions over the last 10 seconds. You set the sampling rate for the trace PMDA to 10 seconds and fetch
the metric <strong>trace.transact.rate</strong>. So if in the last 10 seconds, 8 transactions took place, the transaction rate would be 8/10 or 0.8 transactions per second.</p>
<p>The trace PMDA does not actually do this. It instead does its calculations automatically at a subinterval of the sampling interval. Reconsider the 10-second scenario.
It has a calculation subinterval of 2 seconds as shown in <a class="reference internal" href="#figure-4-5-sampling-intervals">Figure 4.5. Sampling Intervals</a>.</p>
<div class="figure" id="id5">
<span id="figure-4-5-sampling-intervals"></span><img alt="../_images/trace-example.png" src="../_images/trace-example.png" />
<p class="caption"><span class="caption-text">Figure 4.5. Sampling Intervals</span></p>
</div>
<p>If at 13.5 seconds, you request the transaction rate, you receive a value of 0.7 transactions per second. In actual fact, the transaction rate was 0.8, but the
trace PMDA did its calculations on the sampling interval from 2 seconds to 12 seconds, and not from 3.5 seconds to 13.5 seconds. For efficiency, the trace PMDA
calculates the metrics on the last 10 seconds every 2 seconds. As a result, the PMDA is not driven each time a fetch request is received to do a calculation.</p>
</div>
</div>
<div class="section" id="configuring-the-trace-pmda">
<h3>4.6.3. Configuring the Trace PMDA<a class="headerlink" href="#configuring-the-trace-pmda" title="Permalink to this headline">¶</a></h3>
<p>The trace PMDA is configurable primarily through command-line options. The list of command-line options in <a class="reference internal" href="#table-4-1-selected-command-line-options">Table 4.1. Selected Command-Line Options</a> is not
exhaustive, but it identifies those options which are particularly relevant to tuning the manner in which performance data is collected.</p>
<p id="table-4-1-selected-command-line-options"><strong>Table 4.1. Selected Command-Line Options</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Option</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td>Access controls</td>
<td>The trace PMDA offers host-based access control. This control allows and disallows connections from instrumented applications running on specified hosts or
groups of hosts. Limits to the number of connections allowed from individual hosts can also be mandated.</td>
</tr>
<tr class="row-odd"><td>Sample duration</td>
<td>The interval over which metrics are to be maintained before being discarded is called the sample duration.</td>
</tr>
<tr class="row-even"><td>Number of historical buffers</td>
<td>The data maintained for the sample duration is held in a number of internal buffers within the trace PMDA. These are referred to as historical buffers. This
number is configurable so that the rolling window effect can be tuned within the sample duration.</td>
</tr>
<tr class="row-odd"><td>Counter and observation metric units</td>
<td>Since the data being exported by the <strong>trace.observe.value</strong> and <strong>trace.counter.count</strong> metrics are user-defined, the trace PMDA by default exports these
metrics with a type of “none.” A framework is provided that allows the user to make the type more specific (for example, bytes per second) and allows the
exported values to be plotted along with other performance metrics of similar units by tools like <strong>pmchart</strong>.</td>
</tr>
<tr class="row-even"><td>Instance domain refresh</td>
<td>The set of instances exported for each of the <strong>trace</strong> metrics can be cleared through the storable <strong>trace.control.reset</strong> metric.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="trace-api">
<h2>4.7. Trace API<a class="headerlink" href="#trace-api" title="Permalink to this headline">¶</a></h2>
<p>The <strong>libpcp_trace</strong> Application Programming Interface (API) is called from C, C++, Fortran, and Java. Each language has access to the complete set of functionality
offered by <strong>libpcp_trace</strong>. In some cases, the calling conventions differ slightly between languages. This section presents an overview of each of the different
tracing mechanisms offered by the API, as well as an explanation of their mappings to the actual performance metrics exported by the trace PMDA.</p>
<div class="section" id="transactions">
<h3>4.7.1. Transactions<a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h3>
<p>Paired calls to the <strong>pmtracebegin</strong> and <strong>pmtraceend</strong> API functions result in transaction data being sent to the trace PMDA with a measure of the time interval
between the two calls. This interval is the transaction service time. Using the <strong>pmtraceabort</strong> call causes data for that particular transaction to be discarded.
The trace PMDA exports transaction data through the following <strong>trace.transact</strong> metrics listed in <a class="reference internal" href="#table-4-2-trace-transact-metrics">Table 4.2. trace.transact Metrics</a>:</p>
<p id="table-4-2-trace-transact-metrics"><strong>Table 4.2. trace.transact Metrics</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Metric</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>trace.transact.ave_time</strong></td>
<td>The average service time per transaction type. This time is calculated over the last sample duration.</td>
</tr>
<tr class="row-odd"><td><strong>trace.transact.count</strong></td>
<td>The running count for each transaction type seen since the trace PMDA started.</td>
</tr>
<tr class="row-even"><td><strong>trace.transact.max_time</strong></td>
<td>The maximum service time per transaction type within the last sample duration.</td>
</tr>
<tr class="row-odd"><td><strong>trace.transact.min_time</strong></td>
<td>The minimum service time per transaction type within the last sample duration.</td>
</tr>
<tr class="row-even"><td><strong>trace.transact.rate</strong></td>
<td>The average rate at which each transaction type is completed. The rate is calculated over the last sample duration.</td>
</tr>
<tr class="row-odd"><td><strong>trace.transact.total_time</strong></td>
<td>The cumulative time spent processing each transaction since the trace PMDA started running.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="point-tracing">
<h3>4.7.2. Point Tracing<a class="headerlink" href="#point-tracing" title="Permalink to this headline">¶</a></h3>
<p>Point tracing allows the application programmer to export metrics related to salient events. The <strong>pmtracepoint</strong> function is most useful when start and end points
are not well defined. For example, this function is useful when the code branches in such a way that a transaction cannot be clearly identified, or when processing
does not follow a transactional model, or when the desired instrumentation is akin to event rates rather than event service times. This data is exported through the
trace.point metrics listed in <a class="reference internal" href="#table-4-3-trace-point-metrics">Table 4.3. trace.point Metrics</a>:</p>
<p id="table-4-3-trace-point-metrics"><strong>Table 4.3. trace.point Metrics</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Metric</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>trace.point.count</strong></td>
<td>Running count of point observations for each tag seen since the trace PMDA started.</td>
</tr>
<tr class="row-odd"><td><strong>trace.point.rate</strong></td>
<td>The average rate at which observation points occur for each tag within the last sample duration.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="observations-and-counters">
<h3>4.7.3. Observations and Counters<a class="headerlink" href="#observations-and-counters" title="Permalink to this headline">¶</a></h3>
<p>The <strong>pmtraceobs</strong> and <strong>pmtracecount</strong> functions have similar semantics to <strong>pmtracepoint</strong>, but also allow an arbitrary numeric value to be passed to the trace
PMDA. The most recent value for each tag is then immediately available from the PMDA. Observation data is exported through the <strong>trace.observe</strong> metrics listed in
<a class="reference internal" href="#table-4-4-trace-observe-metrics">Table 4.4. trace.observe Metrics</a>:</p>
<p id="table-4-4-trace-observe-metrics"><strong>Table 4.4. trace.observe Metrics</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Metric</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>trace.observe.count</strong></td>
<td>Running count of observations seen since the trace PMDA started.</td>
</tr>
<tr class="row-odd"><td><strong>trace.observe.rate</strong></td>
<td>The average rate at which observations for each tag occur. This rate is calculated over the last sample duration.</td>
</tr>
<tr class="row-even"><td><strong>trace.observe.value</strong></td>
<td>The numeric value associated with the observation last seen by the trace PMDA.</td>
</tr>
<tr class="row-odd"><td><strong>trace.counter</strong></td>
<td>Counter data is exported through the <strong>trace.counter</strong> metrics. The only difference between <strong>trace.counter</strong> and <strong>trace.observe</strong> metrics is that the
numeric value of <strong>trace.counter</strong> must be a monotonic increasing count.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="configuring-the-trace-library">
<h3>4.7.4. Configuring the Trace Library<a class="headerlink" href="#configuring-the-trace-library" title="Permalink to this headline">¶</a></h3>
<p>The trace library is configurable through the use of environment variables listed in <a class="reference internal" href="#table-4-5-environment-variables">Table 4.5. Environment Variables</a> as well as through the state flags listed in
<a class="reference internal" href="#table-4-6-state-flags">Table 4.6. State Flags</a>. Both provide diagnostic output and enable or disable the configurable functionality within the library.</p>
<p id="table-4-5-environment-variables"><strong>Table 4.5. Environment Variables</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>PCP_TRACE_HOST</strong></td>
<td>The name of the host where the trace PMDA is running.</td>
</tr>
<tr class="row-odd"><td><strong>PCP_TRACE_PORT</strong></td>
<td>TCP/IP port number on which the trace PMDA is accepting client connections.</td>
</tr>
<tr class="row-even"><td><strong>PCP_TRACE_TIMEOUT</strong></td>
<td>The number of seconds to wait until assuming that the initial connection is not going to be made, and timeout will occur. The default is three seconds.</td>
</tr>
<tr class="row-odd"><td><strong>PCP_TRACE_REQTIMEOUT</strong></td>
<td>The number of seconds to allow before timing out on awaiting acknowledgment from the trace PMDA after trace data has been sent to it. This variable has no
effect in the asynchronous trace protocol (refer to <a class="reference internal" href="#table-4-6-state-flags">Table 4.6. State Flags</a>).</td>
</tr>
<tr class="row-even"><td><strong>PCP_TRACE_RECONNECT</strong></td>
<td>A list of values which represents the backoff approach that the <strong>libpcp_trace</strong> library routines take when attempting to reconnect to the trace PMDA after
a connection has been lost. The list of values should be a positive number of seconds for the application to delay before making the next reconnection attempt.
When the final value in the list is reached, that value is used for all subsequent reconnection attempts.</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="#table-4-6-state-flags">Table 4.6. State Flags</a> are used to customize the operation of the <strong>libpcp_trace</strong> routines. These are registered through the <strong>pmtracestate</strong> call, and they
can be set either individually or together.</p>
<p id="table-4-6-state-flags"><strong>Table 4.6. State Flags</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Flag</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>PMTRACE_STATE_NONE</strong></td>
<td>The default. No state flags have been set, the fault-tolerant, synchronous protocol is used for communicating with the trace PMDA, and no diagnostic messages
are displayed by the <strong>libpcp_trace</strong> routines.</td>
</tr>
<tr class="row-odd"><td><strong>PMTRACE_STATE_API</strong></td>
<td>High-level diagnostics. This flag simply displays entry into each of the API routines.</td>
</tr>
<tr class="row-even"><td><strong>PMTRACE_STATE_COMMS</strong></td>
<td>Diagnostic messages related to establishing and maintaining the communication channel between application and PMDA.</td>
</tr>
<tr class="row-odd"><td><strong>PMTRACE_STATE_PDU</strong></td>
<td>The low-level details of the trace protocol data units (PDU) is displayed as each PDU is transmitted or received.</td>
</tr>
<tr class="row-even"><td><strong>PMTRACE_STATE_PDUBUF</strong></td>
<td>The full contents of the PDU buffers are dumped as PDUs are transmitted and received.</td>
</tr>
<tr class="row-odd"><td><strong>PMTRACE_STATE_NOAGENT</strong></td>
<td>Interprocess communication control. If this flag is set, it causes interprocess communication between the instrumented application and the trace PMDA to be
skipped. This flag is a debugging aid for applications using <strong>libpcp_trace</strong>.</td>
</tr>
<tr class="row-even"><td><strong>PMTRACE_STATE_ASYNC</strong></td>
<td>Asynchronous trace protocol. This flag enables the asynchronous trace protocol so that the application does not block awaiting acknowledgment PDUs from the
trace PMDA. In order for the flag to be effective, it must be set before using the other <strong>libpcp_trace</strong> entry points.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../REST_API/PMWEBAPI.html" class="btn btn-neutral float-right" title="PMWEBAPI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="PMAPI.html" class="btn btn-neutral float-left" title="3. PMAPI–The Performance Metrics API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Performance Co-Pilot

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>